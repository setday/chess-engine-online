/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/chess.js/dist/esm/chess.js":
/*!*************************************************!*\
  !*** ./node_modules/chess.js/dist/esm/chess.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BISHOP: () => (/* binding */ BISHOP),\n/* harmony export */   BLACK: () => (/* binding */ BLACK),\n/* harmony export */   Chess: () => (/* binding */ Chess),\n/* harmony export */   DEFAULT_POSITION: () => (/* binding */ DEFAULT_POSITION),\n/* harmony export */   KING: () => (/* binding */ KING),\n/* harmony export */   KNIGHT: () => (/* binding */ KNIGHT),\n/* harmony export */   PAWN: () => (/* binding */ PAWN),\n/* harmony export */   QUEEN: () => (/* binding */ QUEEN),\n/* harmony export */   ROOK: () => (/* binding */ ROOK),\n/* harmony export */   SQUARES: () => (/* binding */ SQUARES),\n/* harmony export */   WHITE: () => (/* binding */ WHITE),\n/* harmony export */   validateFen: () => (/* binding */ validateFen)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\nconst WHITE = 'w';\nconst BLACK = 'b';\nconst PAWN = 'p';\nconst KNIGHT = 'n';\nconst BISHOP = 'b';\nconst ROOK = 'r';\nconst QUEEN = 'q';\nconst KING = 'k';\nconst DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nconst EMPTY = -1;\nconst FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q',\n};\n// prettier-ignore\nconst SQUARES = [\n    'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n    'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n    'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n    'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n    'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n    'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n    'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n    'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n];\nconst BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64,\n};\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88 = {\n    a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\n    a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\n    a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\n    a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\n    a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\n    a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\n    a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n};\nconst PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15],\n};\nconst PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1],\n};\n// prettier-ignore\nconst ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\n];\n// prettier-ignore\nconst RAYS = [\n    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\n    0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\n    0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\n    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\n    0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\n    1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\n    0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\n    0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\n    0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\n    0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\n    -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\n];\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 };\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [KNIGHT, BISHOP, ROOK, QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst SIDES = {\n    [KING]: BITS.KSIDE_CASTLE,\n    [QUEEN]: BITS.QSIDE_CASTLE,\n};\nconst ROOKS = {\n    w: [\n        { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n    ],\n    b: [\n        { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n    ],\n};\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 };\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square) {\n    return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square) {\n    return square & 0xf;\n}\nfunction isDigit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square) {\n    const f = file(square);\n    const r = rank(square);\n    return ('abcdefgh'.substring(f, f + 1) +\n        '87654321'.substring(r, r + 1));\n}\nfunction swapColor(color) {\n    return color === WHITE ? BLACK : WHITE;\n}\nfunction validateFen(fen) {\n    // 1st criterion: 6 space-seperated fields?\n    const tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: must contain six space-delimited fields',\n        };\n    }\n    // 2nd criterion: move number field is a integer value > 0?\n    const moveNumber = parseInt(tokens[5], 10);\n    if (isNaN(moveNumber) || moveNumber <= 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: move number must be a positive integer',\n        };\n    }\n    // 3rd criterion: half move counter is an integer >= 0?\n    const halfMoves = parseInt(tokens[4], 10);\n    if (isNaN(halfMoves) || halfMoves < 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: half move counter number must be a non-negative integer',\n        };\n    }\n    // 4th criterion: 4th field is a valid e.p.-string?\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n        return { ok: false, error: 'Invalid FEN: en-passant square is invalid' };\n    }\n    // 5th criterion: 3th field is a valid castle-string?\n    if (/[^kKqQ-]/.test(tokens[2])) {\n        return { ok: false, error: 'Invalid FEN: castling availability is invalid' };\n    }\n    // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n    if (!/^(w|b)$/.test(tokens[1])) {\n        return { ok: false, error: 'Invalid FEN: side-to-move is invalid' };\n    }\n    // 7th criterion: 1st field contains 8 rows?\n    const rows = tokens[0].split('/');\n    if (rows.length !== 8) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n        };\n    }\n    // 8th criterion: every row is valid?\n    for (let i = 0; i < rows.length; i++) {\n        // check for right sum of fields AND not two numbers in succession\n        let sumFields = 0;\n        let previousWasNumber = false;\n        for (let k = 0; k < rows[i].length; k++) {\n            if (isDigit(rows[i][k])) {\n                if (previousWasNumber) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (consecutive number)',\n                    };\n                }\n                sumFields += parseInt(rows[i][k], 10);\n                previousWasNumber = true;\n            }\n            else {\n                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (invalid piece)',\n                    };\n                }\n                sumFields += 1;\n                previousWasNumber = false;\n            }\n        }\n        if (sumFields !== 8) {\n            return {\n                ok: false,\n                error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n            };\n        }\n    }\n    // 9th criterion: is en-passant square legal?\n    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||\n        (tokens[3][1] == '6' && tokens[1] == 'b')) {\n        return { ok: false, error: 'Invalid FEN: illegal en-passant square' };\n    }\n    // 10th criterion: does chess position contain exact two kings?\n    const kings = [\n        { color: 'white', regex: /K/g },\n        { color: 'black', regex: /k/g },\n    ];\n    for (const { color, regex } of kings) {\n        if (!regex.test(tokens[0])) {\n            return { ok: false, error: `Invalid FEN: missing ${color} king` };\n        }\n        if ((tokens[0].match(regex) || []).length > 1) {\n            return { ok: false, error: `Invalid FEN: too many ${color} kings` };\n        }\n    }\n    // 11th criterion: are any pawns on the first or eighth rows?\n    if (Array.from(rows[0] + rows[7]).some((char) => char.toUpperCase() === 'P')) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: some pawns are on the edge rows',\n        };\n    }\n    return { ok: true };\n}\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move, moves) {\n    const from = move.from;\n    const to = move.to;\n    const piece = move.piece;\n    let ambiguities = 0;\n    let sameRank = 0;\n    let sameFile = 0;\n    for (let i = 0, len = moves.length; i < len; i++) {\n        const ambigFrom = moves[i].from;\n        const ambigTo = moves[i].to;\n        const ambigPiece = moves[i].piece;\n        /*\n         * if a move of the same piece type ends on the same to square, we'll need\n         * to add a disambiguator to the algebraic notation\n         */\n        if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n            ambiguities++;\n            if (rank(from) === rank(ambigFrom)) {\n                sameRank++;\n            }\n            if (file(from) === file(ambigFrom)) {\n                sameFile++;\n            }\n        }\n    }\n    if (ambiguities > 0) {\n        if (sameRank > 0 && sameFile > 0) {\n            /*\n             * if there exists a similar moving piece on the same rank and file as\n             * the move in question, use the square as the disambiguator\n             */\n            return algebraic(from);\n        }\n        else if (sameFile > 0) {\n            /*\n             * if the moving piece rests on the same file, use the rank symbol as the\n             * disambiguator\n             */\n            return algebraic(from).charAt(1);\n        }\n        else {\n            // else use the file symbol\n            return algebraic(from).charAt(0);\n        }\n    }\n    return '';\n}\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\n    const r = rank(to);\n    if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n        for (let i = 0; i < PROMOTIONS.length; i++) {\n            const promotion = PROMOTIONS[i];\n            moves.push({\n                color,\n                from,\n                to,\n                piece,\n                captured,\n                promotion,\n                flags: flags | BITS.PROMOTION,\n            });\n        }\n    }\n    else {\n        moves.push({\n            color,\n            from,\n            to,\n            piece,\n            captured,\n            flags,\n        });\n    }\n}\nfunction inferPieceType(san) {\n    let pieceType = san.charAt(0);\n    if (pieceType >= 'a' && pieceType <= 'h') {\n        const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n        if (matches) {\n            return undefined;\n        }\n        return PAWN;\n    }\n    pieceType = pieceType.toLowerCase();\n    if (pieceType === 'o') {\n        return KING;\n    }\n    return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nfunction trimFen(fen) {\n    /*\n     * remove last two fields in FEN string as they're not needed when checking\n     * for repetition\n     */\n    return fen.split(' ').slice(0, 4).join(' ');\n}\nclass Chess {\n    _board = new Array(128);\n    _turn = WHITE;\n    _header = {};\n    _kings = { w: EMPTY, b: EMPTY };\n    _epSquare = -1;\n    _halfMoves = 0;\n    _moveNumber = 0;\n    _history = [];\n    _comments = {};\n    _castling = { w: 0, b: 0 };\n    // tracks number of times a position has been seen for repetition checking\n    _positionCount = {};\n    constructor(fen = DEFAULT_POSITION) {\n        this.load(fen);\n    }\n    clear({ preserveHeaders = false } = {}) {\n        this._board = new Array(128);\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._turn = WHITE;\n        this._castling = { w: 0, b: 0 };\n        this._epSquare = EMPTY;\n        this._halfMoves = 0;\n        this._moveNumber = 1;\n        this._history = [];\n        this._comments = {};\n        this._header = preserveHeaders ? this._header : {};\n        this._positionCount = {};\n        /*\n         * Delete the SetUp and FEN headers (if preserved), the board is empty and\n         * these headers don't make sense in this state. They'll get added later\n         * via .load() or .put()\n         */\n        delete this._header['SetUp'];\n        delete this._header['FEN'];\n    }\n    removeHeader(key) {\n        if (key in this._header) {\n            delete this._header[key];\n        }\n    }\n    load(fen, { skipValidation = false, preserveHeaders = false } = {}) {\n        let tokens = fen.split(/\\s+/);\n        // append commonly omitted fen tokens\n        if (tokens.length >= 2 && tokens.length < 6) {\n            const adjustments = ['-', '-', '0', '1'];\n            fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\n        }\n        tokens = fen.split(/\\s+/);\n        if (!skipValidation) {\n            const { ok, error } = validateFen(fen);\n            if (!ok) {\n                throw new Error(error);\n            }\n        }\n        const position = tokens[0];\n        let square = 0;\n        this.clear({ preserveHeaders });\n        for (let i = 0; i < position.length; i++) {\n            const piece = position.charAt(i);\n            if (piece === '/') {\n                square += 8;\n            }\n            else if (isDigit(piece)) {\n                square += parseInt(piece, 10);\n            }\n            else {\n                const color = piece < 'a' ? WHITE : BLACK;\n                this._put({ type: piece.toLowerCase(), color }, algebraic(square));\n                square++;\n            }\n        }\n        this._turn = tokens[1];\n        if (tokens[2].indexOf('K') > -1) {\n            this._castling.w |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('Q') > -1) {\n            this._castling.w |= BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('k') > -1) {\n            this._castling.b |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('q') > -1) {\n            this._castling.b |= BITS.QSIDE_CASTLE;\n        }\n        this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n        this._halfMoves = parseInt(tokens[4], 10);\n        this._moveNumber = parseInt(tokens[5], 10);\n        this._updateSetup(fen);\n        this._incPositionCount(fen);\n    }\n    fen() {\n        let empty = 0;\n        let fen = '';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i]) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const { color, type: piece } = this._board[i];\n                fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n            }\n            else {\n                empty++;\n            }\n            if ((i + 1) & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n                if (i !== Ox88.h1) {\n                    fen += '/';\n                }\n                empty = 0;\n                i += 8;\n            }\n        }\n        let castling = '';\n        if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n            castling += 'K';\n        }\n        if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n            castling += 'Q';\n        }\n        if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n            castling += 'k';\n        }\n        if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n            castling += 'q';\n        }\n        // do we have an empty castling flag?\n        castling = castling || '-';\n        let epSquare = '-';\n        /*\n         * only print the ep square if en passant is a valid move (pawn is present\n         * and ep capture is not pinned)\n         */\n        if (this._epSquare !== EMPTY) {\n            const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n            const squares = [bigPawnSquare + 1, bigPawnSquare - 1];\n            for (const square of squares) {\n                // is the square off the board?\n                if (square & 0x88) {\n                    continue;\n                }\n                const color = this._turn;\n                // is there a pawn that can capture the epSquare?\n                if (this._board[square]?.color === color &&\n                    this._board[square]?.type === PAWN) {\n                    // if the pawn makes an ep capture, does it leave it's king in check?\n                    this._makeMove({\n                        color,\n                        from: square,\n                        to: this._epSquare,\n                        piece: PAWN,\n                        captured: PAWN,\n                        flags: BITS.EP_CAPTURE,\n                    });\n                    const isLegal = !this._isKingAttacked(color);\n                    this._undoMove();\n                    // if ep is legal, break and set the ep square in the FEN output\n                    if (isLegal) {\n                        epSquare = algebraic(this._epSquare);\n                        break;\n                    }\n                }\n            }\n        }\n        return [\n            fen,\n            this._turn,\n            castling,\n            epSquare,\n            this._halfMoves,\n            this._moveNumber,\n        ].join(' ');\n    }\n    /*\n     * Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object. If the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been made.\n     */\n    _updateSetup(fen) {\n        if (this._history.length > 0)\n            return;\n        if (fen !== DEFAULT_POSITION) {\n            this._header['SetUp'] = '1';\n            this._header['FEN'] = fen;\n        }\n        else {\n            delete this._header['SetUp'];\n            delete this._header['FEN'];\n        }\n    }\n    reset() {\n        this.load(DEFAULT_POSITION);\n    }\n    get(square) {\n        return this._board[Ox88[square]] || false;\n    }\n    put({ type, color }, square) {\n        if (this._put({ type, color }, square)) {\n            this._updateCastlingRights();\n            this._updateEnPassantSquare();\n            this._updateSetup(this.fen());\n            return true;\n        }\n        return false;\n    }\n    _put({ type, color }, square) {\n        // check for piece\n        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n            return false;\n        }\n        // check for valid square\n        if (!(square in Ox88)) {\n            return false;\n        }\n        const sq = Ox88[square];\n        // don't let the user place more than one king\n        if (type == KING &&\n            !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n            return false;\n        }\n        const currentPieceOnSquare = this._board[sq];\n        // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\n        if (currentPieceOnSquare && currentPieceOnSquare.type === KING) {\n            this._kings[currentPieceOnSquare.color] = EMPTY;\n        }\n        this._board[sq] = { type: type, color: color };\n        if (type === KING) {\n            this._kings[color] = sq;\n        }\n        return true;\n    }\n    remove(square) {\n        const piece = this.get(square);\n        delete this._board[Ox88[square]];\n        if (piece && piece.type === KING) {\n            this._kings[piece.color] = EMPTY;\n        }\n        this._updateCastlingRights();\n        this._updateEnPassantSquare();\n        this._updateSetup(this.fen());\n        return piece;\n    }\n    _updateCastlingRights() {\n        const whiteKingInPlace = this._board[Ox88.e1]?.type === KING &&\n            this._board[Ox88.e1]?.color === WHITE;\n        const blackKingInPlace = this._board[Ox88.e8]?.type === KING &&\n            this._board[Ox88.e8]?.color === BLACK;\n        if (!whiteKingInPlace ||\n            this._board[Ox88.a1]?.type !== ROOK ||\n            this._board[Ox88.a1]?.color !== WHITE) {\n            this._castling.w &= ~BITS.QSIDE_CASTLE;\n        }\n        if (!whiteKingInPlace ||\n            this._board[Ox88.h1]?.type !== ROOK ||\n            this._board[Ox88.h1]?.color !== WHITE) {\n            this._castling.w &= ~BITS.KSIDE_CASTLE;\n        }\n        if (!blackKingInPlace ||\n            this._board[Ox88.a8]?.type !== ROOK ||\n            this._board[Ox88.a8]?.color !== BLACK) {\n            this._castling.b &= ~BITS.QSIDE_CASTLE;\n        }\n        if (!blackKingInPlace ||\n            this._board[Ox88.h8]?.type !== ROOK ||\n            this._board[Ox88.h8]?.color !== BLACK) {\n            this._castling.b &= ~BITS.KSIDE_CASTLE;\n        }\n    }\n    _updateEnPassantSquare() {\n        if (this._epSquare === EMPTY) {\n            return;\n        }\n        const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16);\n        const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n        const attackers = [currentSquare + 1, currentSquare - 1];\n        if (this._board[startSquare] !== null ||\n            this._board[this._epSquare] !== null ||\n            this._board[currentSquare]?.color !== swapColor(this._turn) ||\n            this._board[currentSquare]?.type !== PAWN) {\n            this._epSquare = EMPTY;\n            return;\n        }\n        const canCapture = (square) => !(square & 0x88) &&\n            this._board[square]?.color === this._turn &&\n            this._board[square]?.type === PAWN;\n        if (!attackers.some(canCapture)) {\n            this._epSquare = EMPTY;\n        }\n    }\n    _attacked(color, square) {\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            // if empty square or wrong color\n            if (this._board[i] === undefined || this._board[i].color !== color) {\n                continue;\n            }\n            const piece = this._board[i];\n            const difference = i - square;\n            // skip - to/from square are the same\n            if (difference === 0) {\n                continue;\n            }\n            const index = difference + 119;\n            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n                if (piece.type === PAWN) {\n                    if (difference > 0) {\n                        if (piece.color === WHITE)\n                            return true;\n                    }\n                    else {\n                        if (piece.color === BLACK)\n                            return true;\n                    }\n                    continue;\n                }\n                // if the piece is a knight or a king\n                if (piece.type === 'n' || piece.type === 'k')\n                    return true;\n                const offset = RAYS[index];\n                let j = i + offset;\n                let blocked = false;\n                while (j !== square) {\n                    if (this._board[j] != null) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked)\n                    return true;\n            }\n        }\n        return false;\n    }\n    _isKingAttacked(color) {\n        const square = this._kings[color];\n        return square === -1 ? false : this._attacked(swapColor(color), square);\n    }\n    isAttacked(square, attackedBy) {\n        return this._attacked(attackedBy, Ox88[square]);\n    }\n    isCheck() {\n        return this._isKingAttacked(this._turn);\n    }\n    inCheck() {\n        return this.isCheck();\n    }\n    isCheckmate() {\n        return this.isCheck() && this._moves().length === 0;\n    }\n    isStalemate() {\n        return !this.isCheck() && this._moves().length === 0;\n    }\n    isInsufficientMaterial() {\n        /*\n         * k.b. vs k.b. (of opposite colors) with mate in 1:\n         * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n         *\n         * k.b. vs k.n. with mate in 1:\n         * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n         */\n        const pieces = {\n            b: 0,\n            n: 0,\n            r: 0,\n            q: 0,\n            k: 0,\n            p: 0,\n        };\n        const bishops = [];\n        let numPieces = 0;\n        let squareColor = 0;\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            squareColor = (squareColor + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            const piece = this._board[i];\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n                if (piece.type === BISHOP) {\n                    bishops.push(squareColor);\n                }\n                numPieces++;\n            }\n        }\n        // k vs. k\n        if (numPieces === 2) {\n            return true;\n        }\n        else if (\n        // k vs. kn .... or .... k vs. kb\n        numPieces === 3 &&\n            (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n            return true;\n        }\n        else if (numPieces === pieces[BISHOP] + 2) {\n            // kb vs. kb where any number of bishops are all on the same color\n            let sum = 0;\n            const len = bishops.length;\n            for (let i = 0; i < len; i++) {\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isThreefoldRepetition() {\n        return this._getPositionCount(this.fen()) >= 3;\n    }\n    isDraw() {\n        return (this._halfMoves >= 100 || // 50 moves per side = 100 half moves\n            this.isStalemate() ||\n            this.isInsufficientMaterial() ||\n            this.isThreefoldRepetition());\n    }\n    isGameOver() {\n        return this.isCheckmate() || this.isStalemate() || this.isDraw();\n    }\n    moves({ verbose = false, square = undefined, piece = undefined, } = {}) {\n        const moves = this._moves({ square, piece });\n        if (verbose) {\n            return moves.map((move) => this._makePretty(move));\n        }\n        else {\n            return moves.map((move) => this._moveToSan(move, moves));\n        }\n    }\n    _moves({ legal = true, piece = undefined, square = undefined, } = {}) {\n        const forSquare = square ? square.toLowerCase() : undefined;\n        const forPiece = piece?.toLowerCase();\n        const moves = [];\n        const us = this._turn;\n        const them = swapColor(us);\n        let firstSquare = Ox88.a8;\n        let lastSquare = Ox88.h1;\n        let singleSquare = false;\n        // are we generating moves for a single square?\n        if (forSquare) {\n            // illegal square, return empty moves\n            if (!(forSquare in Ox88)) {\n                return [];\n            }\n            else {\n                firstSquare = lastSquare = Ox88[forSquare];\n                singleSquare = true;\n            }\n        }\n        for (let from = firstSquare; from <= lastSquare; from++) {\n            // did we run off the end of the board\n            if (from & 0x88) {\n                from += 7;\n                continue;\n            }\n            // empty square or opponent, skip\n            if (!this._board[from] || this._board[from].color === them) {\n                continue;\n            }\n            const { type } = this._board[from];\n            let to;\n            if (type === PAWN) {\n                if (forPiece && forPiece !== type)\n                    continue;\n                // single square, non-capturing\n                to = from + PAWN_OFFSETS[us][0];\n                if (!this._board[to]) {\n                    addMove(moves, us, from, to, PAWN);\n                    // double square\n                    to = from + PAWN_OFFSETS[us][1];\n                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n                        addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN);\n                    }\n                }\n                // pawn captures\n                for (let j = 2; j < 4; j++) {\n                    to = from + PAWN_OFFSETS[us][j];\n                    if (to & 0x88)\n                        continue;\n                    if (this._board[to]?.color === them) {\n                        addMove(moves, us, from, to, PAWN, this._board[to].type, BITS.CAPTURE);\n                    }\n                    else if (to === this._epSquare) {\n                        addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE);\n                    }\n                }\n            }\n            else {\n                if (forPiece && forPiece !== type)\n                    continue;\n                for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n                    const offset = PIECE_OFFSETS[type][j];\n                    to = from;\n                    while (true) {\n                        to += offset;\n                        if (to & 0x88)\n                            break;\n                        if (!this._board[to]) {\n                            addMove(moves, us, from, to, type);\n                        }\n                        else {\n                            // own color, stop loop\n                            if (this._board[to].color === us)\n                                break;\n                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n                            break;\n                        }\n                        /* break, if knight or king */\n                        if (type === KNIGHT || type === KING)\n                            break;\n                    }\n                }\n            }\n        }\n        /*\n         * check for castling if we're:\n         *   a) generating all moves, or\n         *   b) doing single square move generation on the king's square\n         */\n        if (forPiece === undefined || forPiece === KING) {\n            if (!singleSquare || lastSquare === this._kings[us]) {\n                // king-side castling\n                if (this._castling[us] & BITS.KSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom + 2;\n                    if (!this._board[castlingFrom + 1] &&\n                        !this._board[castlingTo] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom + 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.KSIDE_CASTLE);\n                    }\n                }\n                // queen-side castling\n                if (this._castling[us] & BITS.QSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom - 2;\n                    if (!this._board[castlingFrom - 1] &&\n                        !this._board[castlingFrom - 2] &&\n                        !this._board[castlingFrom - 3] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom - 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.QSIDE_CASTLE);\n                    }\n                }\n            }\n        }\n        /*\n         * return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured)\n         */\n        if (!legal || this._kings[us] === -1) {\n            return moves;\n        }\n        // filter out illegal moves\n        const legalMoves = [];\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(us)) {\n                legalMoves.push(moves[i]);\n            }\n            this._undoMove();\n        }\n        return legalMoves;\n    }\n    move(move, { strict = false } = {}) {\n        /*\n         * The move function can be called with in the following parameters:\n         *\n         * .move('Nxb7')       <- argument is a case-sensitive SAN string\n         *\n         * .move({ from: 'h7', <- argument is a move object\n         *         to :'h8',\n         *         promotion: 'q' })\n         *\n         *\n         * An optional strict argument may be supplied to tell chess.js to\n         * strictly follow the SAN specification.\n         */\n        let moveObj = null;\n        if (typeof move === 'string') {\n            moveObj = this._moveFromSan(move, strict);\n        }\n        else if (typeof move === 'object') {\n            const moves = this._moves();\n            // convert the pretty move object to an ugly move object\n            for (let i = 0, len = moves.length; i < len; i++) {\n                if (move.from === algebraic(moves[i].from) &&\n                    move.to === algebraic(moves[i].to) &&\n                    (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n                    moveObj = moves[i];\n                    break;\n                }\n            }\n        }\n        // failed to find move\n        if (!moveObj) {\n            if (typeof move === 'string') {\n                throw new Error(`Invalid move: ${move}`);\n            }\n            else {\n                throw new Error(`Invalid move: ${JSON.stringify(move)}`);\n            }\n        }\n        /*\n         * need to make a copy of move because we can't generate SAN after the move\n         * is made\n         */\n        const prettyMove = this._makePretty(moveObj);\n        this._makeMove(moveObj);\n        this._incPositionCount(prettyMove.after);\n        return prettyMove;\n    }\n    _push(move) {\n        this._history.push({\n            move,\n            kings: { b: this._kings.b, w: this._kings.w },\n            turn: this._turn,\n            castling: { b: this._castling.b, w: this._castling.w },\n            epSquare: this._epSquare,\n            halfMoves: this._halfMoves,\n            moveNumber: this._moveNumber,\n        });\n    }\n    _makeMove(move) {\n        const us = this._turn;\n        const them = swapColor(us);\n        this._push(move);\n        this._board[move.to] = this._board[move.from];\n        delete this._board[move.from];\n        // if ep capture, remove the captured pawn\n        if (move.flags & BITS.EP_CAPTURE) {\n            if (this._turn === BLACK) {\n                delete this._board[move.to - 16];\n            }\n            else {\n                delete this._board[move.to + 16];\n            }\n        }\n        // if pawn promotion, replace with new piece\n        if (move.promotion) {\n            this._board[move.to] = { type: move.promotion, color: us };\n        }\n        // if we moved the king\n        if (this._board[move.to].type === KING) {\n            this._kings[us] = move.to;\n            // if we castled, move the rook next to the king\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                const castlingTo = move.to - 1;\n                const castlingFrom = move.to + 1;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            else if (move.flags & BITS.QSIDE_CASTLE) {\n                const castlingTo = move.to + 1;\n                const castlingFrom = move.to - 2;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            // turn off castling\n            this._castling[us] = 0;\n        }\n        // turn off castling if we move a rook\n        if (this._castling[us]) {\n            for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n                if (move.from === ROOKS[us][i].square &&\n                    this._castling[us] & ROOKS[us][i].flag) {\n                    this._castling[us] ^= ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n        // turn off castling if we capture a rook\n        if (this._castling[them]) {\n            for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n                if (move.to === ROOKS[them][i].square &&\n                    this._castling[them] & ROOKS[them][i].flag) {\n                    this._castling[them] ^= ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n        // if big pawn move, update the en passant square\n        if (move.flags & BITS.BIG_PAWN) {\n            if (us === BLACK) {\n                this._epSquare = move.to - 16;\n            }\n            else {\n                this._epSquare = move.to + 16;\n            }\n        }\n        else {\n            this._epSquare = EMPTY;\n        }\n        // reset the 50 move counter if a pawn is moved or a piece is captured\n        if (move.piece === PAWN) {\n            this._halfMoves = 0;\n        }\n        else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n            this._halfMoves = 0;\n        }\n        else {\n            this._halfMoves++;\n        }\n        if (us === BLACK) {\n            this._moveNumber++;\n        }\n        this._turn = them;\n    }\n    undo() {\n        const move = this._undoMove();\n        if (move) {\n            const prettyMove = this._makePretty(move);\n            this._decPositionCount(prettyMove.after);\n            return prettyMove;\n        }\n        return null;\n    }\n    _undoMove() {\n        const old = this._history.pop();\n        if (old === undefined) {\n            return null;\n        }\n        const move = old.move;\n        this._kings = old.kings;\n        this._turn = old.turn;\n        this._castling = old.castling;\n        this._epSquare = old.epSquare;\n        this._halfMoves = old.halfMoves;\n        this._moveNumber = old.moveNumber;\n        const us = this._turn;\n        const them = swapColor(us);\n        this._board[move.from] = this._board[move.to];\n        this._board[move.from].type = move.piece; // to undo any promotions\n        delete this._board[move.to];\n        if (move.captured) {\n            if (move.flags & BITS.EP_CAPTURE) {\n                // en passant capture\n                let index;\n                if (us === BLACK) {\n                    index = move.to - 16;\n                }\n                else {\n                    index = move.to + 16;\n                }\n                this._board[index] = { type: PAWN, color: them };\n            }\n            else {\n                // regular capture\n                this._board[move.to] = { type: move.captured, color: them };\n            }\n        }\n        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n            let castlingTo, castlingFrom;\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                castlingTo = move.to + 1;\n                castlingFrom = move.to - 1;\n            }\n            else {\n                castlingTo = move.to - 2;\n                castlingFrom = move.to + 1;\n            }\n            this._board[castlingTo] = this._board[castlingFrom];\n            delete this._board[castlingFrom];\n        }\n        return move;\n    }\n    pgn({ newline = '\\n', maxWidth = 0, } = {}) {\n        /*\n         * using the specification from http://www.chessclub.com/help/PGN-spec\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n         */\n        const result = [];\n        let headerExists = false;\n        /* add the PGN header information */\n        for (const i in this._header) {\n            /*\n             * TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             */\n            result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline);\n            headerExists = true;\n        }\n        if (headerExists && this._history.length) {\n            result.push(newline);\n        }\n        const appendComment = (moveString) => {\n            const comment = this._comments[this.fen()];\n            if (typeof comment !== 'undefined') {\n                const delimiter = moveString.length > 0 ? ' ' : '';\n                moveString = `${moveString}${delimiter}{${comment}}`;\n            }\n            return moveString;\n        };\n        // pop all of history onto reversed_history\n        const reversedHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        const moves = [];\n        let moveString = '';\n        // special case of a commented starting position with no moves\n        if (reversedHistory.length === 0) {\n            moves.push(appendComment(''));\n        }\n        // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n        while (reversedHistory.length > 0) {\n            moveString = appendComment(moveString);\n            const move = reversedHistory.pop();\n            // make TypeScript stop complaining about move being undefined\n            if (!move) {\n                break;\n            }\n            // if the position started with black to move, start PGN with #. ...\n            if (!this._history.length && move.color === 'b') {\n                const prefix = `${this._moveNumber}. ...`;\n                // is there a comment preceding the first move?\n                moveString = moveString ? `${moveString} ${prefix}` : prefix;\n            }\n            else if (move.color === 'w') {\n                // store the previous generated move_string if we have one\n                if (moveString.length) {\n                    moves.push(moveString);\n                }\n                moveString = this._moveNumber + '.';\n            }\n            moveString =\n                moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }));\n            this._makeMove(move);\n        }\n        // are there any other leftover moves?\n        if (moveString.length) {\n            moves.push(appendComment(moveString));\n        }\n        // is there a result?\n        if (typeof this._header.Result !== 'undefined') {\n            moves.push(this._header.Result);\n        }\n        /*\n         * history should be back to what it was before we started generating PGN,\n         * so join together moves\n         */\n        if (maxWidth === 0) {\n            return result.join('') + moves.join(' ');\n        }\n        // TODO (jah): huh?\n        const strip = function () {\n            if (result.length > 0 && result[result.length - 1] === ' ') {\n                result.pop();\n                return true;\n            }\n            return false;\n        };\n        // NB: this does not preserve comment whitespace.\n        const wrapComment = function (width, move) {\n            for (const token of move.split(' ')) {\n                if (!token) {\n                    continue;\n                }\n                if (width + token.length > maxWidth) {\n                    while (strip()) {\n                        width--;\n                    }\n                    result.push(newline);\n                    width = 0;\n                }\n                result.push(token);\n                width += token.length;\n                result.push(' ');\n                width++;\n            }\n            if (strip()) {\n                width--;\n            }\n            return width;\n        };\n        // wrap the PGN output at max_width\n        let currentWidth = 0;\n        for (let i = 0; i < moves.length; i++) {\n            if (currentWidth + moves[i].length > maxWidth) {\n                if (moves[i].includes('{')) {\n                    currentWidth = wrapComment(currentWidth, moves[i]);\n                    continue;\n                }\n            }\n            // if the current move will push past max_width\n            if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n                // don't end the line with whitespace\n                if (result[result.length - 1] === ' ') {\n                    result.pop();\n                }\n                result.push(newline);\n                currentWidth = 0;\n            }\n            else if (i !== 0) {\n                result.push(' ');\n                currentWidth++;\n            }\n            result.push(moves[i]);\n            currentWidth += moves[i].length;\n        }\n        return result.join('');\n    }\n    header(...args) {\n        for (let i = 0; i < args.length; i += 2) {\n            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n                this._header[args[i]] = args[i + 1];\n            }\n        }\n        return this._header;\n    }\n    loadPgn(pgn, { strict = false, newlineChar = '\\r?\\n', } = {}) {\n        function mask(str) {\n            return str.replace(/\\\\/g, '\\\\');\n        }\n        function parsePgnHeader(header) {\n            const headerObj = {};\n            const headers = header.split(new RegExp(mask(newlineChar)));\n            let key = '';\n            let value = '';\n            for (let i = 0; i < headers.length; i++) {\n                const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n                key = headers[i].replace(regex, '$1');\n                value = headers[i].replace(regex, '$2');\n                if (key.trim().length > 0) {\n                    headerObj[key] = value;\n                }\n            }\n            return headerObj;\n        }\n        // strip whitespace from head/tail of PGN block\n        pgn = pgn.trim();\n        /*\n         * RegExp to split header. Takes advantage of the fact that header and movetext\n         * will always have a blank line between them (ie, two newline_char's). Handles\n         * case where movetext is empty by matching newlineChar until end of string is\n         * matched - effectively trimming from the end extra newlineChar.\n         *\n         * With default newline_char, will equal:\n         * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n         */\n        const headerRegex = new RegExp('^(\\\\[((?:' +\n            mask(newlineChar) +\n            ')|.)*\\\\])' +\n            '((?:\\\\s*' +\n            mask(newlineChar) +\n            '){2}|(?:\\\\s*' +\n            mask(newlineChar) +\n            ')*$)');\n        // If no header given, begin with moves.\n        const headerRegexResults = headerRegex.exec(pgn);\n        const headerString = headerRegexResults\n            ? headerRegexResults.length >= 2\n                ? headerRegexResults[1]\n                : ''\n            : '';\n        // Put the board in the starting position\n        this.reset();\n        // parse PGN header\n        const headers = parsePgnHeader(headerString);\n        let fen = '';\n        for (const key in headers) {\n            // check to see user is including fen (possibly with wrong tag case)\n            if (key.toLowerCase() === 'fen') {\n                fen = headers[key];\n            }\n            this.header(key, headers[key]);\n        }\n        /*\n         * the permissive parser should attempt to load a fen tag, even if it's the\n         * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n         */\n        if (!strict) {\n            if (fen) {\n                this.load(fen, { preserveHeaders: true });\n            }\n        }\n        else {\n            /*\n             * strict parser - load the starting position indicated by [Setup '1']\n             * and [FEN position]\n             */\n            if (headers['SetUp'] === '1') {\n                if (!('FEN' in headers)) {\n                    throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\n                }\n                // don't clear the headers when loading\n                this.load(headers['FEN'], { preserveHeaders: true });\n            }\n        }\n        /*\n         * NB: the regexes below that delete move numbers, recursive annotations,\n         * and numeric annotation glyphs may also match text in comments. To\n         * prevent this, we transform comments by hex-encoding them in place and\n         * decoding them again after the other tokens have been deleted.\n         *\n         * While the spec states that PGN files should be ASCII encoded, we use\n         * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n         * for modern users\n         */\n        function toHex(s) {\n            return Array.from(s)\n                .map(function (c) {\n                /*\n                 * encodeURI doesn't transform most ASCII characters, so we handle\n                 * these ourselves\n                 */\n                return c.charCodeAt(0) < 128\n                    ? c.charCodeAt(0).toString(16)\n                    : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n            })\n                .join('');\n        }\n        function fromHex(s) {\n            return s.length == 0\n                ? ''\n                : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n        }\n        const encodeComment = function (s) {\n            s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n            return `{${toHex(s.slice(1, s.length - 1))}}`;\n        };\n        const decodeComment = function (s) {\n            if (s.startsWith('{') && s.endsWith('}')) {\n                return fromHex(s.slice(1, s.length - 1));\n            }\n        };\n        // delete header to get the moves\n        let ms = pgn\n            .replace(headerString, '')\n            .replace(\n        // encode comments so they don't get deleted below\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function (_match, bracket, semicolon) {\n            return bracket !== undefined\n                ? encodeComment(bracket)\n                : ' ' + encodeComment(`{${semicolon.slice(1)}}`);\n        })\n            .replace(new RegExp(mask(newlineChar), 'g'), ' ');\n        // delete recursive annotation variations\n        const ravRegex = /(\\([^()]+\\))+?/g;\n        while (ravRegex.test(ms)) {\n            ms = ms.replace(ravRegex, '');\n        }\n        // delete move numbers\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n        // delete ... indicating black to move\n        ms = ms.replace(/\\.\\.\\./g, '');\n        /* delete numeric annotation glyphs */\n        ms = ms.replace(/\\$\\d+/g, '');\n        // trim and get array of moves\n        let moves = ms.trim().split(new RegExp(/\\s+/));\n        // delete empty entries\n        moves = moves.filter((move) => move !== '');\n        let result = '';\n        for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n            const comment = decodeComment(moves[halfMove]);\n            if (comment !== undefined) {\n                this._comments[this.fen()] = comment;\n                continue;\n            }\n            const move = this._moveFromSan(moves[halfMove], strict);\n            // invalid move\n            if (move == null) {\n                // was the move an end of game marker\n                if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n                    result = moves[halfMove];\n                }\n                else {\n                    throw new Error(`Invalid move in PGN: ${moves[halfMove]}`);\n                }\n            }\n            else {\n                // reset the end of game marker if making a valid move\n                result = '';\n                this._makeMove(move);\n                this._incPositionCount(this.fen());\n            }\n        }\n        /*\n         * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n         * the termination marker. Only do this when headers are present, but the\n         * result tag is missing\n         */\n        if (result && Object.keys(this._header).length && !this._header['Result']) {\n            this.header('Result', result);\n        }\n    }\n    /*\n     * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} strict Use the strict SAN parser. It will throw errors\n     * on overly disambiguated moves (see below):\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */\n    _moveToSan(move, moves) {\n        let output = '';\n        if (move.flags & BITS.KSIDE_CASTLE) {\n            output = 'O-O';\n        }\n        else if (move.flags & BITS.QSIDE_CASTLE) {\n            output = 'O-O-O';\n        }\n        else {\n            if (move.piece !== PAWN) {\n                const disambiguator = getDisambiguator(move, moves);\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n                if (move.piece === PAWN) {\n                    output += algebraic(move.from)[0];\n                }\n                output += 'x';\n            }\n            output += algebraic(move.to);\n            if (move.promotion) {\n                output += '=' + move.promotion.toUpperCase();\n            }\n        }\n        this._makeMove(move);\n        if (this.isCheck()) {\n            if (this.isCheckmate()) {\n                output += '#';\n            }\n            else {\n                output += '+';\n            }\n        }\n        this._undoMove();\n        return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    _moveFromSan(move, strict = false) {\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\n        const cleanMove = strippedSan(move);\n        let pieceType = inferPieceType(cleanMove);\n        let moves = this._moves({ legal: true, piece: pieceType });\n        // strict parser\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n                return moves[i];\n            }\n        }\n        // the strict parser failed\n        if (strict) {\n            return null;\n        }\n        let piece = undefined;\n        let matches = undefined;\n        let from = undefined;\n        let to = undefined;\n        let promotion = undefined;\n        /*\n         * The default permissive (non-strict) parser allows the user to parse\n         * non-standard chess notations. This parser is only run after the strict\n         * Standard Algebraic Notation (SAN) parser has failed.\n         *\n         * When running the permissive parser, we'll run a regex to grab the piece, the\n         * to/from square, and an optional promotion piece. This regex will\n         * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n         * f7f8q, b1c3\n         *\n         * NOTE: Some positions and moves may be ambiguous when using the permissive\n         * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n         * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n         * move). In these cases, the permissive parser will default to the most\n         * basic interpretation (which is b1c3 parsing to Nc3).\n         */\n        let overlyDisambiguated = false;\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n        if (matches) {\n            piece = matches[1];\n            from = matches[2];\n            to = matches[3];\n            promotion = matches[4];\n            if (from.length == 1) {\n                overlyDisambiguated = true;\n            }\n        }\n        else {\n            /*\n             * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n             * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n             * there is one legal knight move to e7). In this case, the value of\n             * 'from' variable will be a rank or file, not a square.\n             */\n            matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n                if (from.length == 1) {\n                    overlyDisambiguated = true;\n                }\n            }\n        }\n        pieceType = inferPieceType(cleanMove);\n        moves = this._moves({\n            legal: true,\n            piece: piece ? piece : pieceType,\n        });\n        if (!to) {\n            return null;\n        }\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (!from) {\n                // if there is no from square, it could be just 'x' missing from a capture\n                if (cleanMove ===\n                    strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')) {\n                    return moves[i];\n                }\n                // hand-compare move properties with the results from our permissive regex\n            }\n            else if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                Ox88[from] == moves[i].from &&\n                Ox88[to] == moves[i].to &&\n                (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                return moves[i];\n            }\n            else if (overlyDisambiguated) {\n                /*\n                 * SPECIAL CASE: we parsed a move string that may have an unneeded\n                 * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n                 */\n                const square = algebraic(moves[i].from);\n                if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                    Ox88[to] == moves[i].to &&\n                    (from == square[0] || from == square[1]) &&\n                    (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                    return moves[i];\n                }\n            }\n        }\n        return null;\n    }\n    ascii() {\n        let s = '   +------------------------+\\n';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // display the rank\n            if (file(i) === 0) {\n                s += ' ' + '87654321'[rank(i)] + ' |';\n            }\n            if (this._board[i]) {\n                const piece = this._board[i].type;\n                const color = this._board[i].color;\n                const symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n                s += ' ' + symbol + ' ';\n            }\n            else {\n                s += ' . ';\n            }\n            if ((i + 1) & 0x88) {\n                s += '|\\n';\n                i += 8;\n            }\n        }\n        s += '   +------------------------+\\n';\n        s += '     a  b  c  d  e  f  g  h';\n        return s;\n    }\n    perft(depth) {\n        const moves = this._moves({ legal: false });\n        let nodes = 0;\n        const color = this._turn;\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(color)) {\n                if (depth - 1 > 0) {\n                    nodes += this.perft(depth - 1);\n                }\n                else {\n                    nodes++;\n                }\n            }\n            this._undoMove();\n        }\n        return nodes;\n    }\n    // pretty = external move object\n    _makePretty(uglyMove) {\n        const { color, piece, from, to, flags, captured, promotion } = uglyMove;\n        let prettyFlags = '';\n        for (const flag in BITS) {\n            if (BITS[flag] & flags) {\n                prettyFlags += FLAGS[flag];\n            }\n        }\n        const fromAlgebraic = algebraic(from);\n        const toAlgebraic = algebraic(to);\n        const move = {\n            color,\n            piece,\n            from: fromAlgebraic,\n            to: toAlgebraic,\n            san: this._moveToSan(uglyMove, this._moves({ legal: true })),\n            flags: prettyFlags,\n            lan: fromAlgebraic + toAlgebraic,\n            before: this.fen(),\n            after: '',\n        };\n        // generate the FEN for the 'after' key\n        this._makeMove(uglyMove);\n        move.after = this.fen();\n        this._undoMove();\n        if (captured) {\n            move.captured = captured;\n        }\n        if (promotion) {\n            move.promotion = promotion;\n            move.lan += promotion;\n        }\n        return move;\n    }\n    turn() {\n        return this._turn;\n    }\n    board() {\n        const output = [];\n        let row = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i] == null) {\n                row.push(null);\n            }\n            else {\n                row.push({\n                    square: algebraic(i),\n                    type: this._board[i].type,\n                    color: this._board[i].color,\n                });\n            }\n            if ((i + 1) & 0x88) {\n                output.push(row);\n                row = [];\n                i += 8;\n            }\n        }\n        return output;\n    }\n    squareColor(square) {\n        if (square in Ox88) {\n            const sq = Ox88[square];\n            return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n        }\n        return null;\n    }\n    history({ verbose = false } = {}) {\n        const reversedHistory = [];\n        const moveHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            if (verbose) {\n                moveHistory.push(this._makePretty(move));\n            }\n            else {\n                moveHistory.push(this._moveToSan(move, this._moves()));\n            }\n            this._makeMove(move);\n        }\n        return moveHistory;\n    }\n    /*\n     * Keeps track of position occurrence counts for the purpose of repetition\n     * checking. All three methods (`_inc`, `_dec`, and `_get`) trim the\n     * irrelevent information from the fen, initialising new positions, and\n     * removing old positions from the record if their counts are reduced to 0.\n     */\n    _getPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        return this._positionCount[trimmedFen] || 0;\n    }\n    _incPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        if (this._positionCount[trimmedFen] === undefined) {\n            this._positionCount[trimmedFen] = 0;\n        }\n        this._positionCount[trimmedFen] += 1;\n    }\n    _decPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        if (this._positionCount[trimmedFen] === 1) {\n            delete this._positionCount[trimmedFen];\n        }\n        else {\n            this._positionCount[trimmedFen] -= 1;\n        }\n    }\n    _pruneComments() {\n        const reversedHistory = [];\n        const currentComments = {};\n        const copyComment = (fen) => {\n            if (fen in this._comments) {\n                currentComments[fen] = this._comments[fen];\n            }\n        };\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        copyComment(this.fen());\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            this._makeMove(move);\n            copyComment(this.fen());\n        }\n        this._comments = currentComments;\n    }\n    getComment() {\n        return this._comments[this.fen()];\n    }\n    setComment(comment) {\n        this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n    }\n    deleteComment() {\n        const comment = this._comments[this.fen()];\n        delete this._comments[this.fen()];\n        return comment;\n    }\n    getComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            return { fen: fen, comment: this._comments[fen] };\n        });\n    }\n    deleteComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            const comment = this._comments[fen];\n            delete this._comments[fen];\n            return { fen: fen, comment: comment };\n        });\n    }\n    setCastlingRights(color, rights) {\n        for (const side of [KING, QUEEN]) {\n            if (rights[side] !== undefined) {\n                if (rights[side]) {\n                    this._castling[color] |= SIDES[side];\n                }\n                else {\n                    this._castling[color] &= ~SIDES[side];\n                }\n            }\n        }\n        this._updateCastlingRights();\n        const result = this.getCastlingRights(color);\n        return ((rights[KING] === undefined || rights[KING] === result[KING]) &&\n            (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN]));\n    }\n    getCastlingRights(color) {\n        return {\n            [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n            [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0,\n        };\n    }\n    moveNumber() {\n        return this._moveNumber;\n    }\n}\n//# sourceMappingURL=chess.js.map\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/chess.js/dist/esm/chess.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var chess_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chess.js */ \"./node_modules/chess.js/dist/esm/chess.js\");\n/* harmony import */ var cm_chessboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cm-chessboard */ \"./node_modules/cm-chessboard/src/Chessboard.js\");\n/* harmony import */ var cm_chessboard_src_extensions_markers_Markers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cm-chessboard/src/extensions/markers/Markers */ \"./node_modules/cm-chessboard/src/extensions/markers/Markers.js\");\n/* harmony import */ var cm_chessboard_src_extensions_promotion_dialog_PromotionDialog__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cm-chessboard/src/extensions/promotion-dialog/PromotionDialog */ \"./node_modules/cm-chessboard/src/extensions/promotion-dialog/PromotionDialog.js\");\n/* harmony import */ var cm_chessboard_src_extensions_arrows_Arrows__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cm-chessboard/src/extensions/arrows/Arrows */ \"./node_modules/cm-chessboard/src/extensions/arrows/Arrows.js\");\n/* harmony import */ var _nn_functions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./nn_functions */ \"./src/nn_functions.js\");\n\n\n\n\n\n\n\n\nconst modelLoadingSpan = document.getElementById(\"modelLoading\");\n\nlet model = null\nmodelLoadingSpan.classList.toggle(\"hidden\", false);\n_nn_functions__WEBPACK_IMPORTED_MODULE_5__.loadModel(\"./../models/TORCH_100EPOCHS_imot.onnx\").then(m => {\n  console.log(\"Model loaded\");\n  model = m;\n\n  // Log model details (if available)\n  if (model.name) {\n    console.log(\"Model Name:\", model.name);\n  } else {\n    console.log(\"Model loaded, but no name property found.\");\n  }\n\n  modelLoadingSpan.classList.toggle(\"hidden\", true);\n});\n\nlet autoPlay = false;\n\nvar chess = new chess_js__WEBPACK_IMPORTED_MODULE_0__.Chess()\nconst board = new cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.Chessboard(document.getElementById(\"board\"), {\n  position: chess.fen(),\n  assetsUrl: \"./assets/\",\n  style: {borderType: cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.BORDER_TYPE.none, pieces: {file: \"pieces/standard.svg\"}, animationDuration: 300},\n  orientation: cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.COLOR.white,\n  extensions: [\n      {class: cm_chessboard_src_extensions_markers_Markers__WEBPACK_IMPORTED_MODULE_2__.Markers, props: {autoMarkers: cm_chessboard_src_extensions_markers_Markers__WEBPACK_IMPORTED_MODULE_2__.MARKER_TYPE.square}},\n      {class: cm_chessboard_src_extensions_promotion_dialog_PromotionDialog__WEBPACK_IMPORTED_MODULE_3__.PromotionDialog},\n      {class: cm_chessboard_src_extensions_arrows_Arrows__WEBPACK_IMPORTED_MODULE_4__.Arrows },\n  ]\n});\n\nconst changeOrientationButton = document.getElementById(\"flipBoardButton\");\nchangeOrientationButton.addEventListener(\"click\", () => {\n  board.setOrientation(board.getOrientation() === cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.COLOR.white ? cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.COLOR.black : cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.COLOR.white);\n  setTimeout(_ => {\n    flipTurn();\n  }, 300);\n});\n\nconst autoPlayButton = document.getElementById(\"autoPlayButton\");\nautoPlayButton.addEventListener(\"click\", () => {\n  autoPlay = !autoPlay;\n  flipTurn();\n});\n\nconst overlay = document.getElementById(\"overlay\");\nconst gameOverText = document.getElementById(\"gameOverText\");\nconst gameCodeButton = document.getElementById(\"gameCode\");\nconst restartButton = document.getElementById(\"restartButton\");\n\nrestartButton.addEventListener(\"click\", () => {\n  chess.reset();\n  board.setPosition(chess.fen(), true);\n  overlay.classList.toggle(\"hidden\", true);\n  flipTurn();\n});\n\ngameCodeButton.addEventListener(\"click\", () => {\n  navigator.clipboard.writeText(chess.pgn() + \" *\").then(() => {\n    alert(\"Game code copied to clipboard!\");\n  });\n});\n\nfunction make_move(move) {\n  chess.move(move);\n  board.setPosition(chess.fen(), true);\n\n  setTimeout(_ => {\n    flipTurn();\n  }, 100);\n}\n\nasync function makeEngineMove(chessboard) {\n  const possibleMoves = chess.moves({verbose: true});\n  const possibleMovesLan = possibleMoves.map((move) => move.lan);\n\n  if (possibleMoves.length > 0) {\n    while (model === null) {\n      await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n\n    const prediction = await _nn_functions__WEBPACK_IMPORTED_MODULE_5__.predictMoves(chess, model);\n    const predictionPossible = prediction.filter(move => possibleMovesLan.includes(move));\n    if (predictionPossible.length > 0) {\n      make_move(predictionPossible[0]);\n    } else {\n      console.log(\"Bot can't make move so it will make a random move\");\n      make_move(possibleMoves[Math.floor(Math.random() * possibleMoves.length)]);\n    }\n  }\n}\n\nfunction flipTurn() {\n  // check if the game is over\n  if (chess.isCheckmate()) {\n    gameOverText.innerText = chess.turn() === board.getOrientation() ? \"You got checkmated!\" : \"You checkmated the opponent!\";\n    overlay.classList.toggle(\"hidden\", false);\n    return;\n  }\n  if (chess.isDraw()) {\n    chess.loadPgn(chess.pgn() + \" 1/2-1/2\");\n    gameOverText.innerText = \"It's a draw!\";\n    overlay.classList.toggle(\"hidden\", false);\n    return;\n  }\n\n  if (chess.turn() === board.getOrientation() && !autoPlay) {\n    board.enableMoveInput(inputHandler, board.getOrientation());\n  } else {\n    board.disableMoveInput();\n    makeEngineMove(board);\n  }\n}\n\nfunction inputHandler(event) {\n  if(event.type === cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.INPUT_EVENT_TYPE.movingOverSquare) {\n    return\n  }\n\n  if(event.type !== cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.INPUT_EVENT_TYPE.moveInputFinished) {\n    event.chessboard.removeLegalMovesMarkers();\n  }\n  if (event.type === cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.INPUT_EVENT_TYPE.moveInputStarted) {\n    const moves = chess.moves({square: event.squareFrom, verbose: true});\n    event.chessboard.addLegalMovesMarkers(moves);\n    return moves.length > 0;\n  }\n  if (event.type === cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.INPUT_EVENT_TYPE.moveInputFinished) {\n    if(event.legalMove) {\n      event.chessboard.disableMoveInput();\n    }\n    return;\n  }\n\n  if (event.type === cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.INPUT_EVENT_TYPE.validateMoveInput) {\n    const move = {from: event.squareFrom, to: event.squareTo, promotion: event.promotion};\n    let result = false;\n\n    try {\n      result = chess.move(move);\n\n      event.chessboard.state.moveInputProcess.then(() => {\n        event.chessboard.setPosition(chess.fen(), true).then(() => {\n          flipTurn();\n        })\n      })\n    } catch (e) {\n      let possibleMoves = chess.moves({square: event.squareFrom, verbose: true});\n\n      for (const possibleMove of possibleMoves) {\n        if (!possibleMove.promotion || possibleMove.to !== event.squareTo) {\n          continue;\n        }\n\n        event.chessboard.showPromotionDialog(event.squareTo, cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.COLOR.white, (result) => {\n          if (result.type === cm_chessboard_src_extensions_promotion_dialog_PromotionDialog__WEBPACK_IMPORTED_MODULE_3__.PROMOTION_DIALOG_RESULT_TYPE.pieceSelected) {\n            const move = {from: event.squareFrom, to: event.squareTo, promotion: result.piece.charAt(1)};\n              \n            make_move(move);\n          } else {\n            event.chessboard.enableMoveInput(inputHandler, event.chessboard.getOrientation());\n            event.chessboard.setPosition(chess.fen(), true);\n          }\n        });\n\n        return true;\n      }\n    }\n    return result;\n  }\n}\n\nboard.enableMoveInput(inputHandler, cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.COLOR.white);\n\n\n//# sourceURL=webpack://chess-bot-online/./src/index.js?");

/***/ }),

/***/ "./src/nn_functions.js":
/*!*****************************!*\
  !*** ./src/nn_functions.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadModel: () => (/* binding */ loadModel),\n/* harmony export */   predictMoves: () => (/* binding */ predictMoves)\n/* harmony export */ });\n/* harmony import */ var _models_heavy_move_to_int_imot_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/heavy_move_to_int_imot.json */ \"./models/heavy_move_to_int_imot.json\");\n// import * as ort from 'onnxruntime-web';\n\n\n\nasync function loadModel(path) {\n    const session = new onnx.InferenceSession();\n    await session.loadModel(path);\n    return session;\n}\n\nfunction str2Pos(str) {\n    return [str[1] - 1, str.charCodeAt(0) - 97];\n}\n\nfunction board2Matrix(board, legalMoves) {\n    let matrix = new Array(13).fill([]).map(() =>\n        new Array(8).fill([]).map(() =>\n            new Array(8).fill(0.0)\n        )\n    );\n\n    for (const row of board) {\n        for (const cell of row) {\n            if (cell === null) {\n                continue;\n            }\n\n            const { type, color, square } = cell;\n            const [row, col] = str2Pos(square);\n            const piece_type = ['p', 'n', 'b', 'r', 'q', 'k'].indexOf(type);\n            const piece_color = ['w', 'b'].indexOf(color) * 6;\n    \n            matrix[piece_type + piece_color][row][col] = 1.0;    \n        }\n    }\n\n    for (const move of legalMoves) {\n        const { to } = move;\n        const [row, col] = str2Pos(to);\n        matrix[12][row][col] = 1.0;\n    }\n\n    return matrix;\n}\n\nlet indexes_to_move = null;\n\nfunction initializeIndexesToMove() {\n    indexes_to_move = {};\n\n    for (const move in _models_heavy_move_to_int_imot_json__WEBPACK_IMPORTED_MODULE_0__) {\n        indexes_to_move[_models_heavy_move_to_int_imot_json__WEBPACK_IMPORTED_MODULE_0__[move]] = move;\n    }\n}\n\nasync function predictMoves(game, model) {\n    const board = game.board();\n    const legalMoves = game.moves({ verbose: true });\n    const matrix = board2Matrix(board, legalMoves);\n    const tensor = new onnx.Tensor(matrix.flat(2), 'float32', [1, 13, 8, 8]);\n\n    // Make the prediction\n    const prediction = await model.run([tensor]);\n    \n    // Unpack the propabilities of the moves\n    const moveProps = prediction.values().next().value.data;\n    const movePropsD = Array.from(moveProps);\n    \n    // Apply softmax to the propabilities\n    const softmax = movePropsD.map((x) => Math.exp(x));\n    const sum = softmax.reduce((a, b) => a + b, 0);\n    const softmaxed = softmax.map((x) => x / sum);\n\n    if (!indexes_to_move) {\n        initializeIndexesToMove();\n    }\n\n    // Sort the indexes of the moves by the propabilities\n    const sortedMoves = softmaxed\n        .map((x, i) => [x, i])\n        .sort((a, b) => b[0] - a[0])\n        .map((x) => indexes_to_move[x[1]]);\n\n    return sortedMoves;\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./src/nn_functions.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/Chessboard.js":
/*!******************************************************!*\
  !*** ./node_modules/cm-chessboard/src/Chessboard.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BORDER_TYPE: () => (/* reexport safe */ _view_ChessboardView_js__WEBPACK_IMPORTED_MODULE_4__.BORDER_TYPE),\n/* harmony export */   COLOR: () => (/* reexport safe */ _view_ChessboardView_js__WEBPACK_IMPORTED_MODULE_4__.COLOR),\n/* harmony export */   Chessboard: () => (/* binding */ Chessboard),\n/* harmony export */   FEN: () => (/* reexport safe */ _model_Position_js__WEBPACK_IMPORTED_MODULE_1__.FEN),\n/* harmony export */   INPUT_EVENT_TYPE: () => (/* reexport safe */ _view_ChessboardView_js__WEBPACK_IMPORTED_MODULE_4__.INPUT_EVENT_TYPE),\n/* harmony export */   PIECE: () => (/* binding */ PIECE),\n/* harmony export */   PIECES_FILE_TYPE: () => (/* binding */ PIECES_FILE_TYPE),\n/* harmony export */   PIECE_TYPE: () => (/* binding */ PIECE_TYPE),\n/* harmony export */   POINTER_EVENTS: () => (/* reexport safe */ _view_ChessboardView_js__WEBPACK_IMPORTED_MODULE_4__.POINTER_EVENTS)\n/* harmony export */ });\n/* harmony import */ var _model_ChessboardState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model/ChessboardState.js */ \"./node_modules/cm-chessboard/src/model/ChessboardState.js\");\n/* harmony import */ var _model_Position_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model/Position.js */ \"./node_modules/cm-chessboard/src/model/Position.js\");\n/* harmony import */ var _view_PositionAnimationsQueue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./view/PositionAnimationsQueue.js */ \"./node_modules/cm-chessboard/src/view/PositionAnimationsQueue.js\");\n/* harmony import */ var _model_Extension_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model/Extension.js */ \"./node_modules/cm-chessboard/src/model/Extension.js\");\n/* harmony import */ var _view_ChessboardView_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./view/ChessboardView.js */ \"./node_modules/cm-chessboard/src/view/ChessboardView.js\");\n/* harmony import */ var _lib_Utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/Utils.js */ \"./node_modules/cm-chessboard/src/lib/Utils.js\");\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\n\n\n\n\n\n\n\nconst PIECE = {\n    wp: \"wp\", wb: \"wb\", wn: \"wn\", wr: \"wr\", wq: \"wq\", wk: \"wk\",\n    bp: \"bp\", bb: \"bb\", bn: \"bn\", br: \"br\", bq: \"bq\", bk: \"bk\"\n}\nconst PIECE_TYPE = {\n    pawn: \"p\", knight: \"n\", bishop: \"b\", rook: \"r\", queen: \"q\", king: \"k\"\n}\nconst PIECES_FILE_TYPE = {\n    svgSprite: \"svgSprite\"\n}\n\n\n\n\n\n\nclass Chessboard {\n\n    constructor(context, props = {}) {\n        if (!context) {\n            throw new Error(\"container element is \" + context)\n        }\n        this.context = context\n        this.id = (Math.random() + 1).toString(36).substring(2, 8)\n        this.extensions = []\n        this.props = {\n            position: _model_Position_js__WEBPACK_IMPORTED_MODULE_1__.FEN.empty, // set position as fen, use FEN.start or FEN.empty as shortcuts\n            orientation: _view_ChessboardView_js__WEBPACK_IMPORTED_MODULE_4__.COLOR.white, // white on bottom\n            responsive: true, // resize the board automatically to the size of the context element\n            assetsUrl: \"./assets/\", // put all css and sprites in this folder, will be ignored for absolute urls of assets files\n            assetsCache: true, // cache the sprites, deactivate if you want to use multiple pieces sets in one page\n            style: {\n                cssClass: \"default\", // set the css theme of the board, try \"green\", \"blue\" or \"chess-club\"\n                showCoordinates: true, // show ranks and files\n                borderType: _view_ChessboardView_js__WEBPACK_IMPORTED_MODULE_4__.BORDER_TYPE.none, // \"thin\" thin border, \"frame\" wide border with coordinates in it, \"none\" no border\n                aspectRatio: 1, // height/width of the board\n                pieces: {\n                    type: PIECES_FILE_TYPE.svgSprite, // pieces are in an SVG sprite, no other type supported for now\n                    file: \"pieces/standard.svg\", // the filename of the sprite in `assets/pieces/` or an absolute url like `https://` or `/`\n                    tileSize: 40 // the tile size in the sprite\n                },\n                animationDuration: 300 // pieces animation duration in milliseconds. Disable all animations with `0`\n            },\n            extensions: [ /* {class: ExtensionClass, props: { ... }} */] // add extensions here\n        }\n        _lib_Utils_js__WEBPACK_IMPORTED_MODULE_5__.Utils.mergeObjects(this.props, props)\n        this.state = new _model_ChessboardState_js__WEBPACK_IMPORTED_MODULE_0__.ChessboardState()\n        this.view = new _view_ChessboardView_js__WEBPACK_IMPORTED_MODULE_4__.ChessboardView(this)\n        this.positionAnimationsQueue = new _view_PositionAnimationsQueue_js__WEBPACK_IMPORTED_MODULE_2__.PositionAnimationsQueue(this)\n        this.state.orientation = this.props.orientation\n        // instantiate extensions\n        for (const extensionData of this.props.extensions) {\n            this.addExtension(extensionData.class, extensionData.props)\n        }\n        this.view.redrawBoard()\n        this.state.position = new _model_Position_js__WEBPACK_IMPORTED_MODULE_1__.Position(this.props.position)\n        this.view.redrawPieces()\n        this.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_3__.EXTENSION_POINT.positionChanged)\n        this.initialized = Promise.resolve() // deprecated 2023-09-19 don't use this anymore\n    }\n\n    // API //\n\n    async setPiece(square, piece, animated = false) {\n        const positionFrom = this.state.position.clone()\n        this.state.position.setPiece(square, piece)\n        this.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_3__.EXTENSION_POINT.positionChanged)\n        return this.positionAnimationsQueue.enqueuePositionChange(positionFrom, this.state.position.clone(), animated)\n    }\n\n    async movePiece(squareFrom, squareTo, animated = false) {\n        const positionFrom = this.state.position.clone()\n        this.state.position.movePiece(squareFrom, squareTo)\n        this.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_3__.EXTENSION_POINT.positionChanged)\n        return this.positionAnimationsQueue.enqueuePositionChange(positionFrom, this.state.position.clone(), animated)\n    }\n\n    async setPosition(fen, animated = false) {\n        const positionFrom = this.state.position.clone()\n        const positionTo = new _model_Position_js__WEBPACK_IMPORTED_MODULE_1__.Position(fen)\n        if (positionFrom.getFen() !== positionTo.getFen()) {\n            this.state.position.setFen(fen)\n            this.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_3__.EXTENSION_POINT.positionChanged)\n        }\n        return this.positionAnimationsQueue.enqueuePositionChange(positionFrom, this.state.position.clone(), animated)\n    }\n\n    async setOrientation(color, animated = false) {\n        const position = this.state.position.clone()\n        if (this.boardTurning) {\n            console.warn(\"setOrientation is only once in queue allowed\")\n            return\n        }\n        this.boardTurning = true\n        return this.positionAnimationsQueue.enqueueTurnBoard(position, color, animated).then(() => {\n            this.boardTurning = false\n            this.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_3__.EXTENSION_POINT.boardChanged)\n        })\n    }\n\n    getPiece(square) {\n        return this.state.position.getPiece(square)\n    }\n\n    getPosition() {\n        return this.state.position.getFen()\n    }\n\n    getOrientation() {\n        return this.state.orientation\n    }\n\n    enableMoveInput(eventHandler, color = undefined) {\n        this.view.enableMoveInput(eventHandler, color)\n    }\n\n    disableMoveInput() {\n        this.view.disableMoveInput()\n    }\n\n    isMoveInputEnabled() {\n        return this.state.inputWhiteEnabled || this.state.inputBlackEnabled\n    }\n\n    enableSquareSelect(eventType = _view_ChessboardView_js__WEBPACK_IMPORTED_MODULE_4__.POINTER_EVENTS.pointerdown, eventHandler) {\n        if (!this.squareSelectListener) {\n            this.squareSelectListener = function (e) {\n                const square = e.target.getAttribute(\"data-square\")\n                eventHandler({\n                    eventType: e.type,\n                    event: e,\n                    chessboard: this,\n                    square: square\n                })\n            }\n        }\n        this.context.addEventListener(eventType, this.squareSelectListener)\n        this.state.squareSelectEnabled = true\n        this.view.visualizeInputState()\n    }\n\n    disableSquareSelect(eventType) {\n        this.context.removeEventListener(eventType, this.squareSelectListener)\n        this.squareSelectListener = undefined\n        this.state.squareSelectEnabled = false\n        this.view.visualizeInputState()\n    }\n\n    isSquareSelectEnabled() {\n        return this.state.squareSelectEnabled\n    }\n\n    addExtension(extensionClass, props) {\n        if (this.getExtension(extensionClass)) {\n            throw Error(\"extension \\\"\" + extensionClass.name + \"\\\" already added\")\n        }\n        this.extensions.push(new extensionClass(this, props))\n    }\n\n    getExtension(extensionClass) {\n        for (const extension of this.extensions) {\n            if (extension instanceof extensionClass) {\n                return extension\n            }\n        }\n        return null\n    }\n\n    destroy() {\n        this.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_3__.EXTENSION_POINT.destroy)\n        this.positionAnimationsQueue.destroy()\n        this.view.destroy()\n        this.view = undefined\n        this.state = undefined\n    }\n\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/Chessboard.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/extensions/arrows/Arrows.js":
/*!********************************************************************!*\
  !*** ./node_modules/cm-chessboard/src/extensions/arrows/Arrows.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ARROW_TYPE: () => (/* binding */ ARROW_TYPE),\n/* harmony export */   Arrows: () => (/* binding */ Arrows)\n/* harmony export */ });\n/* harmony import */ var _model_Extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../model/Extension.js */ \"./node_modules/cm-chessboard/src/model/Extension.js\");\n/* harmony import */ var _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/Svg.js */ \"./node_modules/cm-chessboard/src/lib/Svg.js\");\n/* harmony import */ var _lib_Utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/Utils.js */ \"./node_modules/cm-chessboard/src/lib/Utils.js\");\n/**\n * Authors and copyright: Barak Michener (@barakmich) and Stefan Haack (@shaack)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\n\n\n\n\nconst ARROW_TYPE = {\n    default: {class: \"arrow-default\", slice: \"arrowDefault\", headSize: 7},\n    danger: {class: \"arrow-danger\", slice: \"arrowDefault\", headSize: 7},\n    pointy: {class: \"arrow-pointy\", slice: \"arrowPointy\", headSize: 7},\n}\n\nclass Arrows extends _model_Extension_js__WEBPACK_IMPORTED_MODULE_0__.Extension {\n\n    /** @constructor */\n    constructor(chessboard, props = {}) {\n        super(chessboard)\n        this.registerExtensionPoint(_model_Extension_js__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_POINT.afterRedrawBoard, () => {\n            this.onRedrawBoard()\n        })\n        this.props = {\n            sprite: \"extensions/arrows/arrows.svg\"\n        }\n        Object.assign(this.props, props)\n        if (this.chessboard.props.assetsCache) {\n            this.chessboard.view.cacheSpriteToDiv(\"cm-chessboard-arrows\", this.getSpriteUrl())\n        }\n        chessboard.addArrow = this.addArrow.bind(this)\n        chessboard.getArrows = this.getArrows.bind(this)\n        chessboard.removeArrows = this.removeArrows.bind(this)\n        this.arrowGroup = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(chessboard.view.markersTopLayer, \"g\", {class: \"arrows\"})\n        this.arrows = []\n    }\n\n    onRedrawBoard() {\n        while (this.arrowGroup.firstChild) {\n            this.arrowGroup.removeChild(this.arrowGroup.firstChild)\n        }\n        this.arrows.forEach((arrow) => {\n            this.drawArrow(arrow)\n        })\n    }\n\n    drawArrow(arrow) {\n        const arrowsGroup = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(this.arrowGroup, \"g\")\n        arrowsGroup.setAttribute(\"data-arrow\", arrow.from + arrow.to)\n        arrowsGroup.setAttribute(\"class\", \"arrow \" + arrow.type.class)\n        const view = this.chessboard.view\n        const sqfrom = document.querySelectorAll('[data-square=\"' + arrow.from + '\"]')[0]\n        const sqto = document.querySelectorAll('[data-square=\"' + arrow.to + '\"]')[0]\n        const spriteUrl = this.chessboard.props.assetsCache ? \"\" : this.getSpriteUrl()\n        const defs = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(arrowsGroup, \"defs\")\n        const id = \"arrow-\" + arrow.from + arrow.to\n        const marker = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(defs, \"marker\", {\n            id: id,\n            markerWidth: arrow.type.headSize,\n            markerHeight: arrow.type.headSize,\n            //markerUnits: \"userSpaceOnUse\",\n            refX: 20,\n            refY: 20,\n            viewBox: \"0 0 40 40\",\n            orient: \"auto\",\n            class: \"arrow-head\",\n        })\n\n        const ignored = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(marker, \"use\", {\n            href: `${spriteUrl}#${arrow.type.slice}`,\n        })\n\n        const x1 = sqfrom.x.baseVal.value + (sqfrom.width.baseVal.value / 2)\n        const x2 = sqto.x.baseVal.value + (sqto.width.baseVal.value / 2)\n        const y1 = sqfrom.y.baseVal.value + (sqfrom.height.baseVal.value / 2)\n        const y2 = sqto.y.baseVal.value + (sqto.height.baseVal.value / 2)\n\n        const width = ((view.scalingX + view.scalingY) / 2) * 4\n        let lineFill = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(arrowsGroup, \"line\")\n        lineFill.setAttribute('x1', x1.toString())\n        lineFill.setAttribute('x2', x2.toString())\n        lineFill.setAttribute('y1', y1.toString())\n        lineFill.setAttribute('y2', y2.toString())\n        lineFill.setAttribute('class', 'arrow-line')\n        lineFill.setAttribute(\"marker-end\", \"url(#\" + id + \")\")\n        lineFill.setAttribute('stroke-width', width + \"px\")\n    }\n\n    addArrow(type, from, to) {\n        this.arrows.push(new Arrow(from, to, type))\n        this.chessboard.view.redrawBoard()\n    }\n\n    getArrows(type = undefined, from = undefined, to = undefined) {\n        let arrows = []\n        this.arrows.forEach((arrow) => {\n            if (arrow.matches(from, to, type)) {\n                arrows.push(arrow)\n            }\n        })\n        return arrows\n    }\n\n    removeArrows(type = undefined, from = undefined, to = undefined) {\n        this.arrows = this.arrows.filter((arrow) => !arrow.matches(from, to, type))\n        this.chessboard.view.redrawBoard()\n    }\n\n    getSpriteUrl() {\n        if(_lib_Utils_js__WEBPACK_IMPORTED_MODULE_2__.Utils.isAbsoluteUrl(this.props.sprite)) {\n            return this.props.sprite\n        } else {\n            return this.chessboard.props.assetsUrl + this.props.sprite\n        }\n    }\n}\n\nclass Arrow {\n    constructor(from, to, type) {\n        this.from = from\n        this.to = to\n        this.type = type\n    }\n\n    matches(from = undefined, to = undefined, type = undefined) {\n        if (from && from !== this.from) {\n            return false\n        }\n        if (to && to !== this.to) {\n            return false\n        }\n        return !(type && type !== this.type)\n    }\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/extensions/arrows/Arrows.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/extensions/markers/Markers.js":
/*!**********************************************************************!*\
  !*** ./node_modules/cm-chessboard/src/extensions/markers/Markers.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MARKER_TYPE: () => (/* binding */ MARKER_TYPE),\n/* harmony export */   Markers: () => (/* binding */ Markers)\n/* harmony export */ });\n/* harmony import */ var _model_Extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../model/Extension.js */ \"./node_modules/cm-chessboard/src/model/Extension.js\");\n/* harmony import */ var _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/Svg.js */ \"./node_modules/cm-chessboard/src/lib/Svg.js\");\n/* harmony import */ var _Chessboard_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Chessboard.js */ \"./node_modules/cm-chessboard/src/Chessboard.js\");\n/* harmony import */ var _lib_Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/Utils.js */ \"./node_modules/cm-chessboard/src/lib/Utils.js\");\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\n\n\n\n\nconst MARKER_TYPE = {\n    frame: {class: \"marker-frame\", slice: \"markerFrame\"},\n    framePrimary: {class: \"marker-frame-primary\", slice: \"markerFrame\"},\n    frameDanger: {class: \"marker-frame-danger\", slice: \"markerFrame\"},\n    circle: {class: \"marker-circle\", slice: \"markerCircle\"},\n    circlePrimary: {class: \"marker-circle-primary\", slice: \"markerCircle\"},\n    circleDanger: {class: \"marker-circle-danger\", slice: \"markerCircle\"},\n    square: {class: \"marker-square\", slice: \"markerSquare\"},\n    dot: {class: \"marker-dot\", slice: \"markerDot\", position: 'above'},\n    bevel: {class: \"marker-bevel\", slice: \"markerBevel\"}\n}\n\nclass Markers extends _model_Extension_js__WEBPACK_IMPORTED_MODULE_0__.Extension {\n\n    /** @constructor */\n    constructor(chessboard, props = {}) {\n        super(chessboard)\n        this.registerExtensionPoint(_model_Extension_js__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_POINT.afterRedrawBoard, () => {\n            this.onRedrawBoard()\n        })\n        this.props = {\n            autoMarkers: MARKER_TYPE.frame, // set to `null` to disable autoMarkers\n            sprite: \"extensions/markers/markers.svg\" // the sprite file of the markers\n        }\n        Object.assign(this.props, props)\n        if (chessboard.props.assetsCache) {\n            chessboard.view.cacheSpriteToDiv(\"cm-chessboard-markers\", this.getSpriteUrl())\n        }\n        chessboard.addMarker = this.addMarker.bind(this)\n        chessboard.getMarkers = this.getMarkers.bind(this)\n        chessboard.removeMarkers = this.removeMarkers.bind(this)\n        chessboard.addLegalMovesMarkers = this.addLegalMovesMarkers.bind(this)\n        chessboard.removeLegalMovesMarkers = this.removeLegalMovesMarkers.bind(this)\n        this.markerGroupDown = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(chessboard.view.markersLayer, \"g\", {class: \"markers\"})\n        this.markerGroupUp = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(chessboard.view.markersTopLayer, \"g\", {class: \"markers\"})\n        this.markers = []\n        if (this.props.autoMarkers) {\n            Object.assign(this.props.autoMarkers, this.props.autoMarkers)\n            this.registerExtensionPoint(_model_Extension_js__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_POINT.moveInput, (event) => {\n                this.drawAutoMarkers(event)\n            })\n        }\n    }\n\n    drawAutoMarkers(event) {\n        if(event.type !== _Chessboard_js__WEBPACK_IMPORTED_MODULE_2__.INPUT_EVENT_TYPE.moveInputFinished) {\n            this.removeMarkers(this.props.autoMarkers)\n        }\n        if (event.type === _Chessboard_js__WEBPACK_IMPORTED_MODULE_2__.INPUT_EVENT_TYPE.moveInputStarted &&\n            !event.moveInputCallbackResult) {\n            return\n        }\n        if (event.type === _Chessboard_js__WEBPACK_IMPORTED_MODULE_2__.INPUT_EVENT_TYPE.moveInputStarted ||\n            event.type === _Chessboard_js__WEBPACK_IMPORTED_MODULE_2__.INPUT_EVENT_TYPE.movingOverSquare) {\n            if (event.squareFrom) {\n                this.addMarker(this.props.autoMarkers, event.squareFrom)\n            }\n            if (event.squareTo) {\n                this.addMarker(this.props.autoMarkers, event.squareTo)\n            }\n        }\n    }\n\n    onRedrawBoard() {\n        while (this.markerGroupUp.firstChild) {\n            this.markerGroupUp.removeChild(this.markerGroupUp.firstChild)\n        }\n        while (this.markerGroupDown.firstChild) {\n            this.markerGroupDown.removeChild(this.markerGroupDown.firstChild)\n        }\n        this.markers.forEach((marker) => {\n                this.drawMarker(marker)\n            }\n        )\n    }\n\n    addLegalMovesMarkers(moves) {\n        for (const move of moves) {\n            if (move.promotion && move.promotion !== \"q\") {\n                continue\n            }\n            if (this.chessboard.getPiece(move.to)) {\n                this.chessboard.addMarker(MARKER_TYPE.bevel, move.to)\n            } else {\n                this.chessboard.addMarker(MARKER_TYPE.dot, move.to)\n            }\n        }\n    }\n\n    removeLegalMovesMarkers() {\n        this.chessboard.removeMarkers(MARKER_TYPE.bevel)\n        this.chessboard.removeMarkers(MARKER_TYPE.dot)\n    }\n\n    drawMarker(marker) {\n        let markerGroup\n        if (marker.type.position === 'above') {\n            markerGroup = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(this.markerGroupUp, \"g\")\n        } else {\n            markerGroup = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(this.markerGroupDown, \"g\")\n        }\n        markerGroup.setAttribute(\"data-square\", marker.square)\n        const point = this.chessboard.view.squareToPoint(marker.square)\n        const transform = (this.chessboard.view.svg.createSVGTransform())\n        transform.setTranslate(point.x, point.y)\n        markerGroup.transform.baseVal.appendItem(transform)\n        const spriteUrl = this.chessboard.props.assetsCache ? \"\" : this.getSpriteUrl()\n        const markerUse = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(markerGroup, \"use\",\n            {href: `${spriteUrl}#${marker.type.slice}`, class: \"marker \" + marker.type.class})\n        const transformScale = (this.chessboard.view.svg.createSVGTransform())\n        transformScale.setScale(this.chessboard.view.scalingX, this.chessboard.view.scalingY)\n        markerUse.transform.baseVal.appendItem(transformScale)\n        return markerGroup\n    }\n\n    addMarker(type, square) {\n        if (typeof type === \"string\" || typeof square === \"object\") { // todo remove 2022-12-01\n            console.error(\"changed the signature of `addMarker` to `(type, square)` with v5.1.x\")\n            return\n        }\n        this.markers.push(new Marker(square, type))\n        this.onRedrawBoard()\n    }\n\n    getMarkers(type = undefined, square = undefined) {\n        if (typeof type === \"string\" || typeof square === \"object\") { // todo remove 2022-12-01\n            console.error(\"changed the signature of `getMarkers` to `(type, square)` with v5.1.x\")\n            return\n        }\n        let markersFound = []\n        this.markers.forEach((marker) => {\n            if (marker.matches(square, type)) {\n                markersFound.push(marker)\n            }\n        })\n        return markersFound\n    }\n\n    removeMarkers(type = undefined, square = undefined) {\n        if (typeof type === \"string\" || typeof square === \"object\") { // todo remove 2022-12-01\n            console.error(\"changed the signature of `removeMarkers` to `(type, square)` with v5.1.x\")\n            return\n        }\n        this.markers = this.markers.filter((marker) => !marker.matches(square, type))\n        this.onRedrawBoard()\n    }\n\n    getSpriteUrl() {\n        if(_lib_Utils_js__WEBPACK_IMPORTED_MODULE_3__.Utils.isAbsoluteUrl(this.props.sprite)) {\n            return this.props.sprite\n        } else {\n            return this.chessboard.props.assetsUrl + this.props.sprite\n        }\n    }\n}\n\nclass Marker {\n    constructor(square, type) {\n        this.square = square\n        this.type = type\n    }\n\n    matches(square = undefined, type = undefined) {\n        if (!type && !square) {\n            return true\n        } else if (!type) {\n            if (square === this.square) {\n                return true\n            }\n        } else if (!square) {\n            if (this.type === type) {\n                return true\n            }\n        } else if (this.type === type && square === this.square) {\n            return true\n        }\n        return false\n    }\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/extensions/markers/Markers.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/extensions/promotion-dialog/PromotionDialog.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/cm-chessboard/src/extensions/promotion-dialog/PromotionDialog.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PROMOTION_DIALOG_RESULT_TYPE: () => (/* binding */ PROMOTION_DIALOG_RESULT_TYPE),\n/* harmony export */   PromotionDialog: () => (/* binding */ PromotionDialog)\n/* harmony export */ });\n/* harmony import */ var _model_Extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../model/Extension.js */ \"./node_modules/cm-chessboard/src/model/Extension.js\");\n/* harmony import */ var _Chessboard_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Chessboard.js */ \"./node_modules/cm-chessboard/src/Chessboard.js\");\n/* harmony import */ var _lib_Svg_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/Svg.js */ \"./node_modules/cm-chessboard/src/lib/Svg.js\");\n/* harmony import */ var _lib_Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/Utils.js */ \"./node_modules/cm-chessboard/src/lib/Utils.js\");\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\n\n\n\n\nconst DISPLAY_STATE = {\n    hidden: \"hidden\",\n    displayRequested: \"displayRequested\",\n    shown: \"shown\"\n}\n\nconst PROMOTION_DIALOG_RESULT_TYPE = {\n    pieceSelected: \"pieceSelected\",\n    canceled: \"canceled\"\n}\n\nclass PromotionDialog extends _model_Extension_js__WEBPACK_IMPORTED_MODULE_0__.Extension {\n\n    /** @constructor */\n    constructor(chessboard) {\n        super(chessboard)\n        this.registerExtensionPoint(_model_Extension_js__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_POINT.afterRedrawBoard, this.extensionPointRedrawBoard.bind(this))\n        chessboard.showPromotionDialog = this.showPromotionDialog.bind(this)\n        chessboard.isPromotionDialogShown = this.isPromotionDialogShown.bind(this)\n        this.promotionDialogGroup = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_2__.Svg.addElement(chessboard.view.interactiveTopLayer, \"g\", {class: \"promotion-dialog-group\"})\n        this.state = {\n            displayState: DISPLAY_STATE.hidden,\n            callback: null,\n            dialogParams: {\n                square: null,\n                color: null\n            }\n        }\n    }\n\n    // public (chessboard.showPromotionDialog)\n    showPromotionDialog(square, color, callback) {\n        this.state.dialogParams.square = square\n        this.state.dialogParams.color = color\n        this.state.callback = callback\n        this.setDisplayState(DISPLAY_STATE.displayRequested)\n        setTimeout(() => {\n                this.chessboard.view.positionsAnimationTask.then(() => {\n                    this.setDisplayState(DISPLAY_STATE.shown)\n                })\n            }\n        )\n    }\n\n    // public (chessboard.isPromotionDialogShown)\n    isPromotionDialogShown() {\n        return this.state.displayState === DISPLAY_STATE.shown ||\n            this.state.displayState === DISPLAY_STATE.displayRequested\n    }\n\n    // private\n    extensionPointRedrawBoard() {\n        this.redrawDialog()\n    }\n\n    drawPieceButton(piece, point) {\n        const squareWidth = this.chessboard.view.squareWidth\n        const squareHeight = this.chessboard.view.squareHeight\n        _lib_Svg_js__WEBPACK_IMPORTED_MODULE_2__.Svg.addElement(this.promotionDialogGroup,\n            \"rect\", {\n                x: point.x, y: point.y, width: squareWidth, height: squareHeight,\n                class: \"promotion-dialog-button\",\n                \"data-piece\": piece\n            })\n        this.chessboard.view.drawPiece(this.promotionDialogGroup, piece, point)\n    }\n\n    redrawDialog() {\n        while (this.promotionDialogGroup.firstChild) {\n            this.promotionDialogGroup.removeChild(this.promotionDialogGroup.firstChild)\n        }\n        if (this.state.displayState === DISPLAY_STATE.shown) {\n            const squareWidth = this.chessboard.view.squareWidth\n            const squareHeight = this.chessboard.view.squareHeight\n            const squareCenterPoint = this.chessboard.view.squareToPoint(this.state.dialogParams.square)\n            squareCenterPoint.x = squareCenterPoint.x + squareWidth / 2\n            squareCenterPoint.y = squareCenterPoint.y + squareHeight / 2\n            let turned = false\n            const rank = parseInt(this.state.dialogParams.square.charAt(1), 10)\n            if (this.chessboard.getOrientation() === _Chessboard_js__WEBPACK_IMPORTED_MODULE_1__.COLOR.white && rank < 5 ||\n                this.chessboard.getOrientation() === _Chessboard_js__WEBPACK_IMPORTED_MODULE_1__.COLOR.black && rank >= 5) {\n                turned = true\n            }\n            const offsetY = turned ? -4 * squareHeight : 0\n            const offsetX = squareCenterPoint.x + squareWidth > this.chessboard.view.width ? -squareWidth : 0\n            _lib_Svg_js__WEBPACK_IMPORTED_MODULE_2__.Svg.addElement(this.promotionDialogGroup,\n                \"rect\", {\n                    x: squareCenterPoint.x + offsetX,\n                    y: squareCenterPoint.y + offsetY,\n                    width: squareWidth,\n                    height: squareHeight * 4,\n                    class: \"promotion-dialog\"\n                })\n            const dialogParams = this.state.dialogParams\n            if (turned) {\n                this.drawPieceButton(_Chessboard_js__WEBPACK_IMPORTED_MODULE_1__.PIECE[dialogParams.color + \"q\"], {\n                    x: squareCenterPoint.x + offsetX,\n                    y: squareCenterPoint.y - squareHeight\n                })\n                this.drawPieceButton(_Chessboard_js__WEBPACK_IMPORTED_MODULE_1__.PIECE[dialogParams.color + \"r\"], {\n                    x: squareCenterPoint.x + offsetX,\n                    y: squareCenterPoint.y - squareHeight * 2\n                })\n                this.drawPieceButton(_Chessboard_js__WEBPACK_IMPORTED_MODULE_1__.PIECE[dialogParams.color + \"b\"], {\n                    x: squareCenterPoint.x + offsetX,\n                    y: squareCenterPoint.y - squareHeight * 3\n                })\n                this.drawPieceButton(_Chessboard_js__WEBPACK_IMPORTED_MODULE_1__.PIECE[dialogParams.color + \"n\"], {\n                    x: squareCenterPoint.x + offsetX,\n                    y: squareCenterPoint.y - squareHeight * 4\n                })\n            } else {\n                this.drawPieceButton(_Chessboard_js__WEBPACK_IMPORTED_MODULE_1__.PIECE[dialogParams.color + \"q\"], {\n                    x: squareCenterPoint.x + offsetX,\n                    y: squareCenterPoint.y\n                })\n                this.drawPieceButton(_Chessboard_js__WEBPACK_IMPORTED_MODULE_1__.PIECE[dialogParams.color + \"r\"], {\n                    x: squareCenterPoint.x + offsetX,\n                    y: squareCenterPoint.y + squareHeight\n                })\n                this.drawPieceButton(_Chessboard_js__WEBPACK_IMPORTED_MODULE_1__.PIECE[dialogParams.color + \"b\"], {\n                    x: squareCenterPoint.x + offsetX,\n                    y: squareCenterPoint.y + squareHeight * 2\n                })\n                this.drawPieceButton(_Chessboard_js__WEBPACK_IMPORTED_MODULE_1__.PIECE[dialogParams.color + \"n\"], {\n                    x: squareCenterPoint.x + offsetX,\n                    y: squareCenterPoint.y + squareHeight * 3\n                })\n            }\n        }\n    }\n\n    promotionDialogOnClickPiece(event) {\n        if (event.button !== 2) {\n            if (event.target.dataset.piece) {\n                if(this.state.callback) {\n                    this.state.callback({\n                        type: PROMOTION_DIALOG_RESULT_TYPE.pieceSelected,\n                        square: this.state.dialogParams.square,\n                        piece: event.target.dataset.piece\n                    })\n                }\n                this.setDisplayState(DISPLAY_STATE.hidden)\n            } else {\n                this.promotionDialogOnCancel(event)\n            }\n        }\n    }\n\n    promotionDialogOnCancel(event) {\n        if (this.state.displayState === DISPLAY_STATE.shown) {\n            event.preventDefault()\n            this.setDisplayState(DISPLAY_STATE.hidden)\n            if(this.state.callback) {\n                this.state.callback({type: PROMOTION_DIALOG_RESULT_TYPE.canceled})\n            }\n        }\n    }\n\n    contextMenu(event) {\n        event.preventDefault()\n        this.setDisplayState(DISPLAY_STATE.hidden)\n        if(this.state.callback) {\n            this.state.callback({type: PROMOTION_DIALOG_RESULT_TYPE.canceled})\n        }\n    }\n\n    setDisplayState(displayState) {\n        this.state.displayState = displayState\n        if (displayState === DISPLAY_STATE.shown) {\n            this.clickDelegate = _lib_Utils_js__WEBPACK_IMPORTED_MODULE_3__.Utils.delegate(this.chessboard.view.svg,\n                \"pointerdown\",\n                \"*\",\n                this.promotionDialogOnClickPiece.bind(this))\n            this.contextMenuListener = this.contextMenu.bind(this)\n            this.chessboard.view.svg.addEventListener(\"contextmenu\", this.contextMenuListener)\n        } else if (displayState === DISPLAY_STATE.hidden) {\n            this.clickDelegate.remove()\n            this.chessboard.view.svg.removeEventListener(\"contextmenu\", this.contextMenuListener)\n        }\n        this.redrawDialog()\n    }\n\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/extensions/promotion-dialog/PromotionDialog.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/lib/Svg.js":
/*!***************************************************!*\
  !*** ./node_modules/cm-chessboard/src/lib/Svg.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Svg: () => (/* binding */ Svg)\n/* harmony export */ });\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\"\n\nclass Svg {\n\n    /**\n     * create the Svg in the HTML DOM\n     * @param containerElement\n     * @returns {Element}\n     */\n    static createSvg(containerElement = undefined) {\n        let svg = document.createElementNS(SVG_NAMESPACE, \"svg\")\n        if (containerElement) {\n            svg.setAttribute(\"width\", \"100%\")\n            svg.setAttribute(\"height\", \"100%\")\n            containerElement.appendChild(svg)\n        }\n        return svg\n    }\n\n    /**\n     * Add an Element to an SVG DOM\n     * @param parent\n     * @param name\n     * @param attributes\n     * @returns {Element}\n     */\n    static addElement(parent, name, attributes = {}) {\n        let element = document.createElementNS(SVG_NAMESPACE, name)\n        if (name === \"use\") {\n            attributes[\"xlink:href\"] = attributes[\"href\"] // fix for safari\n        }\n        for (let attribute in attributes) {\n            if (attributes.hasOwnProperty(attribute)) {\n                if (attribute.indexOf(\":\") !== -1) {\n                    const value = attribute.split(\":\")\n                    element.setAttributeNS(\"http://www.w3.org/1999/\" + value[0], value[1], attributes[attribute])\n                } else {\n                    element.setAttribute(attribute, attributes[attribute])\n                }\n            }\n        }\n        parent.appendChild(element)\n        return element\n    }\n\n    /**\n     * Remove an element from an SVG DOM\n     * @param element\n     */\n    static removeElement(element) {\n        if(!element) {\n            console.warn(\"removeElement, element is\", element)\n            return\n        }\n        if (element.parentNode) {\n            element.parentNode.removeChild(element)\n        } else {\n            console.warn(element, \"without parentNode\")\n        }\n    }\n\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/lib/Svg.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/lib/Utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/cm-chessboard/src/lib/Utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Utils: () => (/* binding */ Utils)\n/* harmony export */ });\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\nclass Utils {\n\n    static delegate(element, eventName, selector, handler) {\n        const eventListener = function (event) {\n            let target = event.target\n            while (target && target !== this) {\n                if (target.matches(selector)) {\n                    handler.call(target, event)\n                }\n                target = target.parentNode\n            }\n        }\n        element.addEventListener(eventName, eventListener)\n        return {\n            remove: function () {\n                element.removeEventListener(eventName, eventListener)\n            }\n        }\n    }\n\n    static mergeObjects(target, source) {\n        const isObject = (obj) => obj && typeof obj === 'object'\n        if (!isObject(target) || !isObject(source)) {\n            return source\n        }\n        for (const key of Object.keys(source)) {\n            if (source[key] instanceof Object) {\n                Object.assign(source[key], Utils.mergeObjects(target[key], source[key]))\n            }\n        }\n        Object.assign(target || {}, source)\n        return target\n    }\n\n    static createDomElement(html) {\n        const template = document.createElement('template')\n        template.innerHTML = html.trim()\n        return template.content.firstChild\n    }\n\n    static createTask() {\n        let resolve, reject\n        const promise = new Promise(function (_resolve, _reject) {\n            resolve = _resolve\n            reject = _reject\n        })\n        promise.resolve = resolve\n        promise.reject = reject\n        return promise\n    }\n\n    static isAbsoluteUrl(url) {\n        return url.indexOf(\"://\") !== -1 || url.startsWith(\"/\")\n    }\n\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/lib/Utils.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/model/ChessboardState.js":
/*!*****************************************************************!*\
  !*** ./node_modules/cm-chessboard/src/model/ChessboardState.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChessboardState: () => (/* binding */ ChessboardState)\n/* harmony export */ });\n/* harmony import */ var _Position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Position.js */ \"./node_modules/cm-chessboard/src/model/Position.js\");\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\n\nclass ChessboardState {\n\n    constructor() {\n        this.position = new _Position_js__WEBPACK_IMPORTED_MODULE_0__.Position()\n        this.orientation = undefined\n        this.inputWhiteEnabled = false\n        this.inputBlackEnabled = false\n        this.squareSelectEnabled = false\n        this.moveInputCallback = null\n        this.extensionPoints = {}\n        this.moveInputProcess = Promise.resolve()\n    }\n\n    inputEnabled() {\n        return this.inputWhiteEnabled || this.inputBlackEnabled\n    }\n\n    invokeExtensionPoints(name, data = {}) {\n        const extensionPoints = this.extensionPoints[name]\n        const dataCloned = Object.assign({}, data)\n        dataCloned.extensionPoint = name\n        let returnValue = true\n        if (extensionPoints) {\n            for (const extensionPoint of extensionPoints) {\n                if(extensionPoint(dataCloned) === false) {\n                    returnValue = false\n                }\n            }\n        }\n        return returnValue\n    }\n\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/model/ChessboardState.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/model/Extension.js":
/*!***********************************************************!*\
  !*** ./node_modules/cm-chessboard/src/model/Extension.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXTENSION_POINT: () => (/* binding */ EXTENSION_POINT),\n/* harmony export */   Extension: () => (/* binding */ Extension)\n/* harmony export */ });\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\nconst EXTENSION_POINT = {\n    positionChanged: \"positionChanged\", // the positions of the pieces was changed\n    boardChanged: \"boardChanged\", // the board (orientation) was changed\n    moveInputToggled: \"moveInputToggled\", // move input was enabled or disabled\n    moveInput: \"moveInput\", // move started, moving over a square, validating or canceled\n    beforeRedrawBoard: \"beforeRedrawBoard\", // called before redrawing the board\n    afterRedrawBoard: \"afterRedrawBoard\", // called after redrawing the board\n    redrawBoard: \"redrawBoard\", // called after redrawing the board, DEPRECATED, use afterRedrawBoard 2023-09-18\n    animation: \"animation\", // called on animation start, end, and on every animation frame\n    destroy: \"destroy\" // called, before the board is destroyed\n}\n\nclass Extension {\n\n    constructor(chessboard) {\n        this.chessboard = chessboard\n    }\n\n    registerExtensionPoint(name, callback) {\n        if(name === EXTENSION_POINT.redrawBoard) { // deprecated 2023-09-18\n            console.warn(\"EXTENSION_POINT.redrawBoard is deprecated, use EXTENSION_POINT.afterRedrawBoard\")\n            name = EXTENSION_POINT.afterRedrawBoard\n        }\n        if (!this.chessboard.state.extensionPoints[name]) {\n            this.chessboard.state.extensionPoints[name] = []\n        }\n        this.chessboard.state.extensionPoints[name].push(callback)\n    }\n\n    /** @deprecated 2023-05-18 */\n    registerMethod(name, callback) {\n        console.warn(\"registerMethod is deprecated, just add methods directly to the chessboard instance\")\n        if (!this.chessboard[name]) {\n            this.chessboard[name] = (...args) => {\n                return callback.apply(this, args)\n            }\n        } else {\n            log.error(\"method\", name, \"already exists\")\n        }\n    }\n\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/model/Extension.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/model/Position.js":
/*!**********************************************************!*\
  !*** ./node_modules/cm-chessboard/src/model/Position.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FEN: () => (/* binding */ FEN),\n/* harmony export */   Position: () => (/* binding */ Position)\n/* harmony export */ });\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\nconst FEN = {\n    start: \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\",\n    empty: \"8/8/8/8/8/8/8/8\"\n}\n\nclass Position {\n\n    constructor(fen = FEN.empty) {\n        this.squares = new Array(64).fill(null)\n        this.setFen(fen)\n    }\n\n    setFen(fen = FEN.empty) {\n        const parts = fen.replace(/^\\s*/, \"\").replace(/\\s*$/, \"\").split(/\\/|\\s/)\n        for (let part = 0; part < 8; part++) {\n            const row = parts[7 - part].replace(/\\d/g, (str) => {\n                const numSpaces = parseInt(str)\n                let ret = ''\n                for (let i = 0; i < numSpaces; i++) {\n                    ret += '-'\n                }\n                return ret\n            })\n            for (let c = 0; c < 8; c++) {\n                const char = row.substring(c, c + 1)\n                let piece = null\n                if (char !== '-') {\n                    if (char.toUpperCase() === char) {\n                        piece = `w${char.toLowerCase()}`\n                    } else {\n                        piece = `b${char}`\n                    }\n                }\n                this.squares[part * 8 + c] = piece\n            }\n        }\n    }\n\n    getFen() {\n        let parts = new Array(8).fill(\"\")\n        for (let part = 0; part < 8; part++) {\n            let spaceCounter = 0\n            for (let i = 0; i < 8; i++) {\n                const piece = this.squares[part * 8 + i]\n                if (!piece) {\n                    spaceCounter++\n                } else {\n                    if (spaceCounter > 0) {\n                        parts[7 - part] += spaceCounter\n                        spaceCounter = 0\n                    }\n                    const color = piece.substring(0, 1)\n                    const name = piece.substring(1, 2)\n                    if (color === \"w\") {\n                        parts[7 - part] += name.toUpperCase()\n                    } else {\n                        parts[7 - part] += name\n                    }\n                }\n            }\n            if (spaceCounter > 0) {\n                parts[7 - part] += spaceCounter\n                spaceCounter = 0\n            }\n        }\n        return parts.join(\"/\")\n    }\n\n    getPieces(pieceColor = undefined, pieceType = undefined, sortBy = ['k', 'q', 'r', 'b', 'n', 'p']) {\n        const pieces = []\n        const sort = (a, b) => {\n            return sortBy.indexOf(a.name) - sortBy.indexOf(b.name)\n        }\n        for (let i = 0; i < 64; i++) {\n            const piece = this.squares[i]\n            if (piece) {\n                const type = piece.charAt(1)\n                const color = piece.charAt(0)\n                const square = Position.indexToSquare(i)\n                if(pieceType && pieceType !== type || pieceColor && pieceColor !== color) {\n                    continue\n                }\n                pieces.push({\n                    name: type, // deprecated, use type\n                    type: type,\n                    color: color,\n                    position: square, // deprecated, use square\n                    square: square\n                })\n            }\n        }\n        if (sortBy) {\n            pieces.sort(sort)\n        }\n        return pieces\n    }\n\n    movePiece(squareFrom, squareTo) {\n        if (!this.squares[Position.squareToIndex(squareFrom)]) {\n            console.warn(\"no piece on\", squareFrom)\n            return\n        }\n        this.squares[Position.squareToIndex(squareTo)] = this.squares[Position.squareToIndex(squareFrom)]\n        this.squares[Position.squareToIndex(squareFrom)] = null\n    }\n\n    setPiece(square, piece) {\n        this.squares[Position.squareToIndex(square)] = piece\n    }\n\n    getPiece(square) {\n        return this.squares[Position.squareToIndex(square)]\n    }\n\n    static squareToIndex(square) {\n        const coordinates = Position.squareToCoordinates(square)\n        return coordinates[0] + coordinates[1] * 8\n    }\n\n    static indexToSquare(index) {\n        return this.coordinatesToSquare([Math.floor(index % 8), index / 8])\n    }\n\n    static squareToCoordinates(square) {\n        const file = square.charCodeAt(0) - 97\n        const rank = square.charCodeAt(1) - 49\n        return [file, rank]\n    }\n\n    static coordinatesToSquare(coordinates) {\n        const file = String.fromCharCode(coordinates[0] + 97)\n        const rank = String.fromCharCode(coordinates[1] + 49)\n        return file + rank\n    }\n\n    toString() {\n        return this.getFen()\n    }\n\n    clone() {\n        const cloned = new Position()\n        cloned.squares = this.squares.slice(0)\n        return cloned\n    }\n\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/model/Position.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/view/ChessboardView.js":
/*!***************************************************************!*\
  !*** ./node_modules/cm-chessboard/src/view/ChessboardView.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BORDER_TYPE: () => (/* binding */ BORDER_TYPE),\n/* harmony export */   COLOR: () => (/* binding */ COLOR),\n/* harmony export */   ChessboardView: () => (/* binding */ ChessboardView),\n/* harmony export */   INPUT_EVENT_TYPE: () => (/* binding */ INPUT_EVENT_TYPE),\n/* harmony export */   POINTER_EVENTS: () => (/* binding */ POINTER_EVENTS)\n/* harmony export */ });\n/* harmony import */ var _VisualMoveInput_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VisualMoveInput.js */ \"./node_modules/cm-chessboard/src/view/VisualMoveInput.js\");\n/* harmony import */ var _model_Position_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/Position.js */ \"./node_modules/cm-chessboard/src/model/Position.js\");\n/* harmony import */ var _model_Extension_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/Extension.js */ \"./node_modules/cm-chessboard/src/model/Extension.js\");\n/* harmony import */ var _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/Svg.js */ \"./node_modules/cm-chessboard/src/lib/Svg.js\");\n/* harmony import */ var _lib_Utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/Utils.js */ \"./node_modules/cm-chessboard/src/lib/Utils.js\");\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\n\n\n\n\n\n\nconst COLOR = {\n    white: \"w\",\n    black: \"b\"\n}\nconst INPUT_EVENT_TYPE = {\n    moveInputStarted: \"moveInputStarted\",\n    movingOverSquare: \"movingOverSquare\", // while dragging or hover after click\n    validateMoveInput: \"validateMoveInput\",\n    moveInputCanceled: \"moveInputCanceled\",\n    moveInputFinished: \"moveInputFinished\"\n}\nconst POINTER_EVENTS = {\n    pointercancel: \"pointercancel\",\n    pointerdown: \"pointerdown\",\n    pointerenter: \"pointerenter\",\n    pointerleave: \"pointerleave\",\n    pointermove: \"pointermove\",\n    pointerout: \"pointerout\",\n    pointerover: \"pointerover\",\n    pointerup: \"pointerup\"\n}\nconst BORDER_TYPE = {\n    none: \"none\", // no border\n    thin: \"thin\", // thin border\n    frame: \"frame\" // wide border with coordinates in it\n}\n\nclass ChessboardView {\n    constructor(chessboard) {\n        this.chessboard = chessboard\n        this.visualMoveInput = new _VisualMoveInput_js__WEBPACK_IMPORTED_MODULE_0__.VisualMoveInput(this)\n        if (chessboard.props.assetsCache) {\n            this.cacheSpriteToDiv(\"cm-chessboard-sprite\", this.getSpriteUrl())\n        }\n        this.container = document.createElement(\"div\")\n        this.chessboard.context.appendChild(this.container)\n        if (chessboard.props.responsive) {\n            if (typeof ResizeObserver !== \"undefined\") {\n                this.resizeObserver = new ResizeObserver(() => {\n                    setTimeout(() => { // prevents \"ResizeObserver loop completed with undelivered notifications.\"\n                        this.handleResize()\n                    })\n                })\n                this.resizeObserver.observe(this.chessboard.context)\n            } else {\n                this.resizeListener = this.handleResize.bind(this)\n                window.addEventListener(\"resize\", this.resizeListener)\n            }\n        }\n        this.positionsAnimationTask = Promise.resolve()\n        this.pointerDownListener = this.pointerDownHandler.bind(this)\n        this.container.addEventListener(\"mousedown\", this.pointerDownListener)\n        this.container.addEventListener(\"touchstart\", this.pointerDownListener, {passive: false})\n        this.createSvgAndGroups()\n        this.handleResize()\n    }\n\n    pointerDownHandler(e) {\n        this.visualMoveInput.onPointerDown(e)\n    }\n\n    destroy() {\n        this.visualMoveInput.destroy()\n        if (this.resizeObserver) {\n            this.resizeObserver.unobserve(this.chessboard.context)\n        }\n        if (this.resizeListener) {\n            window.removeEventListener(\"resize\", this.resizeListener)\n        }\n        this.chessboard.context.removeEventListener(\"mousedown\", this.pointerDownListener)\n        this.chessboard.context.removeEventListener(\"touchstart\", this.pointerDownListener)\n        _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.removeElement(this.svg)\n        this.container.remove()\n    }\n\n    // Sprite //\n\n    cacheSpriteToDiv(wrapperId, url) {\n        if (!document.getElementById(wrapperId)) {\n            const wrapper = document.createElement(\"div\")\n            wrapper.style.transform = \"scale(0)\"\n            wrapper.style.position = \"absolute\"\n            wrapper.setAttribute(\"aria-hidden\", \"true\")\n            wrapper.id = wrapperId\n            document.body.appendChild(wrapper)\n            const xhr = new XMLHttpRequest()\n            xhr.open(\"GET\", url, true)\n            xhr.onload = function () {\n                wrapper.insertAdjacentHTML('afterbegin', xhr.response)\n            }\n            xhr.send()\n        }\n    }\n\n    createSvgAndGroups() {\n        this.svg = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.createSvg(this.container)\n        // let description = document.createElement(\"description\")\n        // description.innerText = \"Chessboard\"\n        // description.id = \"svg-description\"\n        // this.svg.appendChild(description)\n        let cssClass = this.chessboard.props.style.cssClass ? this.chessboard.props.style.cssClass : \"default\"\n        this.svg.setAttribute(\"class\", \"cm-chessboard border-type-\" + this.chessboard.props.style.borderType + \" \" + cssClass)\n        // this.svg.setAttribute(\"aria-describedby\", \"svg-description\")\n        this.svg.setAttribute(\"role\", \"img\")\n        this.updateMetrics()\n        this.boardGroup = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.svg, \"g\", {class: \"board\"})\n        this.coordinatesGroup = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.svg, \"g\", {class: \"coordinates\", \"aria-hidden\": \"true\"})\n        this.markersLayer = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.svg, \"g\", {class: \"markers-layer\"})\n        this.piecesLayer = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.svg, \"g\", {class: \"pieces-layer\"})\n        this.piecesGroup = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.piecesLayer, \"g\", {class: \"pieces\"})\n        this.markersTopLayer = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.svg, \"g\", {class: \"markers-top-layer\"})\n        this.interactiveTopLayer = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.svg, \"g\", {class: \"interactive-top-layer\"})\n    }\n\n    updateMetrics() {\n        const piecesTileSize = this.chessboard.props.style.pieces.tileSize\n        this.width = this.container.clientWidth\n        this.height = this.container.clientWidth * (this.chessboard.props.style.aspectRatio || 1)\n        if (this.chessboard.props.style.borderType === BORDER_TYPE.frame) {\n            this.borderSize = this.width / 25\n        } else if (this.chessboard.props.style.borderType === BORDER_TYPE.thin) {\n            this.borderSize = this.width / 320\n        } else {\n            this.borderSize = 0\n        }\n        this.innerWidth = this.width - 2 * this.borderSize\n        this.innerHeight = this.height - 2 * this.borderSize\n        this.squareWidth = this.innerWidth / 8\n        this.squareHeight = this.innerHeight / 8\n        this.scalingX = this.squareWidth / piecesTileSize\n        this.scalingY = this.squareHeight / piecesTileSize\n        this.pieceXTranslate = (this.squareWidth / 2 - piecesTileSize * this.scalingY / 2)\n    }\n\n    handleResize() {\n        this.container.style.width = (this.chessboard.context.clientWidth) + \"px\"\n        this.container.style.height = (this.chessboard.context.clientWidth * this.chessboard.props.style.aspectRatio) + \"px\"\n        if (this.container.clientWidth !== this.width || this.container.clientHeight !== this.height) {\n            this.updateMetrics()\n            this.redrawBoard()\n            this.redrawPieces()\n        }\n        this.svg.setAttribute(\"width\", \"100%\")\n        this.svg.setAttribute(\"height\", \"100%\")\n    }\n\n    redrawBoard() {\n        this.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.beforeRedrawBoard)\n        this.redrawSquares()\n        this.drawCoordinates()\n        this.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.afterRedrawBoard)\n        this.visualizeInputState()\n    }\n\n    // Board //\n\n    redrawSquares() {\n        while (this.boardGroup.firstChild) {\n            this.boardGroup.removeChild(this.boardGroup.lastChild)\n        }\n\n        let boardBorder = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.boardGroup, \"rect\", {width: this.width, height: this.height})\n        boardBorder.setAttribute(\"class\", \"border\")\n        if (this.chessboard.props.style.borderType === BORDER_TYPE.frame) {\n            const innerPos = this.borderSize\n            let borderInner = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.boardGroup, \"rect\", {\n                x: innerPos, y: innerPos, width: this.width - innerPos * 2, height: this.height - innerPos * 2\n            })\n            borderInner.setAttribute(\"class\", \"border-inner\")\n        }\n\n        for (let i = 0; i < 64; i++) {\n            const index = this.chessboard.state.orientation === COLOR.white ? i : 63 - i\n            const squareColor = ((9 * index) & 8) === 0 ? 'black' : 'white'\n            const fieldClass = `square ${squareColor}`\n            const point = this.squareToPoint(_model_Position_js__WEBPACK_IMPORTED_MODULE_1__.Position.indexToSquare(index))\n            const squareRect = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.boardGroup, \"rect\", {\n                x: point.x, y: point.y, width: this.squareWidth, height: this.squareHeight\n            })\n            squareRect.setAttribute(\"class\", fieldClass)\n            squareRect.setAttribute(\"data-square\", _model_Position_js__WEBPACK_IMPORTED_MODULE_1__.Position.indexToSquare(index))\n        }\n    }\n\n    drawCoordinates() {\n        if (!this.chessboard.props.style.showCoordinates) {\n            return\n        }\n        while (this.coordinatesGroup.firstChild) {\n            this.coordinatesGroup.removeChild(this.coordinatesGroup.lastChild)\n        }\n        const inline = this.chessboard.props.style.borderType !== BORDER_TYPE.frame\n        for (let file = 0; file < 8; file++) {\n            let x = this.borderSize + (17 + this.chessboard.props.style.pieces.tileSize * file) * this.scalingX\n            let y = this.height - this.scalingY * 3.5\n            let cssClass = \"coordinate file\"\n            if (inline) {\n                x = x + this.scalingX * 15.5\n                cssClass += file % 2 ? \" white\" : \" black\"\n            }\n            const textElement = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.coordinatesGroup, \"text\", {\n                class: cssClass, x: x, y: y, style: `font-size: ${this.scalingY * 10}px`\n            })\n            if (this.chessboard.state.orientation === COLOR.white) {\n                textElement.textContent = String.fromCharCode(97 + file)\n            } else {\n                textElement.textContent = String.fromCharCode(104 - file)\n            }\n        }\n        for (let rank = 0; rank < 8; rank++) {\n            let x = (this.borderSize / 3.7)\n            let y = this.borderSize + 25 * this.scalingY + rank * this.squareHeight\n            let cssClass = \"coordinate rank\"\n            if (inline) {\n                cssClass += rank % 2 ? \" black\" : \" white\"\n                if (this.chessboard.props.style.borderType === BORDER_TYPE.frame) {\n                    x = x + this.scalingX * 10\n                    y = y - this.scalingY * 15\n                } else {\n                    x = x + this.scalingX * 2\n                    y = y - this.scalingY * 15\n                }\n            }\n            const textElement = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.coordinatesGroup, \"text\", {\n                class: cssClass, x: x, y: y, style: `font-size: ${this.scalingY * 10}px`\n            })\n            if (this.chessboard.state.orientation === COLOR.white) {\n                textElement.textContent = \"\" + (8 - rank)\n            } else {\n                textElement.textContent = \"\" + (1 + rank)\n            }\n        }\n    }\n\n    // Pieces //\n\n    redrawPieces(squares = this.chessboard.state.position.squares) {\n        const childNodes = Array.from(this.piecesGroup.childNodes)\n        const isDragging = this.visualMoveInput.isDragging()\n        for (let i = 0; i < 64; i++) {\n            const pieceName = squares[i]\n            if (pieceName) {\n                const square = _model_Position_js__WEBPACK_IMPORTED_MODULE_1__.Position.indexToSquare(i)\n                this.drawPieceOnSquare(square, pieceName, isDragging && square === this.visualMoveInput.fromSquare)\n            }\n        }\n        for (const childNode of childNodes) {\n            this.piecesGroup.removeChild(childNode)\n        }\n    }\n\n    drawPiece(parentGroup, pieceName, point) {\n        const pieceGroup = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(parentGroup, \"g\", {})\n        pieceGroup.setAttribute(\"data-piece\", pieceName)\n        const transform = (this.svg.createSVGTransform())\n        transform.setTranslate(point.x, point.y)\n        pieceGroup.transform.baseVal.appendItem(transform)\n        const spriteUrl = this.chessboard.props.assetsCache ? \"\" : this.getSpriteUrl()\n        const pieceUse = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(pieceGroup, \"use\", {\n            href: `${spriteUrl}#${pieceName}`, class: \"piece\"\n        })\n        const transformScale = (this.svg.createSVGTransform())\n        transformScale.setScale(this.scalingY, this.scalingY)\n        pieceUse.transform.baseVal.appendItem(transformScale)\n        return pieceGroup\n    }\n\n    drawPieceOnSquare(square, pieceName, hidden = false) {\n        const pieceGroup = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.piecesGroup, \"g\", {})\n        pieceGroup.setAttribute(\"data-piece\", pieceName)\n        pieceGroup.setAttribute(\"data-square\", square)\n        if (hidden) {\n            pieceGroup.setAttribute(\"visibility\", \"hidden\")\n        }\n        const point = this.squareToPoint(square)\n        const transform = (this.svg.createSVGTransform())\n        transform.setTranslate(point.x, point.y)\n        pieceGroup.transform.baseVal.appendItem(transform)\n        const spriteUrl = this.chessboard.props.assetsCache ? \"\" : this.getSpriteUrl()\n        const pieceUse = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(pieceGroup, \"use\", {\n            href: `${spriteUrl}#${pieceName}`, class: \"piece\"\n        })\n        // center on square\n        const transformTranslate = (this.svg.createSVGTransform())\n        transformTranslate.setTranslate(this.pieceXTranslate, 0)\n        pieceUse.transform.baseVal.appendItem(transformTranslate)\n        // scale\n        const transformScale = (this.svg.createSVGTransform())\n        transformScale.setScale(this.scalingY, this.scalingY)\n        pieceUse.transform.baseVal.appendItem(transformScale)\n        return pieceGroup\n    }\n\n    setPieceVisibility(square, visible = true) {\n        const piece = this.getPieceElement(square)\n        if (piece) {\n            if (visible) {\n                piece.setAttribute(\"visibility\", \"visible\")\n            } else {\n                piece.setAttribute(\"visibility\", \"hidden\")\n            }\n        } else {\n            console.warn(\"no piece on\", square)\n        }\n    }\n\n    getPieceElement(square) {\n        if (!square || square.length < 2) {\n            console.warn(\"invalid square\", square)\n            return null\n        }\n        const piece = this.piecesGroup.querySelector(`g[data-square='${square}']`)\n        if (!piece) {\n            console.warn(\"no piece on\", square)\n            return null\n        }\n        return piece\n    }\n\n    // enable and disable move input //\n\n    enableMoveInput(eventHandler, color = null) {\n        if (this.chessboard.state.moveInputCallback) {\n            throw Error(\"moveInput already enabled\")\n        }\n        if (color === COLOR.white) {\n            this.chessboard.state.inputWhiteEnabled = true\n        } else if (color === COLOR.black) {\n            this.chessboard.state.inputBlackEnabled = true\n        } else {\n            this.chessboard.state.inputWhiteEnabled = true\n            this.chessboard.state.inputBlackEnabled = true\n        }\n        this.chessboard.state.moveInputCallback = eventHandler\n        this.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.moveInputToggled, {enabled: true, color: color})\n        this.visualizeInputState()\n    }\n\n    disableMoveInput() {\n        this.chessboard.state.inputWhiteEnabled = false\n        this.chessboard.state.inputBlackEnabled = false\n        this.chessboard.state.moveInputCallback = null\n        this.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.moveInputToggled, {enabled: false})\n        this.visualizeInputState()\n    }\n\n    // callbacks //\n\n    moveInputStartedCallback(square) {\n        const data = {\n            chessboard: this.chessboard,\n            type: INPUT_EVENT_TYPE.moveInputStarted,\n            square: square, /** square is deprecated, use squareFrom (2023-05-22) */\n            squareFrom: square,\n            piece: this.chessboard.getPiece(square)\n        }\n        if (this.chessboard.state.moveInputCallback) {\n            data.moveInputCallbackResult = this.chessboard.state.moveInputCallback(data)\n        }\n        this.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.moveInput, data)\n        return data.moveInputCallbackResult\n    }\n\n    movingOverSquareCallback(squareFrom, squareTo) {\n        const data = {\n            chessboard: this.chessboard,\n            type: INPUT_EVENT_TYPE.movingOverSquare,\n            squareFrom: squareFrom,\n            squareTo: squareTo,\n            piece: this.chessboard.getPiece(squareFrom)\n        }\n        if (this.chessboard.state.moveInputCallback) {\n            data.moveInputCallbackResult = this.chessboard.state.moveInputCallback(data)\n        }\n        this.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.moveInput, data)\n    }\n\n    validateMoveInputCallback(squareFrom, squareTo) {\n        const data = {\n            chessboard: this.chessboard,\n            type: INPUT_EVENT_TYPE.validateMoveInput,\n            squareFrom: squareFrom,\n            squareTo: squareTo,\n            piece: this.chessboard.getPiece(squareFrom)\n        }\n        if (this.chessboard.state.moveInputCallback) {\n            data.moveInputCallbackResult = this.chessboard.state.moveInputCallback(data)\n        }\n        this.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.moveInput, data)\n        return data.moveInputCallbackResult\n    }\n\n    moveInputCanceledCallback(squareFrom, squareTo, reason) {\n        const data = {\n            chessboard: this.chessboard,\n            type: INPUT_EVENT_TYPE.moveInputCanceled,\n            reason: reason,\n            squareFrom: squareFrom,\n            squareTo: squareTo\n        }\n        if (this.chessboard.state.moveInputCallback) {\n            this.chessboard.state.moveInputCallback(data)\n        }\n        this.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.moveInput, data)\n    }\n\n    moveInputFinishedCallback(squareFrom, squareTo, legalMove) {\n        const data = {\n            chessboard: this.chessboard,\n            type: INPUT_EVENT_TYPE.moveInputFinished,\n            squareFrom: squareFrom,\n            squareTo: squareTo,\n            legalMove: legalMove\n        }\n        if (this.chessboard.state.moveInputCallback) {\n            this.chessboard.state.moveInputCallback(data)\n        }\n        this.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.moveInput, data)\n    }\n\n    // Helpers //\n\n    visualizeInputState() {\n        if (this.chessboard.state) { // fix https://github.com/shaack/cm-chessboard/issues/47\n            if (this.chessboard.state.inputWhiteEnabled || this.chessboard.state.inputBlackEnabled) {\n                this.boardGroup.setAttribute(\"class\", \"board input-enabled\")\n            } else {\n                this.boardGroup.setAttribute(\"class\", \"board\")\n            }\n        }\n    }\n\n    indexToPoint(index) {\n        let x, y\n        if (this.chessboard.state.orientation === COLOR.white) {\n            x = this.borderSize + (index % 8) * this.squareWidth\n            y = this.borderSize + (7 - Math.floor(index / 8)) * this.squareHeight\n        } else {\n            x = this.borderSize + (7 - index % 8) * this.squareWidth\n            y = this.borderSize + (Math.floor(index / 8)) * this.squareHeight\n        }\n        return {x: x, y: y}\n    }\n\n    squareToPoint(square) {\n        const index = _model_Position_js__WEBPACK_IMPORTED_MODULE_1__.Position.squareToIndex(square)\n        return this.indexToPoint(index)\n    }\n\n    getSpriteUrl() {\n        if (_lib_Utils_js__WEBPACK_IMPORTED_MODULE_4__.Utils.isAbsoluteUrl(this.chessboard.props.style.pieces.file)) {\n            return this.chessboard.props.style.pieces.file\n        } else {\n            return this.chessboard.props.assetsUrl + this.chessboard.props.style.pieces.file\n        }\n    }\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/view/ChessboardView.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/view/PositionAnimationsQueue.js":
/*!************************************************************************!*\
  !*** ./node_modules/cm-chessboard/src/view/PositionAnimationsQueue.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ANIMATION_EVENT_TYPE: () => (/* binding */ ANIMATION_EVENT_TYPE),\n/* harmony export */   PositionAnimationsQueue: () => (/* binding */ PositionAnimationsQueue),\n/* harmony export */   PositionsAnimation: () => (/* binding */ PositionsAnimation),\n/* harmony export */   PromiseQueue: () => (/* binding */ PromiseQueue)\n/* harmony export */ });\n/* harmony import */ var _model_Position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/Position.js */ \"./node_modules/cm-chessboard/src/model/Position.js\");\n/* harmony import */ var _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/Svg.js */ \"./node_modules/cm-chessboard/src/lib/Svg.js\");\n/* harmony import */ var _model_Extension_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/Extension.js */ \"./node_modules/cm-chessboard/src/model/Extension.js\");\n/* harmony import */ var _lib_Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/Utils.js */ \"./node_modules/cm-chessboard/src/lib/Utils.js\");\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\n\n\n\n\n/*\n* Thanks to markosyan for the idea of the PromiseQueue\n* https://medium.com/@karenmarkosyan/how-to-manage-promises-into-dynamic-queue-with-vanilla-javascript-9d0d1f8d4df5\n*/\n\nconst ANIMATION_EVENT_TYPE = {\n    start: \"start\",\n    frame: \"frame\",\n    end: \"end\"\n}\n\nclass PromiseQueue {\n\n    constructor() {\n        this.queue = []\n        this.workingOnPromise = false\n        this.stop = false\n    }\n\n    async enqueue(promise) {\n        return new Promise((resolve, reject) => {\n            this.queue.push({\n                promise, resolve, reject,\n            })\n            this.dequeue()\n        })\n    }\n\n    dequeue() {\n        if (this.workingOnPromise) {\n            return\n        }\n        if (this.stop) {\n            this.queue = []\n            this.stop = false\n            return\n        }\n        const entry = this.queue.shift()\n        if (!entry) {\n            return\n        }\n        try {\n            this.workingOnPromise = true\n            entry.promise().then((value) => {\n                this.workingOnPromise = false\n                entry.resolve(value)\n                this.dequeue()\n            }).catch(err => {\n                this.workingOnPromise = false\n                entry.reject(err)\n                this.dequeue()\n            })\n        } catch (err) {\n            this.workingOnPromise = false\n            entry.reject(err)\n            this.dequeue()\n        }\n        return true\n    }\n\n    destroy() {\n        this.stop = true\n    }\n\n}\n\n\nconst CHANGE_TYPE = {\n    move: 0,\n    appear: 1,\n    disappear: 2\n}\n\nclass PositionsAnimation {\n\n    constructor(view, fromPosition, toPosition, duration, callback) {\n        this.view = view\n        if (fromPosition && toPosition) {\n            this.animatedElements = this.createAnimation(fromPosition.squares, toPosition.squares)\n            this.duration = duration\n            this.callback = callback\n            this.frameHandle = requestAnimationFrame(this.animationStep.bind(this))\n        } else {\n            console.error(\"fromPosition\", fromPosition, \"toPosition\", toPosition)\n        }\n        this.view.positionsAnimationTask = _lib_Utils_js__WEBPACK_IMPORTED_MODULE_3__.Utils.createTask()\n        this.view.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.animation, {\n            type: ANIMATION_EVENT_TYPE.start\n        })\n    }\n\n    static seekChanges(fromSquares, toSquares) {\n        const appearedList = [], disappearedList = [], changes = []\n        for (let i = 0; i < 64; i++) {\n            const previousSquare = fromSquares[i]\n            const newSquare = toSquares[i]\n            if (newSquare !== previousSquare) {\n                if (newSquare) {\n                    appearedList.push({piece: newSquare, index: i})\n                }\n                if (previousSquare) {\n                    disappearedList.push({piece: previousSquare, index: i})\n                }\n            }\n        }\n        appearedList.forEach((appeared) => {\n            let shortestDistance = 8\n            let foundMoved = null\n            disappearedList.forEach((disappeared) => {\n                if (appeared.piece === disappeared.piece) {\n                    const moveDistance = PositionsAnimation.squareDistance(appeared.index, disappeared.index)\n                    if (moveDistance < shortestDistance) {\n                        foundMoved = disappeared\n                        shortestDistance = moveDistance\n                    }\n                }\n            })\n            if (foundMoved) {\n                disappearedList.splice(disappearedList.indexOf(foundMoved), 1) // remove from disappearedList, because it is moved now\n                changes.push({\n                    type: CHANGE_TYPE.move,\n                    piece: appeared.piece,\n                    atIndex: foundMoved.index,\n                    toIndex: appeared.index\n                })\n            } else {\n                changes.push({type: CHANGE_TYPE.appear, piece: appeared.piece, atIndex: appeared.index})\n            }\n        })\n        disappearedList.forEach((disappeared) => {\n            changes.push({type: CHANGE_TYPE.disappear, piece: disappeared.piece, atIndex: disappeared.index})\n        })\n        return changes\n    }\n\n    createAnimation(fromSquares, toSquares) {\n        const changes = PositionsAnimation.seekChanges(fromSquares, toSquares)\n        const animatedElements = []\n        changes.forEach((change) => {\n            const animatedItem = {\n                type: change.type\n            }\n            switch (change.type) {\n                case CHANGE_TYPE.move:\n                    animatedItem.element = this.view.getPieceElement(_model_Position_js__WEBPACK_IMPORTED_MODULE_0__.Position.indexToSquare(change.atIndex))\n                    animatedItem.element.parentNode.appendChild(animatedItem.element) // move element to top layer\n                    animatedItem.atPoint = this.view.indexToPoint(change.atIndex)\n                    animatedItem.toPoint = this.view.indexToPoint(change.toIndex)\n                    break\n                case CHANGE_TYPE.appear:\n                    animatedItem.element = this.view.drawPieceOnSquare(_model_Position_js__WEBPACK_IMPORTED_MODULE_0__.Position.indexToSquare(change.atIndex), change.piece)\n                    animatedItem.element.style.opacity = 0\n                    break\n                case CHANGE_TYPE.disappear:\n                    animatedItem.element = this.view.getPieceElement(_model_Position_js__WEBPACK_IMPORTED_MODULE_0__.Position.indexToSquare(change.atIndex))\n                    break\n            }\n            animatedElements.push(animatedItem)\n        })\n        return animatedElements\n    }\n\n    animationStep(time) {\n        if(!this.view || !this.view.chessboard.state) { // board was destroyed\n            return\n        }\n        if (!this.startTime) {\n            this.startTime = time\n        }\n        const timeDiff = time - this.startTime\n        if (timeDiff <= this.duration) {\n            this.frameHandle = requestAnimationFrame(this.animationStep.bind(this))\n        } else {\n            cancelAnimationFrame(this.frameHandle)\n            this.animatedElements.forEach((animatedItem) => {\n                if (animatedItem.type === CHANGE_TYPE.disappear) {\n                    _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.removeElement(animatedItem.element)\n                }\n            })\n            this.view.positionsAnimationTask.resolve()\n            this.view.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.animation, {\n                type: ANIMATION_EVENT_TYPE.end\n            })\n            this.callback()\n            return\n        }\n        const t = Math.min(1, timeDiff / this.duration)\n        let progress = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t // easeInOut\n        if (isNaN(progress) || progress > 0.99) {\n            progress = 1\n        }\n        this.animatedElements.forEach((animatedItem) => {\n            if (animatedItem.element) {\n                switch (animatedItem.type) {\n                    case CHANGE_TYPE.move:\n                        animatedItem.element.transform.baseVal.removeItem(0)\n                        const transform = (this.view.svg.createSVGTransform())\n                        transform.setTranslate(\n                            animatedItem.atPoint.x + (animatedItem.toPoint.x - animatedItem.atPoint.x) * progress,\n                            animatedItem.atPoint.y + (animatedItem.toPoint.y - animatedItem.atPoint.y) * progress)\n                        animatedItem.element.transform.baseVal.appendItem(transform)\n                        break\n                    case CHANGE_TYPE.appear:\n                        animatedItem.element.style.opacity = Math.round(progress * 100) / 100\n                        break\n                    case CHANGE_TYPE.disappear:\n                        animatedItem.element.style.opacity = Math.round((1 - progress) * 100) / 100\n                        break\n                }\n            } else {\n                console.warn(\"animatedItem has no element\", animatedItem)\n            }\n        })\n        this.view.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.animation, {\n            type: ANIMATION_EVENT_TYPE.frame,\n            progress: progress\n        })\n    }\n\n    static squareDistance(index1, index2) {\n        const file1 = index1 % 8\n        const rank1 = Math.floor(index1 / 8)\n        const file2 = index2 % 8\n        const rank2 = Math.floor(index2 / 8)\n        return Math.max(Math.abs(rank2 - rank1), Math.abs(file2 - file1))\n    }\n\n}\n\nclass PositionAnimationsQueue extends PromiseQueue {\n\n    constructor(chessboard) {\n        super()\n        this.chessboard = chessboard\n    }\n\n    async enqueuePositionChange(positionFrom, positionTo, animated) {\n        if(positionFrom.getFen() === positionTo.getFen()) {\n            return Promise.resolve()\n        } else {\n            return super.enqueue(() => new Promise((resolve) => {\n                let duration = animated ? this.chessboard.props.style.animationDuration : 0\n                if (this.queue.length > 0) {\n                    duration = duration / (1 + Math.pow(this.queue.length / 5, 2))\n                }\n                new PositionsAnimation(this.chessboard.view,\n                    positionFrom, positionTo, animated ? duration : 0,\n                    () => {\n                        if (this.chessboard.view) { // if destroyed, no view anymore\n                            this.chessboard.view.redrawPieces(positionTo.squares)\n                        }\n                        resolve()\n                    }\n                )\n            }))\n        }\n    }\n\n    async enqueueTurnBoard(position, color, animated) {\n        return super.enqueue(() => new Promise((resolve) => {\n            const emptyPosition = new _model_Position_js__WEBPACK_IMPORTED_MODULE_0__.Position(_model_Position_js__WEBPACK_IMPORTED_MODULE_0__.FEN.empty)\n            let duration = animated ? this.chessboard.props.style.animationDuration : 0\n            if(this.queue.length > 0) {\n                duration = duration / (1 + Math.pow(this.queue.length / 5, 2))\n            }\n            new PositionsAnimation(this.chessboard.view,\n                position, emptyPosition, animated ? duration : 0,\n                () => {\n                    this.chessboard.state.orientation = color\n                    this.chessboard.view.redrawBoard()\n                    this.chessboard.view.redrawPieces(emptyPosition.squares)\n                    new PositionsAnimation(this.chessboard.view,\n                        emptyPosition, position, animated ? duration : 0,\n                        () => {\n                            this.chessboard.view.redrawPieces(position.squares)\n                            resolve()\n                        }\n                    )\n                }\n            )\n        }))\n    }\n\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/view/PositionAnimationsQueue.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/view/VisualMoveInput.js":
/*!****************************************************************!*\
  !*** ./node_modules/cm-chessboard/src/view/VisualMoveInput.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MOVE_CANCELED_REASON: () => (/* binding */ MOVE_CANCELED_REASON),\n/* harmony export */   VisualMoveInput: () => (/* binding */ VisualMoveInput)\n/* harmony export */ });\n/* harmony import */ var _lib_Svg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/Svg.js */ \"./node_modules/cm-chessboard/src/lib/Svg.js\");\n/* harmony import */ var _lib_Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/Utils.js */ \"./node_modules/cm-chessboard/src/lib/Utils.js\");\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\n\n\n\nconst MOVE_INPUT_STATE = {\n    waitForInputStart: \"waitForInputStart\",\n    pieceClickedThreshold: \"pieceClickedThreshold\",\n    clickTo: \"clickTo\",\n    secondClickThreshold: \"secondClickThreshold\",\n    dragTo: \"dragTo\",\n    clickDragTo: \"clickDragTo\",\n    moveDone: \"moveDone\",\n    reset: \"reset\"\n}\n\nconst MOVE_CANCELED_REASON = {\n    secondClick: \"secondClick\", // clicked the same piece\n    secondaryClick: \"secondaryClick\", // right click while moving\n    movedOutOfBoard: \"movedOutOfBoard\",\n    draggedBack: \"draggedBack\", // dragged to the start square\n    clickedAnotherPiece: \"clickedAnotherPiece\" // of the same color\n}\n\nconst DRAG_THRESHOLD = 4\n\nclass VisualMoveInput {\n\n    constructor(view) {\n        this.view = view\n        this.chessboard = view.chessboard\n        this.moveInputState = null\n        this.fromSquare = null\n        this.toSquare = null\n\n        this.setMoveInputState(MOVE_INPUT_STATE.waitForInputStart)\n    }\n\n    moveInputStartedCallback(square) {\n        const result = this.view.moveInputStartedCallback(square)\n        if (result) {\n            this.chessboard.state.moveInputProcess = _lib_Utils_js__WEBPACK_IMPORTED_MODULE_1__.Utils.createTask()\n            this.chessboard.state.moveInputProcess.then((result) => {\n                if (this.moveInputState === MOVE_INPUT_STATE.waitForInputStart ||\n                    this.moveInputState === MOVE_INPUT_STATE.moveDone) {\n                    this.view.moveInputFinishedCallback(this.fromSquare, this.toSquare, result)\n                }\n            })\n        }\n        return result\n    }\n\n    movingOverSquareCallback(fromSquare, toSquare) {\n        this.view.movingOverSquareCallback(fromSquare, toSquare)\n    }\n\n    validateMoveInputCallback(fromSquare, toSquare) {\n        const result = this.view.validateMoveInputCallback(fromSquare, toSquare)\n        this.chessboard.state.moveInputProcess.resolve(result)\n        return result\n    }\n\n    moveInputCanceledCallback(fromSquare, toSquare, reason) {\n        this.view.moveInputCanceledCallback(fromSquare, toSquare, reason)\n        this.chessboard.state.moveInputProcess.resolve()\n    }\n\n    setMoveInputState(newState, params = undefined) {\n        const prevState = this.moveInputState\n        this.moveInputState = newState\n\n        switch (newState) {\n\n            case MOVE_INPUT_STATE.waitForInputStart:\n                break\n\n            case MOVE_INPUT_STATE.pieceClickedThreshold:\n                if (MOVE_INPUT_STATE.waitForInputStart !== prevState && MOVE_INPUT_STATE.clickTo !== prevState) {\n                    throw new Error(\"moveInputState\")\n                }\n                if (this.pointerMoveListener) {\n                    removeEventListener(this.pointerMoveListener.type, this.pointerMoveListener)\n                    this.pointerMoveListener = null\n                }\n                if (this.pointerUpListener) {\n                    removeEventListener(this.pointerUpListener.type, this.pointerUpListener)\n                    this.pointerUpListener = null\n                }\n                this.fromSquare = params.square\n                this.toSquare = null\n                this.movedPiece = params.piece\n                this.startPoint = params.point\n                if (!this.pointerMoveListener && !this.pointerUpListener) {\n                    if (params.type === \"mousedown\") {\n                        this.pointerMoveListener = this.onPointerMove.bind(this)\n                        this.pointerMoveListener.type = \"mousemove\"\n                        addEventListener(\"mousemove\", this.pointerMoveListener)\n                        this.pointerUpListener = this.onPointerUp.bind(this)\n                        this.pointerUpListener.type = \"mouseup\"\n                        addEventListener(\"mouseup\", this.pointerUpListener)\n                    } else if (params.type === \"touchstart\") {\n                        this.pointerMoveListener = this.onPointerMove.bind(this)\n                        this.pointerMoveListener.type = \"touchmove\"\n                        addEventListener(\"touchmove\", this.pointerMoveListener)\n                        this.pointerUpListener = this.onPointerUp.bind(this)\n                        this.pointerUpListener.type = \"touchend\"\n                        addEventListener(\"touchend\", this.pointerUpListener)\n                    } else {\n                        throw Error(\"4b74af\")\n                    }\n                    if (!this.contextMenuListener) {\n                        this.contextMenuListener = this.onContextMenu.bind(this)\n                        this.chessboard.view.svg.addEventListener(\"contextmenu\", this.contextMenuListener)\n                    }\n                } else {\n                    throw Error(\"94ad0c\")\n                }\n                break\n\n            case MOVE_INPUT_STATE.clickTo:\n                if (this.draggablePiece) {\n                    _lib_Svg_js__WEBPACK_IMPORTED_MODULE_0__.Svg.removeElement(this.draggablePiece)\n                    this.draggablePiece = null\n                }\n                if (prevState === MOVE_INPUT_STATE.dragTo) {\n                    this.view.setPieceVisibility(params.square, true)\n                }\n                break\n\n            case MOVE_INPUT_STATE.secondClickThreshold:\n                if (MOVE_INPUT_STATE.clickTo !== prevState) {\n                    throw new Error(\"moveInputState\")\n                }\n                this.startPoint = params.point\n                break\n\n            case MOVE_INPUT_STATE.dragTo:\n                if (MOVE_INPUT_STATE.pieceClickedThreshold !== prevState) {\n                    throw new Error(\"moveInputState\")\n                }\n                if (this.view.chessboard.state.inputEnabled()) {\n                    this.view.setPieceVisibility(params.square, false)\n                    this.createDraggablePiece(params.piece)\n                }\n                break\n\n            case MOVE_INPUT_STATE.clickDragTo:\n                if (MOVE_INPUT_STATE.secondClickThreshold !== prevState) {\n                    throw new Error(\"moveInputState\")\n                }\n                if (this.view.chessboard.state.inputEnabled()) {\n                    this.view.setPieceVisibility(params.square, false)\n                    this.createDraggablePiece(params.piece)\n                }\n                break\n\n            case MOVE_INPUT_STATE.moveDone:\n                if ([MOVE_INPUT_STATE.dragTo, MOVE_INPUT_STATE.clickTo, MOVE_INPUT_STATE.clickDragTo].indexOf(prevState) === -1) {\n                    throw new Error(\"moveInputState\")\n                }\n                this.toSquare = params.square\n                if (this.toSquare && this.validateMoveInputCallback(this.fromSquare, this.toSquare)) {\n                    this.chessboard.movePiece(this.fromSquare, this.toSquare, prevState === MOVE_INPUT_STATE.clickTo).then(() => {\n                        if (prevState === MOVE_INPUT_STATE.clickTo) {\n                            this.view.setPieceVisibility(this.toSquare, true)\n                        }\n                        this.setMoveInputState(MOVE_INPUT_STATE.reset)\n                    })\n                } else {\n                    this.view.setPieceVisibility(this.fromSquare, true)\n                    this.setMoveInputState(MOVE_INPUT_STATE.reset)\n                }\n                break\n\n            case MOVE_INPUT_STATE.reset:\n                if (this.fromSquare && !this.toSquare && this.movedPiece) {\n                    this.chessboard.state.position.setPiece(this.fromSquare, this.movedPiece)\n                }\n                this.fromSquare = null\n                this.toSquare = null\n                this.movedPiece = null\n                if (this.draggablePiece) {\n                    _lib_Svg_js__WEBPACK_IMPORTED_MODULE_0__.Svg.removeElement(this.draggablePiece)\n                    this.draggablePiece = null\n                }\n                if (this.pointerMoveListener) {\n                    removeEventListener(this.pointerMoveListener.type, this.pointerMoveListener)\n                    this.pointerMoveListener = null\n                }\n                if (this.pointerUpListener) {\n                    removeEventListener(this.pointerUpListener.type, this.pointerUpListener)\n                    this.pointerUpListener = null\n                }\n                if (this.contextMenuListener) {\n                    removeEventListener(\"contextmenu\", this.contextMenuListener)\n                    this.contextMenuListener = null\n                }\n                this.setMoveInputState(MOVE_INPUT_STATE.waitForInputStart)\n                // set temporarily hidden pieces visible again\n                const hiddenPieces = this.view.piecesGroup.querySelectorAll(\"[visibility=hidden]\")\n                for (let i = 0; i < hiddenPieces.length; i++) {\n                    hiddenPieces[i].removeAttribute(\"visibility\")\n                }\n                break\n\n            default:\n                throw Error(`260b09: moveInputState ${newState}`)\n        }\n    }\n\n    createDraggablePiece(pieceName) {\n        // maybe I should use the existing piece from the board and don't create a new one\n        if (this.draggablePiece) {\n            throw Error(\"draggablePiece already exists\")\n        }\n        this.draggablePiece = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_0__.Svg.createSvg(document.body)\n        this.draggablePiece.classList.add(\"cm-chessboard-draggable-piece\")\n        this.draggablePiece.setAttribute(\"width\", this.view.squareWidth)\n        this.draggablePiece.setAttribute(\"height\", this.view.squareHeight)\n        this.draggablePiece.setAttribute(\"style\", \"pointer-events: none\")\n        this.draggablePiece.name = pieceName\n        const spriteUrl = this.chessboard.props.assetsCache ? \"\" : this.view.getSpriteUrl()\n        const piece = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_0__.Svg.addElement(this.draggablePiece, \"use\", {\n            href: `${spriteUrl}#${pieceName}`\n        })\n        const scaling = this.view.squareHeight / this.chessboard.props.style.pieces.tileSize\n        const transformScale = (this.draggablePiece.createSVGTransform())\n        transformScale.setScale(scaling, scaling)\n        piece.transform.baseVal.appendItem(transformScale)\n    }\n\n    moveDraggablePiece(x, y) {\n        this.draggablePiece.setAttribute(\"style\",\n            `pointer-events: none; position: absolute; left: ${x - (this.view.squareHeight / 2)}px; top: ${y - (this.view.squareHeight / 2)}px`)\n    }\n\n    onPointerDown(e) {\n        if (!(e.type === \"mousedown\" && e.button === 0 || e.type === \"touchstart\")) {\n            return\n        }\n        const square = e.target.getAttribute(\"data-square\")\n        if (!square) { // pointer on square\n            return\n        }\n        const pieceName = this.chessboard.getPiece(square)\n        let color\n        if (pieceName) {\n            color = pieceName ? pieceName.substring(0, 1) : null\n            // allow scrolling, if not pointed on draggable piece\n            if (color === \"w\" && this.chessboard.state.inputWhiteEnabled ||\n                color === \"b\" && this.chessboard.state.inputBlackEnabled) {\n                e.preventDefault()\n            }\n        }\n        if (this.moveInputState !== MOVE_INPUT_STATE.waitForInputStart ||\n            this.chessboard.state.inputWhiteEnabled && color === \"w\" ||\n            this.chessboard.state.inputBlackEnabled && color === \"b\") {\n            let point\n            if (e.type === \"mousedown\") {\n                point = {x: e.clientX, y: e.clientY}\n            } else if (e.type === \"touchstart\") {\n                point = {x: e.touches[0].clientX, y: e.touches[0].clientY}\n            }\n            if (this.moveInputState === MOVE_INPUT_STATE.waitForInputStart && pieceName && this.moveInputStartedCallback(square)) {\n                this.setMoveInputState(MOVE_INPUT_STATE.pieceClickedThreshold, {\n                    square: square,\n                    piece: pieceName,\n                    point: point,\n                    type: e.type\n                })\n            } else if (this.moveInputState === MOVE_INPUT_STATE.clickTo) {\n                if (square === this.fromSquare) {\n                    this.setMoveInputState(MOVE_INPUT_STATE.secondClickThreshold, {\n                        square: square,\n                        piece: pieceName,\n                        point: point,\n                        type: e.type\n                    })\n                } else {\n                    const pieceName = this.chessboard.getPiece(square)\n                    const pieceColor = pieceName ? pieceName.substring(0, 1) : null\n                    const startPieceName = this.chessboard.getPiece(this.fromSquare)\n                    const startPieceColor = startPieceName ? startPieceName.substring(0, 1) : null\n                    if (color && startPieceColor === pieceColor) {\n                        this.moveInputCanceledCallback(this.fromSquare, square, MOVE_CANCELED_REASON.clickedAnotherPiece)\n                        if (this.moveInputStartedCallback(square)) {\n                            this.setMoveInputState(MOVE_INPUT_STATE.pieceClickedThreshold, {\n                                square: square,\n                                piece: pieceName,\n                                point: point,\n                                type: e.type\n                            })\n                        } else {\n                            this.setMoveInputState(MOVE_INPUT_STATE.reset)\n                        }\n                    } else {\n                        this.setMoveInputState(MOVE_INPUT_STATE.moveDone, {square: square})\n                    }\n                }\n            }\n        }\n    }\n\n    onPointerMove(e) {\n        let pageX, pageY, clientX, clientY, target\n        if (e.type === \"mousemove\") {\n            clientX = e.clientX\n            clientY = e.clientY\n            pageX = e.pageX\n            pageY = e.pageY\n            target = e.target\n        } else if (e.type === \"touchmove\") {\n            clientX = e.touches[0].clientX\n            clientY = e.touches[0].clientY\n            pageX = e.touches[0].pageX\n            pageY = e.touches[0].pageY\n            target = document.elementFromPoint(clientX, clientY)\n        }\n        if (this.moveInputState === MOVE_INPUT_STATE.pieceClickedThreshold || this.moveInputState === MOVE_INPUT_STATE.secondClickThreshold) {\n            if (Math.abs(this.startPoint.x - clientX) > DRAG_THRESHOLD || Math.abs(this.startPoint.y - clientY) > DRAG_THRESHOLD) {\n                if (this.moveInputState === MOVE_INPUT_STATE.secondClickThreshold) {\n                    this.setMoveInputState(MOVE_INPUT_STATE.clickDragTo, {\n                        square: this.fromSquare,\n                        piece: this.movedPiece\n                    })\n                } else {\n                    this.setMoveInputState(MOVE_INPUT_STATE.dragTo, {square: this.fromSquare, piece: this.movedPiece})\n                }\n                if (this.view.chessboard.state.inputEnabled()) {\n                    this.moveDraggablePiece(pageX, pageY)\n                }\n            }\n        } else if (this.moveInputState === MOVE_INPUT_STATE.dragTo || this.moveInputState === MOVE_INPUT_STATE.clickDragTo || this.moveInputState === MOVE_INPUT_STATE.clickTo) {\n            if (target && target.getAttribute && target.parentElement === this.view.boardGroup) {\n                const square = target.getAttribute(\"data-square\")\n                if (square !== this.fromSquare && square !== this.toSquare) {\n                    this.toSquare = square\n                    this.movingOverSquareCallback(this.fromSquare, this.toSquare)\n                } else if (square === this.fromSquare && this.toSquare !== null) {\n                    this.toSquare = null\n                    this.movingOverSquareCallback(this.fromSquare, null)\n                }\n            } else if (this.toSquare !== null) {\n                this.toSquare = null\n                this.movingOverSquareCallback(this.fromSquare, null)\n            }\n\n            if (this.view.chessboard.state.inputEnabled() && (this.moveInputState === MOVE_INPUT_STATE.dragTo || this.moveInputState === MOVE_INPUT_STATE.clickDragTo)) {\n                this.moveDraggablePiece(pageX, pageY)\n            }\n        }\n    }\n\n    onPointerUp(e) {\n        let target\n        if (e.type === \"mouseup\") {\n            target = e.target\n        } else if (e.type === \"touchend\") {\n            target = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY)\n        }\n        if (target && target.getAttribute) {\n            const square = target.getAttribute(\"data-square\")\n\n            if (square) {\n                if (this.moveInputState === MOVE_INPUT_STATE.dragTo || this.moveInputState === MOVE_INPUT_STATE.clickDragTo) {\n                    if (this.fromSquare === square) {\n                        if (this.moveInputState === MOVE_INPUT_STATE.clickDragTo) {\n                            this.chessboard.state.position.setPiece(this.fromSquare, this.movedPiece)\n                            this.view.setPieceVisibility(this.fromSquare)\n                            this.moveInputCanceledCallback(square, null, MOVE_CANCELED_REASON.draggedBack)\n                            this.setMoveInputState(MOVE_INPUT_STATE.reset)\n                        } else {\n                            this.setMoveInputState(MOVE_INPUT_STATE.clickTo, {square: square})\n                        }\n                    } else {\n                        this.setMoveInputState(MOVE_INPUT_STATE.moveDone, {square: square})\n                    }\n                } else if (this.moveInputState === MOVE_INPUT_STATE.pieceClickedThreshold) {\n                    this.setMoveInputState(MOVE_INPUT_STATE.clickTo, {square: square})\n                } else if (this.moveInputState === MOVE_INPUT_STATE.secondClickThreshold) {\n                    this.setMoveInputState(MOVE_INPUT_STATE.reset)\n                    this.moveInputCanceledCallback(square, null, MOVE_CANCELED_REASON.secondClick)\n                }\n            } else {\n                this.view.redrawPieces()\n                const moveStartSquare = this.fromSquare\n                this.setMoveInputState(MOVE_INPUT_STATE.reset)\n                this.moveInputCanceledCallback(moveStartSquare, null, MOVE_CANCELED_REASON.movedOutOfBoard)\n            }\n        } else {\n            this.view.redrawPieces()\n            this.setMoveInputState(MOVE_INPUT_STATE.reset)\n        }\n    }\n\n    onContextMenu(e) { // while moving\n        e.preventDefault()\n        this.view.redrawPieces()\n        this.setMoveInputState(MOVE_INPUT_STATE.reset)\n        this.moveInputCanceledCallback(this.fromSquare, null, MOVE_CANCELED_REASON.secondaryClick)\n    }\n\n    isDragging() {\n        return this.moveInputState === MOVE_INPUT_STATE.dragTo || this.moveInputState === MOVE_INPUT_STATE.clickDragTo\n    }\n\n    destroy() {\n        this.setMoveInputState(MOVE_INPUT_STATE.reset)\n    }\n\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/view/VisualMoveInput.js?");

/***/ }),

/***/ "./models/heavy_move_to_int_imot.json":
/*!********************************************!*\
  !*** ./models/heavy_move_to_int_imot.json ***!
  \********************************************/
/***/ ((module) => {

eval("module.exports = /*#__PURE__*/JSON.parse('{\"e6c6\":0,\"e4g2\":1,\"f6g4\":2,\"a2f7\":3,\"a1h1\":4,\"e4e5\":5,\"e2c2\":6,\"b8h2\":7,\"b1b4\":8,\"d3f2\":9,\"c7a7\":10,\"d7f5\":11,\"b5b8\":12,\"b6c7\":13,\"c8d8\":14,\"c1g1\":15,\"e5f7\":16,\"f5f7\":17,\"f7f4\":18,\"c7e7\":19,\"e6f6\":20,\"d3d4\":21,\"b3d4\":22,\"e3c4\":23,\"e2h2\":24,\"e8c7\":25,\"b7e7\":26,\"e7e8\":27,\"f3f4\":28,\"b8b1\":29,\"c3d3\":30,\"f7g6\":31,\"b5b3\":32,\"g2f4\":33,\"h1e1\":34,\"a1d4\":35,\"g3f5\":36,\"b2b1r\":37,\"g3h1\":38,\"c4c5\":39,\"g1g6\":40,\"g1h1\":41,\"g2a8\":42,\"d6c6\":43,\"c6a8\":44,\"h2h1\":45,\"c7g7\":46,\"g4h6\":47,\"g8h8\":48,\"d5d2\":49,\"h4h6\":50,\"d3b5\":51,\"e5b5\":52,\"g3e1\":53,\"c1g5\":54,\"b2a4\":55,\"e6b3\":56,\"d6f7\":57,\"d4g1\":58,\"f8f4\":59,\"h5e8\":60,\"c1c7\":61,\"h7h1\":62,\"f5h3\":63,\"c7a8\":64,\"g1f3\":65,\"a3g3\":66,\"g2e1\":67,\"c5a5\":68,\"c2e1\":69,\"a1a7\":70,\"f1f7\":71,\"c7b7\":72,\"g2c2\":73,\"a8c8\":74,\"c3c7\":75,\"g2e3\":76,\"h1a1\":77,\"c2c6\":78,\"b5d5\":79,\"b7a5\":80,\"f3a8\":81,\"e1e6\":82,\"g7e7\":83,\"b5b1\":84,\"a8f8\":85,\"f7g8q\":86,\"e4e8\":87,\"f8b8\":88,\"f4g3\":89,\"a7a4\":90,\"e2g3\":91,\"a4a1\":92,\"d2b2\":93,\"f8g6\":94,\"g6e8\":95,\"d3c3\":96,\"c7c5\":97,\"e1d2\":98,\"c3c4\":99,\"c2b1\":100,\"d5d1\":101,\"b5d7\":102,\"f2g4\":103,\"g6d3\":104,\"c1d1\":105,\"g3g4\":106,\"c7a5\":107,\"g3f4\":108,\"b4b6\":109,\"h1h8\":110,\"a4d1\":111,\"b8b7\":112,\"e6e4\":113,\"h2c2\":114,\"c4f1\":115,\"a1g1\":116,\"c2f2\":117,\"h5h6\":118,\"g1a7\":119,\"h2h1q\":120,\"h3a3\":121,\"c4b6\":122,\"g2c6\":123,\"d3h7\":124,\"h8h6\":125,\"f6f7\":126,\"h1g1\":127,\"c5e4\":128,\"a2g2\":129,\"d4e3\":130,\"e5c4\":131,\"d8d3\":132,\"e5g5\":133,\"b6a7\":134,\"h4h8\":135,\"c6a4\":136,\"c6e8\":137,\"b5a6\":138,\"e3e7\":139,\"d5f7\":140,\"f4f3\":141,\"d5h5\":142,\"c2c7\":143,\"e2d3\":144,\"d1d2\":145,\"c8c6\":146,\"e5g4\":147,\"g3f1\":148,\"a4b5\":149,\"b8b3\":150,\"g5b5\":151,\"d5b3\":152,\"c2c1q\":153,\"b3a3\":154,\"g7f8n\":155,\"e6g8\":156,\"a5e5\":157,\"e7e8n\":158,\"b4b8\":159,\"g7d7\":160,\"e3e1\":161,\"d8g5\":162,\"d6h6\":163,\"g7b2\":164,\"a8h1\":165,\"c4h4\":166,\"h4b4\":167,\"d7d6\":168,\"a5b4\":169,\"b2d3\":170,\"d5e7\":171,\"e1c3\":172,\"d2e1\":173,\"a3c2\":174,\"f7c7\":175,\"d2h6\":176,\"h6f7\":177,\"f3e4\":178,\"e5f6\":179,\"c4a6\":180,\"g8c8\":181,\"d3b1\":182,\"b6b7\":183,\"f2e3\":184,\"c6d8\":185,\"f7g8\":186,\"c6e4\":187,\"c2b2\":188,\"f5f2\":189,\"b3e3\":190,\"c4d5\":191,\"d4a7\":192,\"f7h6\":193,\"e6d8\":194,\"h3g4\":195,\"a2a3\":196,\"f3d3\":197,\"e8e2\":198,\"f6a6\":199,\"c3b2\":200,\"a4c5\":201,\"a4c6\":202,\"c8a7\":203,\"c6c2\":204,\"f2h2\":205,\"b1b8\":206,\"d3e3\":207,\"h7b7\":208,\"b3b6\":209,\"a8g2\":210,\"b1c3\":211,\"a3b1\":212,\"g4g8\":213,\"h4e7\":214,\"c8e6\":215,\"b5a3\":216,\"c3e5\":217,\"d6a6\":218,\"f4g2\":219,\"e5g3\":220,\"c3c8\":221,\"d5f5\":222,\"b8b5\":223,\"d8g8\":224,\"g7h8\":225,\"c8f8\":226,\"b2e2\":227,\"c8f5\":228,\"f4f6\":229,\"g8b8\":230,\"b6d4\":231,\"e4c3\":232,\"e6e3\":233,\"d6f5\":234,\"c7h2\":235,\"a7g1\":236,\"c2d1q\":237,\"e4b7\":238,\"d4e5\":239,\"f5c8\":240,\"e3c2\":241,\"h5h8\":242,\"d5d4\":243,\"g6h4\":244,\"b8h8\":245,\"f3e3\":246,\"d8f8\":247,\"h7g6\":248,\"b5c5\":249,\"d6e7\":250,\"b5f1\":251,\"d8c7\":252,\"e1d1\":253,\"b6d6\":254,\"h3e6\":255,\"d8h4\":256,\"e3f2\":257,\"h8h1\":258,\"d6b4\":259,\"c5c3\":260,\"g6f6\":261,\"e8b5\":262,\"e2e1\":263,\"g4e4\":264,\"h3f1\":265,\"a4a6\":266,\"g6b1\":267,\"e4c6\":268,\"b3b1\":269,\"a8f3\":270,\"d2f4\":271,\"e6f8\":272,\"b4a4\":273,\"g5f7\":274,\"e2d2\":275,\"f7d5\":276,\"d8e6\":277,\"a3a2\":278,\"f6d8\":279,\"b4c6\":280,\"f8h6\":281,\"f2h3\":282,\"d5c7\":283,\"g4f6\":284,\"d6f4\":285,\"c6a5\":286,\"c3e3\":287,\"h8g6\":288,\"d3g6\":289,\"b5b4\":290,\"a3b4\":291,\"e4e6\":292,\"d5d8\":293,\"f5e3\":294,\"d2d5\":295,\"h4d8\":296,\"a7b6\":297,\"g7c3\":298,\"f2e2\":299,\"g6f4\":300,\"e3e8\":301,\"c4b4\":302,\"b7h1\":303,\"f3d2\":304,\"d4e2\":305,\"d5f3\":306,\"e7e6\":307,\"g1d1\":308,\"g8g1\":309,\"e7d6\":310,\"d2h2\":311,\"b3d3\":312,\"d5d3\":313,\"e3h6\":314,\"h4a4\":315,\"f8f2\":316,\"d7c8q\":317,\"e1f3\":318,\"f8d8\":319,\"a7a5\":320,\"b2b7\":321,\"c2c5\":322,\"a2d2\":323,\"e7b7\":324,\"g5g6\":325,\"e3a7\":326,\"e5b8\":327,\"c2d2\":328,\"a1b3\":329,\"e6d4\":330,\"h5b5\":331,\"a7c6\":332,\"h6d6\":333,\"f1f8\":334,\"c6c8\":335,\"b6a5\":336,\"g4d1\":337,\"f7d6\":338,\"g5c1\":339,\"c7c3\":340,\"c3b4\":341,\"b4d5\":342,\"c6b8\":343,\"d7d8\":344,\"b3h3\":345,\"f6f8\":346,\"b4c4\":347,\"g4d4\":348,\"a2a1\":349,\"f8c8\":350,\"f3f1\":351,\"g3g8\":352,\"h2c7\":353,\"g4h3\":354,\"a5a3\":355,\"e6e5\":356,\"a2a1b\":357,\"e2e4\":358,\"h2g1\":359,\"g2g7\":360,\"g8g5\":361,\"b8d7\":362,\"g6h8\":363,\"d1c2\":364,\"b8c8\":365,\"g7h5\":366,\"f6f3\":367,\"d3c4\":368,\"d8a8\":369,\"c4e2\":370,\"f6d5\":371,\"e7g6\":372,\"h5g4\":373,\"f1f4\":374,\"e2d1\":375,\"h7h6\":376,\"b2b1\":377,\"h5h1\":378,\"c5d7\":379,\"d2a5\":380,\"c3a4\":381,\"d7c6\":382,\"c5h5\":383,\"f4f5\":384,\"c8d7\":385,\"c1b3\":386,\"d6b7\":387,\"f4e3\":388,\"d5b7\":389,\"d1d8\":390,\"c2f5\":391,\"c7d8q\":392,\"f3b3\":393,\"f8b4\":394,\"d6a3\":395,\"g7f7\":396,\"g1e1\":397,\"e5e7\":398,\"h1f2\":399,\"b8a7\":400,\"f4f8\":401,\"h2e2\":402,\"c4e6\":403,\"c6a6\":404,\"d2b4\":405,\"f4g5\":406,\"h6e6\":407,\"d3c2\":408,\"c3c6\":409,\"e2e3\":410,\"f4b4\":411,\"d4c3\":412,\"f6f1\":413,\"b5c3\":414,\"b4b5\":415,\"e5h5\":416,\"b1a2\":417,\"g2f1\":418,\"e8e5\":419,\"d2e1q\":420,\"h8h7\":421,\"a7h7\":422,\"h1a8\":423,\"e4h7\":424,\"h1c1\":425,\"b6b2\":426,\"d3f5\":427,\"e3d4\":428,\"a6a7\":429,\"g2g8\":430,\"a3a1\":431,\"b8f8\":432,\"f6a1\":433,\"e7e1\":434,\"f6e6\":435,\"e8e3\":436,\"a6g6\":437,\"c7b5\":438,\"a5a2\":439,\"h2e5\":440,\"a6a4\":441,\"f7f3\":442,\"b2c2\":443,\"g7c7\":444,\"d7f8\":445,\"b7b4\":446,\"h8f6\":447,\"f5g3\":448,\"h2a2\":449,\"f2d1\":450,\"f5d7\":451,\"f4e2\":452,\"g5h3\":453,\"f4g4\":454,\"e6f5\":455,\"a8g8\":456,\"g5g3\":457,\"a4b4\":458,\"e2a6\":459,\"h3f3\":460,\"h2g3\":461,\"h7h5\":462,\"g4f5\":463,\"h4h7\":464,\"g1a1\":465,\"a1c2\":466,\"h8c8\":467,\"b7d8\":468,\"g2f2\":469,\"a1h8\":470,\"d7h3\":471,\"d1a4\":472,\"d5f6\":473,\"e5e3\":474,\"c4e4\":475,\"f1d3\":476,\"f4h2\":477,\"b2c1\":478,\"c4b2\":479,\"d4c6\":480,\"c3b5\":481,\"g6f8\":482,\"f7e6\":483,\"c7e5\":484,\"h6g4\":485,\"h5g7\":486,\"c8b6\":487,\"e4d5\":488,\"a1f6\":489,\"f2g1\":490,\"g7e6\":491,\"e3c3\":492,\"h6g7\":493,\"f1e3\":494,\"e4g3\":495,\"a6a8\":496,\"h5f3\":497,\"h6g5\":498,\"c3c2\":499,\"c2c3\":500,\"a4a3\":501,\"c5g5\":502,\"c5c8\":503,\"f1d2\":504,\"a7b5\":505,\"g3e2\":506,\"g8b3\":507,\"h4f5\":508,\"h1h4\":509,\"c3c5\":510,\"a6c4\":511,\"b1b6\":512,\"h7h8q\":513,\"e3b3\":514,\"h6f8\":515,\"e6g5\":516,\"f3d4\":517,\"c5d5\":518,\"b1d3\":519,\"d7c7\":520,\"c5b5\":521,\"a5h5\":522,\"f6h4\":523,\"a8a5\":524,\"f8f6\":525,\"f2f4\":526,\"h4e4\":527,\"g2g5\":528,\"a2f2\":529,\"f7f2\":530,\"d6h2\":531,\"c7c2\":532,\"e8d6\":533,\"h2f1\":534,\"h2d6\":535,\"d6c8\":536,\"d4g7\":537,\"f5f4\":538,\"g4c8\":539,\"d7d8q\":540,\"h3c3\":541,\"d1e3\":542,\"e8e6\":543,\"d2e3\":544,\"a4d4\":545,\"b7g7\":546,\"a3a4\":547,\"h7g5\":548,\"d8f6\":549,\"h5c5\":550,\"g7g8\":551,\"c1c6\":552,\"c7h7\":553,\"g2b2\":554,\"h4h3\":555,\"e4d2\":556,\"a1a4\":557,\"c4c8\":558,\"b6g1\":559,\"d3d7\":560,\"e6d6\":561,\"e4f2\":562,\"a4g4\":563,\"h2g2\":564,\"c5g1\":565,\"b1f1\":566,\"e8g7\":567,\"b4f8\":568,\"d2g2\":569,\"g2g4\":570,\"b2f6\":571,\"a7c7\":572,\"e6h6\":573,\"c4d6\":574,\"b8e5\":575,\"e2b2\":576,\"g5e7\":577,\"g3b8\":578,\"d3f4\":579,\"d1f2\":580,\"a6h6\":581,\"e3g3\":582,\"e5d5\":583,\"e6h3\":584,\"e4b1\":585,\"h8d8\":586,\"a8b8\":587,\"a6f6\":588,\"g6g8\":589,\"b7b8q\":590,\"b3a2\":591,\"e6e2\":592,\"d7e8q\":593,\"c1a1\":594,\"a2a7\":595,\"c2c1n\":596,\"f7f8n\":597,\"d4d3\":598,\"a4a8\":599,\"e7b4\":600,\"b1d1\":601,\"a4b3\":602,\"f2e1q\":603,\"c7g3\":604,\"f7e7\":605,\"e3e4\":606,\"b5g5\":607,\"e3h3\":608,\"e5c7\":609,\"b5a7\":610,\"g2e2\":611,\"d5e4\":612,\"d5b5\":613,\"d4a4\":614,\"f4d3\":615,\"d7f7\":616,\"b3b7\":617,\"e1h1\":618,\"f5f6\":619,\"e4e7\":620,\"h1g2\":621,\"e3e5\":622,\"b8a8\":623,\"a6c7\":624,\"c2a2\":625,\"c1f4\":626,\"e8a4\":627,\"g8a2\":628,\"d1d7\":629,\"c1c5\":630,\"f5e5\":631,\"c5c7\":632,\"g4g7\":633,\"a3a7\":634,\"c8g8\":635,\"e4e2\":636,\"f4e6\":637,\"d6b5\":638,\"c1e3\":639,\"h6h5\":640,\"h8b2\":641,\"b7a8\":642,\"d4f4\":643,\"c7c8q\":644,\"e7e4\":645,\"f6e4\":646,\"g7h8q\":647,\"a6b8\":648,\"a5a1\":649,\"d7e7\":650,\"e2e8\":651,\"d1d3\":652,\"d1e2\":653,\"f7f5\":654,\"b4b1\":655,\"e5g6\":656,\"a1a6\":657,\"a5c6\":658,\"f8g8\":659,\"d2d1\":660,\"h4f4\":661,\"d5c6\":662,\"a6a1\":663,\"d4d1\":664,\"c4d4\":665,\"b1c1\":666,\"a7c5\":667,\"d5c4\":668,\"c6c3\":669,\"g8g6\":670,\"e6c8\":671,\"g7g8q\":672,\"e2e7\":673,\"e6e7\":674,\"e8a8\":675,\"b4b7\":676,\"b5c4\":677,\"b8b6\":678,\"c5e6\":679,\"e8f7\":680,\"g6e6\":681,\"e6a2\":682,\"g3a3\":683,\"d4h8\":684,\"c3a2\":685,\"e3f1\":686,\"h5a5\":687,\"a6a2\":688,\"b5d6\":689,\"c8e7\":690,\"a7d7\":691,\"e8c8\":692,\"f2f6\":693,\"c5c4\":694,\"g8c4\":695,\"c1c8\":696,\"d7g7\":697,\"d4d2\":698,\"c6a7\":699,\"e2g1\":700,\"c3a1\":701,\"a2e2\":702,\"d7c5\":703,\"b5e8\":704,\"a4c2\":705,\"e8c6\":706,\"h5f5\":707,\"b7f7\":708,\"a7c8\":709,\"a5b5\":710,\"h4g4\":711,\"a5c4\":712,\"d8d1\":713,\"e2e6\":714,\"f1f3\":715,\"g2g1\":716,\"g8d8\":717,\"f4d4\":718,\"g3d3\":719,\"a7d4\":720,\"a1a5\":721,\"f2c5\":722,\"f1f6\":723,\"d4a1\":724,\"b2d1\":725,\"a7e7\":726,\"c4a4\":727,\"f1d1\":728,\"d6d1\":729,\"e7f8r\":730,\"a5a6\":731,\"a4d7\":732,\"e7e5\":733,\"f7e8\":734,\"g5h7\":735,\"b2a1n\":736,\"f3g2\":737,\"a7b7\":738,\"d7c8\":739,\"d6c4\":740,\"f8e7\":741,\"c7d8n\":742,\"f3h4\":743,\"e7g5\":744,\"f2c2\":745,\"h3h1\":746,\"d6c5\":747,\"d5d7\":748,\"a8a3\":749,\"f3f6\":750,\"g5h5\":751,\"d3b4\":752,\"b3a5\":753,\"b7b1\":754,\"d5e6\":755,\"f1b1\":756,\"h3h8\":757,\"c7d6\":758,\"c8c2\":759,\"c7c8\":760,\"f2f1\":761,\"g8h7\":762,\"b7d6\":763,\"c3a5\":764,\"g2f3\":765,\"h5h4\":766,\"g3e5\":767,\"g6g1\":768,\"e7f8q\":769,\"e3d3\":770,\"f7f6\":771,\"e1e8\":772,\"e3g4\":773,\"a1a3\":774,\"f8d7\":775,\"e7g8\":776,\"e2b5\":777,\"e7g7\":778,\"f5d6\":779,\"f1e1\":780,\"c7e8\":781,\"f6b6\":782,\"c1d2\":783,\"d8f7\":784,\"h5h7\":785,\"f2f8\":786,\"g6g5\":787,\"b3d2\":788,\"a3f8\":789,\"d3c1\":790,\"f3b7\":791,\"g4g1\":792,\"f6h8\":793,\"g7e5\":794,\"g6g7\":795,\"f5b5\":796,\"h3h5\":797,\"f8a8\":798,\"d7d1\":799,\"a2g8\":800,\"f3d5\":801,\"g4e5\":802,\"f6e7\":803,\"h4g6\":804,\"d6e5\":805,\"f5e7\":806,\"d3d6\":807,\"g5f5\":808,\"h7e7\":809,\"b7b8n\":810,\"c5d6\":811,\"b4a6\":812,\"d1h1\":813,\"h5f4\":814,\"b6c8\":815,\"c7c1\":816,\"b6c4\":817,\"g2a2\":818,\"h6g6\":819,\"c1c2\":820,\"b2a1\":821,\"e1d3\":822,\"f5f8\":823,\"h8a1\":824,\"g6h6\":825,\"b6b5\":826,\"a4c3\":827,\"g3f2\":828,\"b2b1b\":829,\"e4d3\":830,\"d6d5\":831,\"a3b3\":832,\"g6h7\":833,\"g6e7\":834,\"e5h8\":835,\"c3h8\":836,\"e1f2\":837,\"h3g3\":838,\"b6b4\":839,\"f8h7\":840,\"e2d1q\":841,\"d2d6\":842,\"a6e2\":843,\"b7a8q\":844,\"f5a5\":845,\"b7b5\":846,\"a7b8\":847,\"b7a7\":848,\"f6d7\":849,\"f2d3\":850,\"g4f2\":851,\"c5d3\":852,\"g4g3\":853,\"b7d7\":854,\"g4f4\":855,\"h4h1\":856,\"b2g7\":857,\"d7b8\":858,\"d2b3\":859,\"e3d5\":860,\"d1b3\":861,\"f4f7\":862,\"g4d7\":863,\"b2b8\":864,\"c7d7\":865,\"a6c6\":866,\"d6f6\":867,\"c1c4\":868,\"c5b6\":869,\"c3a3\":870,\"c4c3\":871,\"a2h2\":872,\"d5e3\":873,\"e2g4\":874,\"e2f1r\":875,\"d2f2\":876,\"e1b1\":877,\"c2g2\":878,\"a7a6\":879,\"b2b1n\":880,\"a7g7\":881,\"c4d2\":882,\"g5h4\":883,\"g3e4\":884,\"e5e4\":885,\"d8b6\":886,\"e5e2\":887,\"e7e8q\":888,\"c7b8q\":889,\"e4f3\":890,\"h4g5\":891,\"d4f6\":892,\"h1b1\":893,\"a7a8q\":894,\"f5d4\":895,\"h7e4\":896,\"h2h3\":897,\"g8e6\":898,\"g2g1b\":899,\"b3c1\":900,\"b5b2\":901,\"d6d8\":902,\"g8g7\":903,\"f5g6\":904,\"g4g2\":905,\"a4a2\":906,\"e6d7\":907,\"b7b3\":908,\"h2h7\":909,\"c8d6\":910,\"a3a8\":911,\"e8f6\":912,\"h6f6\":913,\"a5d8\":914,\"f3g4\":915,\"g2g6\":916,\"c6d5\":917,\"a4e4\":918,\"a1b2\":919,\"h5d1\":920,\"b5b6\":921,\"e5e6\":922,\"c2a3\":923,\"c4f4\":924,\"f7b7\":925,\"e1a1\":926,\"e3a3\":927,\"h5f6\":928,\"a7f2\":929,\"f3f2\":930,\"f5f1\":931,\"h8g8\":932,\"d3d5\":933,\"d4c4\":934,\"g1g3\":935,\"e5e1\":936,\"b3c5\":937,\"h5e2\":938,\"a3b2\":939,\"d3a6\":940,\"g5c5\":941,\"g1b6\":942,\"h4f3\":943,\"a3d3\":944,\"b2c1q\":945,\"f1g3\":946,\"a1c3\":947,\"c2b3\":948,\"d4f3\":949,\"d8c6\":950,\"e4f4\":951,\"d7d3\":952,\"f1b5\":953,\"f3e2\":954,\"a6d6\":955,\"b3c3\":956,\"h7g8\":957,\"a3b5\":958,\"g1g8\":959,\"h1e4\":960,\"d1a1\":961,\"g2h4\":962,\"h4h2\":963,\"h3h4\":964,\"f7a7\":965,\"d4e4\":966,\"d4c5\":967,\"d3c5\":968,\"e7d7\":969,\"e6a6\":970,\"g6f7\":971,\"b1g1\":972,\"d7g4\":973,\"g2e4\":974,\"c2b4\":975,\"f2a7\":976,\"f4h6\":977,\"a8e4\":978,\"e2d4\":979,\"g6a6\":980,\"d1g1\":981,\"c8g4\":982,\"e7c7\":983,\"e5b2\":984,\"h5g5\":985,\"h7g7\":986,\"f4e4\":987,\"b7c6\":988,\"h7f6\":989,\"c6h6\":990,\"d2c2\":991,\"c7c6\":992,\"g6b6\":993,\"f4c1\":994,\"c2a1\":995,\"g7d4\":996,\"c6d7\":997,\"e2c3\":998,\"b3f3\":999,\"h8b8\":1000,\"b8d6\":1001,\"d5g2\":1002,\"c5f8\":1003,\"f3c6\":1004,\"g5e5\":1005,\"g3g5\":1006,\"h4g2\":1007,\"b2h8\":1008,\"a5a4\":1009,\"f8h8\":1010,\"h7c7\":1011,\"d8b7\":1012,\"c1h6\":1013,\"d6d3\":1014,\"e5d7\":1015,\"b2f2\":1016,\"h7h8\":1017,\"b8a6\":1018,\"a7a8r\":1019,\"e7c6\":1020,\"f7b3\":1021,\"f5c5\":1022,\"f8a3\":1023,\"a2e6\":1024,\"h6h8\":1025,\"d8b8\":1026,\"f6e8\":1027,\"d4d6\":1028,\"e4d6\":1029,\"g5e4\":1030,\"h2h5\":1031,\"g6e5\":1032,\"g4f3\":1033,\"g2b7\":1034,\"h3g1\":1035,\"b3b5\":1036,\"e6f7\":1037,\"g3g1\":1038,\"a5d2\":1039,\"c3f3\":1040,\"f5h6\":1041,\"h6h4\":1042,\"h2h4\":1043,\"h8h2\":1044,\"g1g4\":1045,\"d8d5\":1046,\"g5e6\":1047,\"b3d1\":1048,\"a3d6\":1049,\"e6c4\":1050,\"b3c4\":1051,\"f7f1\":1052,\"f5d3\":1053,\"f8g7\":1054,\"d4h4\":1055,\"e6f4\":1056,\"b4d3\":1057,\"c1f1\":1058,\"c6c4\":1059,\"c5e7\":1060,\"e7e3\":1061,\"b1c2\":1062,\"f6f2\":1063,\"c6e7\":1064,\"g6d6\":1065,\"d6c7\":1066,\"d8d7\":1067,\"g7a1\":1068,\"f1g2\":1069,\"f1f5\":1070,\"g7g8b\":1071,\"c5e5\":1072,\"g7g8n\":1073,\"a5a7\":1074,\"e6e8\":1075,\"e5d3\":1076,\"h3h2\":1077,\"c8b8\":1078,\"h7h3\":1079,\"a8a1\":1080,\"g5f4\":1081,\"e3c1\":1082,\"h6d2\":1083,\"b6d7\":1084,\"d2d4\":1085,\"b3b2\":1086,\"b4h4\":1087,\"d8h8\":1088,\"b5e2\":1089,\"g2g3\":1090,\"e6g6\":1091,\"d3a3\":1092,\"d4d7\":1093,\"c1a3\":1094,\"d3e1\":1095,\"g2h1q\":1096,\"e2e1b\":1097,\"g7f8\":1098,\"e1f1\":1099,\"c7c4\":1100,\"g4h4\":1101,\"f3h3\":1102,\"f3a3\":1103,\"f1f2\":1104,\"c1d3\":1105,\"c6b4\":1106,\"g7g4\":1107,\"e3g1\":1108,\"g3g7\":1109,\"h1f1\":1110,\"b4f4\":1111,\"d4b4\":1112,\"f1e2\":1113,\"a8c6\":1114,\"h3d3\":1115,\"b3c2\":1116,\"f6d6\":1117,\"f4c4\":1118,\"d2d1q\":1119,\"d2d8\":1120,\"a2c1\":1121,\"e7e2\":1122,\"f7h8\":1123,\"c1b2\":1124,\"a8e8\":1125,\"b4a5\":1126,\"b3a1\":1127,\"b6e6\":1128,\"g7g1\":1129,\"h2f2\":1130,\"d5c5\":1131,\"e3g5\":1132,\"e7f7\":1133,\"a2a1n\":1134,\"c3f6\":1135,\"e3d1\":1136,\"e8e4\":1137,\"a5b3\":1138,\"g1g7\":1139,\"d7b7\":1140,\"h4c4\":1141,\"a8a6\":1142,\"b7c8q\":1143,\"h1h7\":1144,\"b5c7\":1145,\"c3d4\":1146,\"f1g1\":1147,\"b1a1\":1148,\"c4e5\":1149,\"a2a4\":1150,\"h7h8n\":1151,\"h2f4\":1152,\"g3c3\":1153,\"c3b3\":1154,\"e8d8\":1155,\"a4h4\":1156,\"g2f1q\":1157,\"c2b1q\":1158,\"e8h5\":1159,\"d7e8\":1160,\"f7e8q\":1161,\"a2a8\":1162,\"b1b5\":1163,\"c3g7\":1164,\"b8g8\":1165,\"a1g7\":1166,\"f2g2\":1167,\"h5d5\":1168,\"f8f3\":1169,\"b4b3\":1170,\"g2h3\":1171,\"c8c3\":1172,\"d8d6\":1173,\"e5h2\":1174,\"b6f2\":1175,\"f2h1\":1176,\"g7h6\":1177,\"c1h1\":1178,\"a3c5\":1179,\"f7f8\":1180,\"g7f6\":1181,\"f2f5\":1182,\"e7d5\":1183,\"g2g1q\":1184,\"d3d2\":1185,\"f6h7\":1186,\"b1e4\":1187,\"b8c7\":1188,\"a6a3\":1189,\"e2f4\":1190,\"f4b8\":1191,\"c5b3\":1192,\"c2e4\":1193,\"f3h1\":1194,\"e4g4\":1195,\"h3d7\":1196,\"d8c8\":1197,\"g1c1\":1198,\"g2h2\":1199,\"g5g2\":1200,\"f7e8n\":1201,\"c2e3\":1202,\"c5f2\":1203,\"a5b6\":1204,\"e7f8\":1205,\"g6g3\":1206,\"e6g7\":1207,\"a8a7\":1208,\"h3c8\":1209,\"d7a4\":1210,\"c4c1\":1211,\"d7a7\":1212,\"c3d1\":1213,\"c6d6\":1214,\"b2a3\":1215,\"d7d2\":1216,\"g7g2\":1217,\"e2g2\":1218,\"f6f5\":1219,\"a2b4\":1220,\"f2h4\":1221,\"d2b1\":1222,\"h6f5\":1223,\"e3c5\":1224,\"c2c4\":1225,\"a2b1q\":1226,\"d1b1\":1227,\"c4c2\":1228,\"c5a7\":1229,\"d4b6\":1230,\"g5h6\":1231,\"a3c3\":1232,\"a6a5\":1233,\"b6h6\":1234,\"c7d8\":1235,\"f4c7\":1236,\"b5a4\":1237,\"h6h1\":1238,\"b3e6\":1239,\"c8h8\":1240,\"f7c4\":1241,\"g5d5\":1242,\"g3g2\":1243,\"h6a6\":1244,\"c8b7\":1245,\"c6c7\":1246,\"c6h1\":1247,\"d8e7\":1248,\"a2a5\":1249,\"c8c1\":1250,\"g8f7\":1251,\"h5g3\":1252,\"f4e5\":1253,\"g5e3\":1254,\"d7f6\":1255,\"d5h1\":1256,\"g4g6\":1257,\"a8d8\":1258,\"h4h5\":1259,\"h8h4\":1260,\"f7g7\":1261,\"d3g3\":1262,\"h1h6\":1263,\"d7d5\":1264,\"b6g6\":1265,\"h8e8\":1266,\"g3f3\":1267,\"g4b4\":1268,\"c5c1\":1269,\"h7c2\":1270,\"e7f5\":1271,\"d4f5\":1272,\"e6g4\":1273,\"b2c4\":1274,\"g3b3\":1275,\"g4e6\":1276,\"g7e8\":1277,\"g8g2\":1278,\"d2c4\":1279,\"g2d5\":1280,\"a8h8\":1281,\"e7h7\":1282,\"e3b6\":1283,\"d2c3\":1284,\"f2a2\":1285,\"e7d8r\":1286,\"h3e3\":1287,\"e2e1q\":1288,\"f5g4\":1289,\"c3g3\":1290,\"h1b7\":1291,\"c5f5\":1292,\"b1h1\":1293,\"h7d7\":1294,\"e5d4\":1295,\"f8e6\":1296,\"c5a3\":1297,\"a3c1\":1298,\"c8a8\":1299,\"b4b2\":1300,\"f5h5\":1301,\"a4a5\":1302,\"d5b4\":1303,\"f2e1n\":1304,\"a1a2\":1305,\"e2c4\":1306,\"e1e4\":1307,\"f4f2\":1308,\"d6e8\":1309,\"d5g8\":1310,\"f6c3\":1311,\"f8f5\":1312,\"c3h3\":1313,\"a8a4\":1314,\"a6d3\":1315,\"h7a7\":1316,\"c3e1\":1317,\"g7g6\":1318,\"f7h5\":1319,\"b4c2\":1320,\"a5b7\":1321,\"c1e1\":1322,\"e7f8n\":1323,\"b2d4\":1324,\"f2e4\":1325,\"h8f7\":1326,\"b5f5\":1327,\"g7a7\":1328,\"c5c2\":1329,\"g4e3\":1330,\"b6d5\":1331,\"a8b7\":1332,\"g8g4\":1333,\"h8d4\":1334,\"a7f7\":1335,\"e6d5\":1336,\"b2c3\":1337,\"d2e2\":1338,\"e1g3\":1339,\"e8d7\":1340,\"f6h6\":1341,\"g8f6\":1342,\"c4d3\":1343,\"d7d4\":1344,\"f1a1\":1345,\"e5c3\":1346,\"h4g3\":1347,\"f3g5\":1348,\"c2h2\":1349,\"e4d4\":1350,\"e5a1\":1351,\"c3d2\":1352,\"c2e2\":1353,\"b2b1q\":1354,\"a1e1\":1355,\"a7e3\":1356,\"a5c3\":1357,\"b8b2\":1358,\"f6g7\":1359,\"d6d2\":1360,\"g4a4\":1361,\"h2h8\":1362,\"g2h1\":1363,\"d6g6\":1364,\"g7g5\":1365,\"e3e2\":1366,\"f4g6\":1367,\"d1c1\":1368,\"f7d7\":1369,\"a3c4\":1370,\"b2b6\":1371,\"d1c3\":1372,\"c4g4\":1373,\"b5e5\":1374,\"e7c8\":1375,\"e3e6\":1376,\"c6e5\":1377,\"e1a5\":1378,\"g4g5\":1379,\"b3f7\":1380,\"b8g3\":1381,\"e4b4\":1382,\"b7a6\":1383,\"d4b3\":1384,\"d1b2\":1385,\"a2b1\":1386,\"c8c7\":1387,\"d5e5\":1388,\"h4e1\":1389,\"a8c7\":1390,\"h3g2\":1391,\"f7f8q\":1392,\"e5d6\":1393,\"e1g2\":1394,\"f7g5\":1395,\"a5a8\":1396,\"g5f6\":1397,\"d2c1q\":1398,\"d3b3\":1399,\"g7f8q\":1400,\"f7a2\":1401,\"e1e3\":1402,\"f2f7\":1403,\"h6h2\":1404,\"f4h3\":1405,\"b8b4\":1406,\"b8d8\":1407,\"a1e5\":1408,\"g5g8\":1409,\"h1c6\":1410,\"b7f3\":1411,\"e3g2\":1412,\"c7b8\":1413,\"e4e3\":1414,\"c7d5\":1415,\"h4f6\":1416,\"c6f6\":1417,\"g8e8\":1418,\"b1e1\":1419,\"f4f1\":1420,\"a6c8\":1421,\"c6b6\":1422,\"d5a2\":1423,\"h1h2\":1424,\"b2e5\":1425,\"b6a4\":1426,\"d7d8n\":1427,\"h8e5\":1428,\"c4g8\":1429,\"f3g1\":1430,\"e3f3\":1431,\"c1c3\":1432,\"h2g1q\":1433,\"d8e8\":1434,\"a5g5\":1435,\"c3e2\":1436,\"f5g7\":1437,\"f3e1\":1438,\"g5d2\":1439,\"c1a2\":1440,\"a2d5\":1441,\"b3g3\":1442,\"a7a2\":1443,\"b2d2\":1444,\"f2d4\":1445,\"h2h6\":1446,\"f5g5\":1447,\"a7a8\":1448,\"d6e4\":1449,\"b3b4\":1450,\"c6c1\":1451,\"f6g5\":1452,\"f2b6\":1453,\"h3g5\":1454,\"g8a8\":1455,\"g7g3\":1456,\"f3h5\":1457,\"c5a6\":1458,\"b2b5\":1459,\"d7e6\":1460,\"e1c1\":1461,\"b3d5\":1462,\"e5c6\":1463,\"b1d2\":1464,\"b5d3\":1465,\"e2f1\":1466,\"f6g8\":1467,\"d5b6\":1468,\"e2d1r\":1469,\"f5f3\":1470,\"g6c2\":1471,\"f3f8\":1472,\"c5a4\":1473,\"d2d3\":1474,\"h5h3\":1475,\"b4c5\":1476,\"h7f5\":1477,\"b4e4\":1478,\"d7c8n\":1479,\"h6h7\":1480,\"b2b4\":1481,\"b6b8\":1482,\"c4b5\":1483,\"e5g7\":1484,\"f4a4\":1485,\"h7b1\":1486,\"f5h4\":1487,\"h3f2\":1488,\"d4g4\":1489,\"a8d5\":1490,\"b4d2\":1491,\"e8b8\":1492,\"a5c7\":1493,\"d2c1\":1494,\"g1f2\":1495,\"b4e1\":1496,\"h5f7\":1497,\"a8b6\":1498,\"e1g1\":1499,\"h1h5\":1500,\"e1c2\":1501,\"e8g8\":1502,\"c6b5\":1503,\"h3h7\":1504,\"e4c2\":1505,\"f6d4\":1506,\"f8d6\":1507,\"e8f8\":1508,\"d7h7\":1509,\"e2a2\":1510,\"e4h1\":1511,\"f4d6\":1512,\"g8h6\":1513,\"d4d5\":1514,\"f2f1n\":1515,\"h6c1\":1516,\"f5d5\":1517,\"d2d7\":1518,\"b4a2\":1519,\"c6g2\":1520,\"h2b8\":1521,\"d5c3\":1522,\"h5g6\":1523,\"h2g4\":1524,\"h2b2\":1525,\"g8f8\":1526,\"e2f2\":1527,\"d3e5\":1528,\"b6c5\":1529,\"a6f1\":1530,\"f6e5\":1531,\"b8e8\":1532,\"e1b4\":1533,\"h3b3\":1534,\"c3d5\":1535,\"f3h2\":1536,\"a2c4\":1537,\"h8g7\":1538,\"e7f6\":1539,\"g5d8\":1540,\"g5g4\":1541,\"g7h7\":1542,\"b7g2\":1543,\"d2e4\":1544,\"h7f7\":1545,\"e5a5\":1546,\"e3d2\":1547,\"g1e3\":1548,\"b1g6\":1549,\"f2d2\":1550,\"g2g1n\":1551,\"e2f3\":1552,\"h3f5\":1553,\"b3b8\":1554,\"b6e3\":1555,\"g4e2\":1556,\"c3b1\":1557,\"d6e6\":1558,\"b1b7\":1559,\"g7g8r\":1560,\"b4a3\":1561,\"f8c5\":1562,\"d5d6\":1563,\"c5b4\":1564,\"c8h3\":1565,\"d3d8\":1566,\"c8c4\":1567,\"g1b1\":1568,\"f2e1\":1569,\"h6h3\":1570,\"h4f2\":1571,\"f6f4\":1572,\"a2b2\":1573,\"g5g1\":1574,\"b5b7\":1575,\"h4d4\":1576,\"d6b8\":1577,\"g2g1r\":1578,\"e5f4\":1579,\"d7e8r\":1580,\"f3d1\":1581,\"c4f7\":1582,\"f5b1\":1583,\"g6e4\":1584,\"d4f2\":1585,\"f4d2\":1586,\"c1e2\":1587,\"f1c4\":1588,\"d7b5\":1589,\"d5a5\":1590,\"g4c4\":1591,\"g1g5\":1592,\"b2a1q\":1593,\"b5d4\":1594,\"f1a6\":1595,\"f7e8r\":1596,\"d2a2\":1597,\"g4h5\":1598,\"a5c5\":1599,\"a6c5\":1600,\"g1f1\":1601,\"a7b8q\":1602,\"d4b5\":1603,\"h7h2\":1604,\"h8f8\":1605,\"b4d4\":1606,\"g5g7\":1607,\"a6b7\":1608,\"a6b5\":1609,\"c2c8\":1610,\"e4a8\":1611,\"c3e4\":1612,\"b6d8\":1613,\"c2d4\":1614,\"d7b6\":1615,\"d8d4\":1616,\"f4h5\":1617,\"e7a7\":1618,\"e4e1\":1619,\"c7e6\":1620,\"c6e6\":1621,\"f3e5\":1622,\"g1h3\":1623,\"b2a2\":1624,\"e1e2\":1625,\"a3h3\":1626,\"a1a8\":1627,\"e8h8\":1628,\"c2h7\":1629,\"f1h1\":1630,\"f8e8\":1631,\"b4g4\":1632,\"g6f5\":1633,\"d6d7\":1634,\"c4c6\":1635,\"b6a8\":1636,\"d4b2\":1637,\"g6h5\":1638,\"d5f4\":1639,\"b5a5\":1640,\"f7h7\":1641,\"c7a6\":1642,\"e6c5\":1643,\"c2a4\":1644,\"c4a2\":1645,\"a2b3\":1646,\"g2d2\":1647,\"a2c2\":1648,\"g1e2\":1649,\"e4g5\":1650,\"c1b1\":1651,\"e7a3\":1652,\"f3c3\":1653,\"a1f1\":1654,\"b7c5\":1655,\"c7f4\":1656,\"f1c1\":1657,\"a7a1\":1658,\"e8e7\":1659,\"b8c6\":1660,\"a3e3\":1661,\"g3h3\":1662,\"a4b2\":1663,\"g7b7\":1664,\"c3c1\":1665,\"h6e3\":1666,\"b4e7\":1667,\"e1h4\":1668,\"e3f4\":1669,\"e7d8\":1670,\"b1b2\":1671,\"d1f1\":1672,\"b2g2\":1673,\"h7g8q\":1674,\"f2g3\":1675,\"d8d2\":1676,\"d2f1\":1677,\"a1b1\":1678,\"f5e6\":1679,\"e8g6\":1680,\"g5a5\":1681,\"f4d5\":1682,\"e2c1\":1683,\"e4f6\":1684,\"g5f3\":1685,\"c5c6\":1686,\"f6b2\":1687,\"h5h2\":1688,\"c4e3\":1689,\"g8d5\":1690,\"h7f8\":1691,\"f3g3\":1692,\"e8e1\":1693,\"g1c5\":1694,\"e6e1\":1695,\"d6d4\":1696,\"d3f3\":1697,\"d6f8\":1698,\"g1g2\":1699,\"f8f7\":1700,\"g3g6\":1701,\"d3f1\":1702,\"h6b6\":1703,\"c2d1\":1704,\"a2a6\":1705,\"c6c5\":1706,\"c6b7\":1707,\"b6c6\":1708,\"f2f3\":1709,\"c7f7\":1710,\"h3h6\":1711,\"d2g5\":1712,\"c6f3\":1713,\"b3a4\":1714,\"d5a8\":1715,\"b7b8\":1716,\"g8e7\":1717,\"b1h7\":1718,\"c2c1\":1719,\"a3e7\":1720,\"f6h5\":1721,\"g3c7\":1722,\"f2f1q\":1723,\"a6b4\":1724,\"d6g3\":1725,\"g3e3\":1726,\"a2a1q\":1727,\"g1d4\":1728,\"b7e4\":1729,\"e4f5\":1730,\"a2c3\":1731,\"d4d8\":1732,\"a8a2\":1733,\"h7d3\":1734,\"c5d4\":1735,\"g8g3\":1736,\"e4c5\":1737,\"f2b2\":1738,\"h7h4\":1739,\"h3f4\":1740,\"h6g8\":1741,\"b7d5\":1742,\"a3f3\":1743,\"g4h2\":1744,\"b6b3\":1745,\"b1b3\":1746,\"e2e1n\":1747,\"h8h3\":1748,\"a1c1\":1749,\"h8a8\":1750,\"c2d3\":1751,\"d3e4\":1752,\"a1d1\":1753,\"b2b3\":1754,\"d6b6\":1755,\"c4b3\":1756,\"c8c5\":1757,\"b2h2\":1758,\"e5f3\":1759,\"h2d2\":1760,\"b5c6\":1761,\"h1d5\":1762,\"e2e5\":1763,\"a4e8\":1764,\"c2g6\":1765,\"f6c6\":1766,\"f3f7\":1767,\"c7b6\":1768,\"e5e8\":1769,\"g6c6\":1770,\"b4c3\":1771,\"a4a7\":1772,\"d1e1\":1773,\"d1d5\":1774,\"e7h4\":1775,\"f7e5\":1776,\"f8f1\":1777,\"d8a5\":1778,\"d1g4\":1779,\"e4c4\":1780,\"b6a6\":1781,\"d1d6\":1782,\"c6g6\":1783,\"b8f4\":1784,\"b1a3\":1785,\"a4c4\":1786,\"e2f1q\":1787,\"b7b6\":1788,\"h5e5\":1789,\"f6g6\":1790,\"e6b6\":1791,\"h1f3\":1792,\"a6e6\":1793,\"e5c5\":1794,\"h1d1\":1795,\"f7d8\":1796,\"a3a6\":1797,\"a6b6\":1798,\"b3g8\":1799,\"d4e6\":1800,\"c4c7\":1801,\"c8e8\":1802,\"b4d6\":1803,\"g3h5\":1804,\"f5e4\":1805,\"a5d5\":1806,\"a4b6\":1807,\"g6g2\":1808,\"h6f4\":1809,\"e7d8q\":1810,\"g1h2\":1811,\"c4a3\":1812,\"c4a5\":1813,\"b7h7\":1814,\"f5c2\":1815,\"h1h3\":1816,\"d7e5\":1817,\"a3a5\":1818,\"b7b2\":1819,\"c6d4\":1820,\"d3e2\":1821,\"h6c6\":1822,\"b7c7\":1823,\"h8c3\":1824,\"b6b1\":1825,\"e2h5\":1826,\"d4c2\":1827,\"g3h4\":1828,\"e3f5\":1829,\"e1e5\":1830,\"c8a6\":1831,\"a7a3\":1832,\"b7c8\":1833,\"f3f5\":1834,\"c5b7\":1835,\"g3d6\":1836,\"c5e3\":1837,\"e1e7\":1838,\"b6f6\":1839,\"d1d4\":1840,\"h2f3\":1841,\"e4h4\":1842,\"a5f5\":1843,\"e7c5\":1844,\"d5g5\":1845,\"f4h4\":1846,\"d3d1\":1847,\"d1f3\":1848,\"e6c7\":1849,\"g3h2\":1850,\"d2f3\":1851,\"a5e1\":1852,\"f1h2\":1853,\"e4a4\":1854,\"d1h5\":1855,\"g6g4\":1856,\"a4f4\":1857,\"g7f5\":1858,\"b5h5\":1859,\"d3b2\":1860,\"h1g3\":1861,\"b1f5\":1862,\"f1h3\":1863,\"e5f5\":1864,\"h8h5\":1865,\"d3h3\":1866,\"f2g1q\":1867,\"f5h7\":1868,\"e4g6\":1869}');\n\n//# sourceURL=webpack://chess-bot-online/./models/heavy_move_to_int_imot.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;