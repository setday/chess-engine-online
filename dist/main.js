/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/chess.js/dist/esm/chess.js":
/*!*************************************************!*\
  !*** ./node_modules/chess.js/dist/esm/chess.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BISHOP: () => (/* binding */ BISHOP),\n/* harmony export */   BLACK: () => (/* binding */ BLACK),\n/* harmony export */   Chess: () => (/* binding */ Chess),\n/* harmony export */   DEFAULT_POSITION: () => (/* binding */ DEFAULT_POSITION),\n/* harmony export */   KING: () => (/* binding */ KING),\n/* harmony export */   KNIGHT: () => (/* binding */ KNIGHT),\n/* harmony export */   PAWN: () => (/* binding */ PAWN),\n/* harmony export */   QUEEN: () => (/* binding */ QUEEN),\n/* harmony export */   ROOK: () => (/* binding */ ROOK),\n/* harmony export */   SQUARES: () => (/* binding */ SQUARES),\n/* harmony export */   WHITE: () => (/* binding */ WHITE),\n/* harmony export */   validateFen: () => (/* binding */ validateFen)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\nconst WHITE = 'w';\nconst BLACK = 'b';\nconst PAWN = 'p';\nconst KNIGHT = 'n';\nconst BISHOP = 'b';\nconst ROOK = 'r';\nconst QUEEN = 'q';\nconst KING = 'k';\nconst DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nconst EMPTY = -1;\nconst FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q',\n};\n// prettier-ignore\nconst SQUARES = [\n    'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n    'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n    'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n    'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n    'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n    'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n    'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n    'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n];\nconst BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64,\n};\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88 = {\n    a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\n    a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\n    a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\n    a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\n    a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\n    a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\n    a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n};\nconst PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15],\n};\nconst PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1],\n};\n// prettier-ignore\nconst ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\n];\n// prettier-ignore\nconst RAYS = [\n    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\n    0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\n    0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\n    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\n    0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\n    1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\n    0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\n    0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\n    0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\n    0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\n    -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\n];\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 };\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [KNIGHT, BISHOP, ROOK, QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst SIDES = {\n    [KING]: BITS.KSIDE_CASTLE,\n    [QUEEN]: BITS.QSIDE_CASTLE,\n};\nconst ROOKS = {\n    w: [\n        { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n    ],\n    b: [\n        { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n    ],\n};\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 };\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square) {\n    return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square) {\n    return square & 0xf;\n}\nfunction isDigit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square) {\n    const f = file(square);\n    const r = rank(square);\n    return ('abcdefgh'.substring(f, f + 1) +\n        '87654321'.substring(r, r + 1));\n}\nfunction swapColor(color) {\n    return color === WHITE ? BLACK : WHITE;\n}\nfunction validateFen(fen) {\n    // 1st criterion: 6 space-seperated fields?\n    const tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: must contain six space-delimited fields',\n        };\n    }\n    // 2nd criterion: move number field is a integer value > 0?\n    const moveNumber = parseInt(tokens[5], 10);\n    if (isNaN(moveNumber) || moveNumber <= 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: move number must be a positive integer',\n        };\n    }\n    // 3rd criterion: half move counter is an integer >= 0?\n    const halfMoves = parseInt(tokens[4], 10);\n    if (isNaN(halfMoves) || halfMoves < 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: half move counter number must be a non-negative integer',\n        };\n    }\n    // 4th criterion: 4th field is a valid e.p.-string?\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n        return { ok: false, error: 'Invalid FEN: en-passant square is invalid' };\n    }\n    // 5th criterion: 3th field is a valid castle-string?\n    if (/[^kKqQ-]/.test(tokens[2])) {\n        return { ok: false, error: 'Invalid FEN: castling availability is invalid' };\n    }\n    // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n    if (!/^(w|b)$/.test(tokens[1])) {\n        return { ok: false, error: 'Invalid FEN: side-to-move is invalid' };\n    }\n    // 7th criterion: 1st field contains 8 rows?\n    const rows = tokens[0].split('/');\n    if (rows.length !== 8) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n        };\n    }\n    // 8th criterion: every row is valid?\n    for (let i = 0; i < rows.length; i++) {\n        // check for right sum of fields AND not two numbers in succession\n        let sumFields = 0;\n        let previousWasNumber = false;\n        for (let k = 0; k < rows[i].length; k++) {\n            if (isDigit(rows[i][k])) {\n                if (previousWasNumber) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (consecutive number)',\n                    };\n                }\n                sumFields += parseInt(rows[i][k], 10);\n                previousWasNumber = true;\n            }\n            else {\n                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (invalid piece)',\n                    };\n                }\n                sumFields += 1;\n                previousWasNumber = false;\n            }\n        }\n        if (sumFields !== 8) {\n            return {\n                ok: false,\n                error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n            };\n        }\n    }\n    // 9th criterion: is en-passant square legal?\n    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||\n        (tokens[3][1] == '6' && tokens[1] == 'b')) {\n        return { ok: false, error: 'Invalid FEN: illegal en-passant square' };\n    }\n    // 10th criterion: does chess position contain exact two kings?\n    const kings = [\n        { color: 'white', regex: /K/g },\n        { color: 'black', regex: /k/g },\n    ];\n    for (const { color, regex } of kings) {\n        if (!regex.test(tokens[0])) {\n            return { ok: false, error: `Invalid FEN: missing ${color} king` };\n        }\n        if ((tokens[0].match(regex) || []).length > 1) {\n            return { ok: false, error: `Invalid FEN: too many ${color} kings` };\n        }\n    }\n    // 11th criterion: are any pawns on the first or eighth rows?\n    if (Array.from(rows[0] + rows[7]).some((char) => char.toUpperCase() === 'P')) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: some pawns are on the edge rows',\n        };\n    }\n    return { ok: true };\n}\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move, moves) {\n    const from = move.from;\n    const to = move.to;\n    const piece = move.piece;\n    let ambiguities = 0;\n    let sameRank = 0;\n    let sameFile = 0;\n    for (let i = 0, len = moves.length; i < len; i++) {\n        const ambigFrom = moves[i].from;\n        const ambigTo = moves[i].to;\n        const ambigPiece = moves[i].piece;\n        /*\n         * if a move of the same piece type ends on the same to square, we'll need\n         * to add a disambiguator to the algebraic notation\n         */\n        if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n            ambiguities++;\n            if (rank(from) === rank(ambigFrom)) {\n                sameRank++;\n            }\n            if (file(from) === file(ambigFrom)) {\n                sameFile++;\n            }\n        }\n    }\n    if (ambiguities > 0) {\n        if (sameRank > 0 && sameFile > 0) {\n            /*\n             * if there exists a similar moving piece on the same rank and file as\n             * the move in question, use the square as the disambiguator\n             */\n            return algebraic(from);\n        }\n        else if (sameFile > 0) {\n            /*\n             * if the moving piece rests on the same file, use the rank symbol as the\n             * disambiguator\n             */\n            return algebraic(from).charAt(1);\n        }\n        else {\n            // else use the file symbol\n            return algebraic(from).charAt(0);\n        }\n    }\n    return '';\n}\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\n    const r = rank(to);\n    if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n        for (let i = 0; i < PROMOTIONS.length; i++) {\n            const promotion = PROMOTIONS[i];\n            moves.push({\n                color,\n                from,\n                to,\n                piece,\n                captured,\n                promotion,\n                flags: flags | BITS.PROMOTION,\n            });\n        }\n    }\n    else {\n        moves.push({\n            color,\n            from,\n            to,\n            piece,\n            captured,\n            flags,\n        });\n    }\n}\nfunction inferPieceType(san) {\n    let pieceType = san.charAt(0);\n    if (pieceType >= 'a' && pieceType <= 'h') {\n        const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n        if (matches) {\n            return undefined;\n        }\n        return PAWN;\n    }\n    pieceType = pieceType.toLowerCase();\n    if (pieceType === 'o') {\n        return KING;\n    }\n    return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nfunction trimFen(fen) {\n    /*\n     * remove last two fields in FEN string as they're not needed when checking\n     * for repetition\n     */\n    return fen.split(' ').slice(0, 4).join(' ');\n}\nclass Chess {\n    _board = new Array(128);\n    _turn = WHITE;\n    _header = {};\n    _kings = { w: EMPTY, b: EMPTY };\n    _epSquare = -1;\n    _halfMoves = 0;\n    _moveNumber = 0;\n    _history = [];\n    _comments = {};\n    _castling = { w: 0, b: 0 };\n    // tracks number of times a position has been seen for repetition checking\n    _positionCount = {};\n    constructor(fen = DEFAULT_POSITION) {\n        this.load(fen);\n    }\n    clear({ preserveHeaders = false } = {}) {\n        this._board = new Array(128);\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._turn = WHITE;\n        this._castling = { w: 0, b: 0 };\n        this._epSquare = EMPTY;\n        this._halfMoves = 0;\n        this._moveNumber = 1;\n        this._history = [];\n        this._comments = {};\n        this._header = preserveHeaders ? this._header : {};\n        this._positionCount = {};\n        /*\n         * Delete the SetUp and FEN headers (if preserved), the board is empty and\n         * these headers don't make sense in this state. They'll get added later\n         * via .load() or .put()\n         */\n        delete this._header['SetUp'];\n        delete this._header['FEN'];\n    }\n    removeHeader(key) {\n        if (key in this._header) {\n            delete this._header[key];\n        }\n    }\n    load(fen, { skipValidation = false, preserveHeaders = false } = {}) {\n        let tokens = fen.split(/\\s+/);\n        // append commonly omitted fen tokens\n        if (tokens.length >= 2 && tokens.length < 6) {\n            const adjustments = ['-', '-', '0', '1'];\n            fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\n        }\n        tokens = fen.split(/\\s+/);\n        if (!skipValidation) {\n            const { ok, error } = validateFen(fen);\n            if (!ok) {\n                throw new Error(error);\n            }\n        }\n        const position = tokens[0];\n        let square = 0;\n        this.clear({ preserveHeaders });\n        for (let i = 0; i < position.length; i++) {\n            const piece = position.charAt(i);\n            if (piece === '/') {\n                square += 8;\n            }\n            else if (isDigit(piece)) {\n                square += parseInt(piece, 10);\n            }\n            else {\n                const color = piece < 'a' ? WHITE : BLACK;\n                this._put({ type: piece.toLowerCase(), color }, algebraic(square));\n                square++;\n            }\n        }\n        this._turn = tokens[1];\n        if (tokens[2].indexOf('K') > -1) {\n            this._castling.w |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('Q') > -1) {\n            this._castling.w |= BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('k') > -1) {\n            this._castling.b |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('q') > -1) {\n            this._castling.b |= BITS.QSIDE_CASTLE;\n        }\n        this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n        this._halfMoves = parseInt(tokens[4], 10);\n        this._moveNumber = parseInt(tokens[5], 10);\n        this._updateSetup(fen);\n        this._incPositionCount(fen);\n    }\n    fen() {\n        let empty = 0;\n        let fen = '';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i]) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const { color, type: piece } = this._board[i];\n                fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n            }\n            else {\n                empty++;\n            }\n            if ((i + 1) & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n                if (i !== Ox88.h1) {\n                    fen += '/';\n                }\n                empty = 0;\n                i += 8;\n            }\n        }\n        let castling = '';\n        if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n            castling += 'K';\n        }\n        if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n            castling += 'Q';\n        }\n        if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n            castling += 'k';\n        }\n        if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n            castling += 'q';\n        }\n        // do we have an empty castling flag?\n        castling = castling || '-';\n        let epSquare = '-';\n        /*\n         * only print the ep square if en passant is a valid move (pawn is present\n         * and ep capture is not pinned)\n         */\n        if (this._epSquare !== EMPTY) {\n            const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n            const squares = [bigPawnSquare + 1, bigPawnSquare - 1];\n            for (const square of squares) {\n                // is the square off the board?\n                if (square & 0x88) {\n                    continue;\n                }\n                const color = this._turn;\n                // is there a pawn that can capture the epSquare?\n                if (this._board[square]?.color === color &&\n                    this._board[square]?.type === PAWN) {\n                    // if the pawn makes an ep capture, does it leave it's king in check?\n                    this._makeMove({\n                        color,\n                        from: square,\n                        to: this._epSquare,\n                        piece: PAWN,\n                        captured: PAWN,\n                        flags: BITS.EP_CAPTURE,\n                    });\n                    const isLegal = !this._isKingAttacked(color);\n                    this._undoMove();\n                    // if ep is legal, break and set the ep square in the FEN output\n                    if (isLegal) {\n                        epSquare = algebraic(this._epSquare);\n                        break;\n                    }\n                }\n            }\n        }\n        return [\n            fen,\n            this._turn,\n            castling,\n            epSquare,\n            this._halfMoves,\n            this._moveNumber,\n        ].join(' ');\n    }\n    /*\n     * Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object. If the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been made.\n     */\n    _updateSetup(fen) {\n        if (this._history.length > 0)\n            return;\n        if (fen !== DEFAULT_POSITION) {\n            this._header['SetUp'] = '1';\n            this._header['FEN'] = fen;\n        }\n        else {\n            delete this._header['SetUp'];\n            delete this._header['FEN'];\n        }\n    }\n    reset() {\n        this.load(DEFAULT_POSITION);\n    }\n    get(square) {\n        return this._board[Ox88[square]] || false;\n    }\n    put({ type, color }, square) {\n        if (this._put({ type, color }, square)) {\n            this._updateCastlingRights();\n            this._updateEnPassantSquare();\n            this._updateSetup(this.fen());\n            return true;\n        }\n        return false;\n    }\n    _put({ type, color }, square) {\n        // check for piece\n        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n            return false;\n        }\n        // check for valid square\n        if (!(square in Ox88)) {\n            return false;\n        }\n        const sq = Ox88[square];\n        // don't let the user place more than one king\n        if (type == KING &&\n            !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n            return false;\n        }\n        const currentPieceOnSquare = this._board[sq];\n        // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\n        if (currentPieceOnSquare && currentPieceOnSquare.type === KING) {\n            this._kings[currentPieceOnSquare.color] = EMPTY;\n        }\n        this._board[sq] = { type: type, color: color };\n        if (type === KING) {\n            this._kings[color] = sq;\n        }\n        return true;\n    }\n    remove(square) {\n        const piece = this.get(square);\n        delete this._board[Ox88[square]];\n        if (piece && piece.type === KING) {\n            this._kings[piece.color] = EMPTY;\n        }\n        this._updateCastlingRights();\n        this._updateEnPassantSquare();\n        this._updateSetup(this.fen());\n        return piece;\n    }\n    _updateCastlingRights() {\n        const whiteKingInPlace = this._board[Ox88.e1]?.type === KING &&\n            this._board[Ox88.e1]?.color === WHITE;\n        const blackKingInPlace = this._board[Ox88.e8]?.type === KING &&\n            this._board[Ox88.e8]?.color === BLACK;\n        if (!whiteKingInPlace ||\n            this._board[Ox88.a1]?.type !== ROOK ||\n            this._board[Ox88.a1]?.color !== WHITE) {\n            this._castling.w &= ~BITS.QSIDE_CASTLE;\n        }\n        if (!whiteKingInPlace ||\n            this._board[Ox88.h1]?.type !== ROOK ||\n            this._board[Ox88.h1]?.color !== WHITE) {\n            this._castling.w &= ~BITS.KSIDE_CASTLE;\n        }\n        if (!blackKingInPlace ||\n            this._board[Ox88.a8]?.type !== ROOK ||\n            this._board[Ox88.a8]?.color !== BLACK) {\n            this._castling.b &= ~BITS.QSIDE_CASTLE;\n        }\n        if (!blackKingInPlace ||\n            this._board[Ox88.h8]?.type !== ROOK ||\n            this._board[Ox88.h8]?.color !== BLACK) {\n            this._castling.b &= ~BITS.KSIDE_CASTLE;\n        }\n    }\n    _updateEnPassantSquare() {\n        if (this._epSquare === EMPTY) {\n            return;\n        }\n        const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16);\n        const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n        const attackers = [currentSquare + 1, currentSquare - 1];\n        if (this._board[startSquare] !== null ||\n            this._board[this._epSquare] !== null ||\n            this._board[currentSquare]?.color !== swapColor(this._turn) ||\n            this._board[currentSquare]?.type !== PAWN) {\n            this._epSquare = EMPTY;\n            return;\n        }\n        const canCapture = (square) => !(square & 0x88) &&\n            this._board[square]?.color === this._turn &&\n            this._board[square]?.type === PAWN;\n        if (!attackers.some(canCapture)) {\n            this._epSquare = EMPTY;\n        }\n    }\n    _attacked(color, square) {\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            // if empty square or wrong color\n            if (this._board[i] === undefined || this._board[i].color !== color) {\n                continue;\n            }\n            const piece = this._board[i];\n            const difference = i - square;\n            // skip - to/from square are the same\n            if (difference === 0) {\n                continue;\n            }\n            const index = difference + 119;\n            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n                if (piece.type === PAWN) {\n                    if (difference > 0) {\n                        if (piece.color === WHITE)\n                            return true;\n                    }\n                    else {\n                        if (piece.color === BLACK)\n                            return true;\n                    }\n                    continue;\n                }\n                // if the piece is a knight or a king\n                if (piece.type === 'n' || piece.type === 'k')\n                    return true;\n                const offset = RAYS[index];\n                let j = i + offset;\n                let blocked = false;\n                while (j !== square) {\n                    if (this._board[j] != null) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked)\n                    return true;\n            }\n        }\n        return false;\n    }\n    _isKingAttacked(color) {\n        const square = this._kings[color];\n        return square === -1 ? false : this._attacked(swapColor(color), square);\n    }\n    isAttacked(square, attackedBy) {\n        return this._attacked(attackedBy, Ox88[square]);\n    }\n    isCheck() {\n        return this._isKingAttacked(this._turn);\n    }\n    inCheck() {\n        return this.isCheck();\n    }\n    isCheckmate() {\n        return this.isCheck() && this._moves().length === 0;\n    }\n    isStalemate() {\n        return !this.isCheck() && this._moves().length === 0;\n    }\n    isInsufficientMaterial() {\n        /*\n         * k.b. vs k.b. (of opposite colors) with mate in 1:\n         * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n         *\n         * k.b. vs k.n. with mate in 1:\n         * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n         */\n        const pieces = {\n            b: 0,\n            n: 0,\n            r: 0,\n            q: 0,\n            k: 0,\n            p: 0,\n        };\n        const bishops = [];\n        let numPieces = 0;\n        let squareColor = 0;\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            squareColor = (squareColor + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            const piece = this._board[i];\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n                if (piece.type === BISHOP) {\n                    bishops.push(squareColor);\n                }\n                numPieces++;\n            }\n        }\n        // k vs. k\n        if (numPieces === 2) {\n            return true;\n        }\n        else if (\n        // k vs. kn .... or .... k vs. kb\n        numPieces === 3 &&\n            (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n            return true;\n        }\n        else if (numPieces === pieces[BISHOP] + 2) {\n            // kb vs. kb where any number of bishops are all on the same color\n            let sum = 0;\n            const len = bishops.length;\n            for (let i = 0; i < len; i++) {\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isThreefoldRepetition() {\n        return this._getPositionCount(this.fen()) >= 3;\n    }\n    isDraw() {\n        return (this._halfMoves >= 100 || // 50 moves per side = 100 half moves\n            this.isStalemate() ||\n            this.isInsufficientMaterial() ||\n            this.isThreefoldRepetition());\n    }\n    isGameOver() {\n        return this.isCheckmate() || this.isStalemate() || this.isDraw();\n    }\n    moves({ verbose = false, square = undefined, piece = undefined, } = {}) {\n        const moves = this._moves({ square, piece });\n        if (verbose) {\n            return moves.map((move) => this._makePretty(move));\n        }\n        else {\n            return moves.map((move) => this._moveToSan(move, moves));\n        }\n    }\n    _moves({ legal = true, piece = undefined, square = undefined, } = {}) {\n        const forSquare = square ? square.toLowerCase() : undefined;\n        const forPiece = piece?.toLowerCase();\n        const moves = [];\n        const us = this._turn;\n        const them = swapColor(us);\n        let firstSquare = Ox88.a8;\n        let lastSquare = Ox88.h1;\n        let singleSquare = false;\n        // are we generating moves for a single square?\n        if (forSquare) {\n            // illegal square, return empty moves\n            if (!(forSquare in Ox88)) {\n                return [];\n            }\n            else {\n                firstSquare = lastSquare = Ox88[forSquare];\n                singleSquare = true;\n            }\n        }\n        for (let from = firstSquare; from <= lastSquare; from++) {\n            // did we run off the end of the board\n            if (from & 0x88) {\n                from += 7;\n                continue;\n            }\n            // empty square or opponent, skip\n            if (!this._board[from] || this._board[from].color === them) {\n                continue;\n            }\n            const { type } = this._board[from];\n            let to;\n            if (type === PAWN) {\n                if (forPiece && forPiece !== type)\n                    continue;\n                // single square, non-capturing\n                to = from + PAWN_OFFSETS[us][0];\n                if (!this._board[to]) {\n                    addMove(moves, us, from, to, PAWN);\n                    // double square\n                    to = from + PAWN_OFFSETS[us][1];\n                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n                        addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN);\n                    }\n                }\n                // pawn captures\n                for (let j = 2; j < 4; j++) {\n                    to = from + PAWN_OFFSETS[us][j];\n                    if (to & 0x88)\n                        continue;\n                    if (this._board[to]?.color === them) {\n                        addMove(moves, us, from, to, PAWN, this._board[to].type, BITS.CAPTURE);\n                    }\n                    else if (to === this._epSquare) {\n                        addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE);\n                    }\n                }\n            }\n            else {\n                if (forPiece && forPiece !== type)\n                    continue;\n                for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n                    const offset = PIECE_OFFSETS[type][j];\n                    to = from;\n                    while (true) {\n                        to += offset;\n                        if (to & 0x88)\n                            break;\n                        if (!this._board[to]) {\n                            addMove(moves, us, from, to, type);\n                        }\n                        else {\n                            // own color, stop loop\n                            if (this._board[to].color === us)\n                                break;\n                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n                            break;\n                        }\n                        /* break, if knight or king */\n                        if (type === KNIGHT || type === KING)\n                            break;\n                    }\n                }\n            }\n        }\n        /*\n         * check for castling if we're:\n         *   a) generating all moves, or\n         *   b) doing single square move generation on the king's square\n         */\n        if (forPiece === undefined || forPiece === KING) {\n            if (!singleSquare || lastSquare === this._kings[us]) {\n                // king-side castling\n                if (this._castling[us] & BITS.KSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom + 2;\n                    if (!this._board[castlingFrom + 1] &&\n                        !this._board[castlingTo] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom + 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.KSIDE_CASTLE);\n                    }\n                }\n                // queen-side castling\n                if (this._castling[us] & BITS.QSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom - 2;\n                    if (!this._board[castlingFrom - 1] &&\n                        !this._board[castlingFrom - 2] &&\n                        !this._board[castlingFrom - 3] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom - 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.QSIDE_CASTLE);\n                    }\n                }\n            }\n        }\n        /*\n         * return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured)\n         */\n        if (!legal || this._kings[us] === -1) {\n            return moves;\n        }\n        // filter out illegal moves\n        const legalMoves = [];\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(us)) {\n                legalMoves.push(moves[i]);\n            }\n            this._undoMove();\n        }\n        return legalMoves;\n    }\n    move(move, { strict = false } = {}) {\n        /*\n         * The move function can be called with in the following parameters:\n         *\n         * .move('Nxb7')       <- argument is a case-sensitive SAN string\n         *\n         * .move({ from: 'h7', <- argument is a move object\n         *         to :'h8',\n         *         promotion: 'q' })\n         *\n         *\n         * An optional strict argument may be supplied to tell chess.js to\n         * strictly follow the SAN specification.\n         */\n        let moveObj = null;\n        if (typeof move === 'string') {\n            moveObj = this._moveFromSan(move, strict);\n        }\n        else if (typeof move === 'object') {\n            const moves = this._moves();\n            // convert the pretty move object to an ugly move object\n            for (let i = 0, len = moves.length; i < len; i++) {\n                if (move.from === algebraic(moves[i].from) &&\n                    move.to === algebraic(moves[i].to) &&\n                    (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n                    moveObj = moves[i];\n                    break;\n                }\n            }\n        }\n        // failed to find move\n        if (!moveObj) {\n            if (typeof move === 'string') {\n                throw new Error(`Invalid move: ${move}`);\n            }\n            else {\n                throw new Error(`Invalid move: ${JSON.stringify(move)}`);\n            }\n        }\n        /*\n         * need to make a copy of move because we can't generate SAN after the move\n         * is made\n         */\n        const prettyMove = this._makePretty(moveObj);\n        this._makeMove(moveObj);\n        this._incPositionCount(prettyMove.after);\n        return prettyMove;\n    }\n    _push(move) {\n        this._history.push({\n            move,\n            kings: { b: this._kings.b, w: this._kings.w },\n            turn: this._turn,\n            castling: { b: this._castling.b, w: this._castling.w },\n            epSquare: this._epSquare,\n            halfMoves: this._halfMoves,\n            moveNumber: this._moveNumber,\n        });\n    }\n    _makeMove(move) {\n        const us = this._turn;\n        const them = swapColor(us);\n        this._push(move);\n        this._board[move.to] = this._board[move.from];\n        delete this._board[move.from];\n        // if ep capture, remove the captured pawn\n        if (move.flags & BITS.EP_CAPTURE) {\n            if (this._turn === BLACK) {\n                delete this._board[move.to - 16];\n            }\n            else {\n                delete this._board[move.to + 16];\n            }\n        }\n        // if pawn promotion, replace with new piece\n        if (move.promotion) {\n            this._board[move.to] = { type: move.promotion, color: us };\n        }\n        // if we moved the king\n        if (this._board[move.to].type === KING) {\n            this._kings[us] = move.to;\n            // if we castled, move the rook next to the king\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                const castlingTo = move.to - 1;\n                const castlingFrom = move.to + 1;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            else if (move.flags & BITS.QSIDE_CASTLE) {\n                const castlingTo = move.to + 1;\n                const castlingFrom = move.to - 2;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            // turn off castling\n            this._castling[us] = 0;\n        }\n        // turn off castling if we move a rook\n        if (this._castling[us]) {\n            for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n                if (move.from === ROOKS[us][i].square &&\n                    this._castling[us] & ROOKS[us][i].flag) {\n                    this._castling[us] ^= ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n        // turn off castling if we capture a rook\n        if (this._castling[them]) {\n            for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n                if (move.to === ROOKS[them][i].square &&\n                    this._castling[them] & ROOKS[them][i].flag) {\n                    this._castling[them] ^= ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n        // if big pawn move, update the en passant square\n        if (move.flags & BITS.BIG_PAWN) {\n            if (us === BLACK) {\n                this._epSquare = move.to - 16;\n            }\n            else {\n                this._epSquare = move.to + 16;\n            }\n        }\n        else {\n            this._epSquare = EMPTY;\n        }\n        // reset the 50 move counter if a pawn is moved or a piece is captured\n        if (move.piece === PAWN) {\n            this._halfMoves = 0;\n        }\n        else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n            this._halfMoves = 0;\n        }\n        else {\n            this._halfMoves++;\n        }\n        if (us === BLACK) {\n            this._moveNumber++;\n        }\n        this._turn = them;\n    }\n    undo() {\n        const move = this._undoMove();\n        if (move) {\n            const prettyMove = this._makePretty(move);\n            this._decPositionCount(prettyMove.after);\n            return prettyMove;\n        }\n        return null;\n    }\n    _undoMove() {\n        const old = this._history.pop();\n        if (old === undefined) {\n            return null;\n        }\n        const move = old.move;\n        this._kings = old.kings;\n        this._turn = old.turn;\n        this._castling = old.castling;\n        this._epSquare = old.epSquare;\n        this._halfMoves = old.halfMoves;\n        this._moveNumber = old.moveNumber;\n        const us = this._turn;\n        const them = swapColor(us);\n        this._board[move.from] = this._board[move.to];\n        this._board[move.from].type = move.piece; // to undo any promotions\n        delete this._board[move.to];\n        if (move.captured) {\n            if (move.flags & BITS.EP_CAPTURE) {\n                // en passant capture\n                let index;\n                if (us === BLACK) {\n                    index = move.to - 16;\n                }\n                else {\n                    index = move.to + 16;\n                }\n                this._board[index] = { type: PAWN, color: them };\n            }\n            else {\n                // regular capture\n                this._board[move.to] = { type: move.captured, color: them };\n            }\n        }\n        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n            let castlingTo, castlingFrom;\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                castlingTo = move.to + 1;\n                castlingFrom = move.to - 1;\n            }\n            else {\n                castlingTo = move.to - 2;\n                castlingFrom = move.to + 1;\n            }\n            this._board[castlingTo] = this._board[castlingFrom];\n            delete this._board[castlingFrom];\n        }\n        return move;\n    }\n    pgn({ newline = '\\n', maxWidth = 0, } = {}) {\n        /*\n         * using the specification from http://www.chessclub.com/help/PGN-spec\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n         */\n        const result = [];\n        let headerExists = false;\n        /* add the PGN header information */\n        for (const i in this._header) {\n            /*\n             * TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             */\n            result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline);\n            headerExists = true;\n        }\n        if (headerExists && this._history.length) {\n            result.push(newline);\n        }\n        const appendComment = (moveString) => {\n            const comment = this._comments[this.fen()];\n            if (typeof comment !== 'undefined') {\n                const delimiter = moveString.length > 0 ? ' ' : '';\n                moveString = `${moveString}${delimiter}{${comment}}`;\n            }\n            return moveString;\n        };\n        // pop all of history onto reversed_history\n        const reversedHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        const moves = [];\n        let moveString = '';\n        // special case of a commented starting position with no moves\n        if (reversedHistory.length === 0) {\n            moves.push(appendComment(''));\n        }\n        // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n        while (reversedHistory.length > 0) {\n            moveString = appendComment(moveString);\n            const move = reversedHistory.pop();\n            // make TypeScript stop complaining about move being undefined\n            if (!move) {\n                break;\n            }\n            // if the position started with black to move, start PGN with #. ...\n            if (!this._history.length && move.color === 'b') {\n                const prefix = `${this._moveNumber}. ...`;\n                // is there a comment preceding the first move?\n                moveString = moveString ? `${moveString} ${prefix}` : prefix;\n            }\n            else if (move.color === 'w') {\n                // store the previous generated move_string if we have one\n                if (moveString.length) {\n                    moves.push(moveString);\n                }\n                moveString = this._moveNumber + '.';\n            }\n            moveString =\n                moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }));\n            this._makeMove(move);\n        }\n        // are there any other leftover moves?\n        if (moveString.length) {\n            moves.push(appendComment(moveString));\n        }\n        // is there a result?\n        if (typeof this._header.Result !== 'undefined') {\n            moves.push(this._header.Result);\n        }\n        /*\n         * history should be back to what it was before we started generating PGN,\n         * so join together moves\n         */\n        if (maxWidth === 0) {\n            return result.join('') + moves.join(' ');\n        }\n        // TODO (jah): huh?\n        const strip = function () {\n            if (result.length > 0 && result[result.length - 1] === ' ') {\n                result.pop();\n                return true;\n            }\n            return false;\n        };\n        // NB: this does not preserve comment whitespace.\n        const wrapComment = function (width, move) {\n            for (const token of move.split(' ')) {\n                if (!token) {\n                    continue;\n                }\n                if (width + token.length > maxWidth) {\n                    while (strip()) {\n                        width--;\n                    }\n                    result.push(newline);\n                    width = 0;\n                }\n                result.push(token);\n                width += token.length;\n                result.push(' ');\n                width++;\n            }\n            if (strip()) {\n                width--;\n            }\n            return width;\n        };\n        // wrap the PGN output at max_width\n        let currentWidth = 0;\n        for (let i = 0; i < moves.length; i++) {\n            if (currentWidth + moves[i].length > maxWidth) {\n                if (moves[i].includes('{')) {\n                    currentWidth = wrapComment(currentWidth, moves[i]);\n                    continue;\n                }\n            }\n            // if the current move will push past max_width\n            if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n                // don't end the line with whitespace\n                if (result[result.length - 1] === ' ') {\n                    result.pop();\n                }\n                result.push(newline);\n                currentWidth = 0;\n            }\n            else if (i !== 0) {\n                result.push(' ');\n                currentWidth++;\n            }\n            result.push(moves[i]);\n            currentWidth += moves[i].length;\n        }\n        return result.join('');\n    }\n    header(...args) {\n        for (let i = 0; i < args.length; i += 2) {\n            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n                this._header[args[i]] = args[i + 1];\n            }\n        }\n        return this._header;\n    }\n    loadPgn(pgn, { strict = false, newlineChar = '\\r?\\n', } = {}) {\n        function mask(str) {\n            return str.replace(/\\\\/g, '\\\\');\n        }\n        function parsePgnHeader(header) {\n            const headerObj = {};\n            const headers = header.split(new RegExp(mask(newlineChar)));\n            let key = '';\n            let value = '';\n            for (let i = 0; i < headers.length; i++) {\n                const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n                key = headers[i].replace(regex, '$1');\n                value = headers[i].replace(regex, '$2');\n                if (key.trim().length > 0) {\n                    headerObj[key] = value;\n                }\n            }\n            return headerObj;\n        }\n        // strip whitespace from head/tail of PGN block\n        pgn = pgn.trim();\n        /*\n         * RegExp to split header. Takes advantage of the fact that header and movetext\n         * will always have a blank line between them (ie, two newline_char's). Handles\n         * case where movetext is empty by matching newlineChar until end of string is\n         * matched - effectively trimming from the end extra newlineChar.\n         *\n         * With default newline_char, will equal:\n         * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n         */\n        const headerRegex = new RegExp('^(\\\\[((?:' +\n            mask(newlineChar) +\n            ')|.)*\\\\])' +\n            '((?:\\\\s*' +\n            mask(newlineChar) +\n            '){2}|(?:\\\\s*' +\n            mask(newlineChar) +\n            ')*$)');\n        // If no header given, begin with moves.\n        const headerRegexResults = headerRegex.exec(pgn);\n        const headerString = headerRegexResults\n            ? headerRegexResults.length >= 2\n                ? headerRegexResults[1]\n                : ''\n            : '';\n        // Put the board in the starting position\n        this.reset();\n        // parse PGN header\n        const headers = parsePgnHeader(headerString);\n        let fen = '';\n        for (const key in headers) {\n            // check to see user is including fen (possibly with wrong tag case)\n            if (key.toLowerCase() === 'fen') {\n                fen = headers[key];\n            }\n            this.header(key, headers[key]);\n        }\n        /*\n         * the permissive parser should attempt to load a fen tag, even if it's the\n         * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n         */\n        if (!strict) {\n            if (fen) {\n                this.load(fen, { preserveHeaders: true });\n            }\n        }\n        else {\n            /*\n             * strict parser - load the starting position indicated by [Setup '1']\n             * and [FEN position]\n             */\n            if (headers['SetUp'] === '1') {\n                if (!('FEN' in headers)) {\n                    throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\n                }\n                // don't clear the headers when loading\n                this.load(headers['FEN'], { preserveHeaders: true });\n            }\n        }\n        /*\n         * NB: the regexes below that delete move numbers, recursive annotations,\n         * and numeric annotation glyphs may also match text in comments. To\n         * prevent this, we transform comments by hex-encoding them in place and\n         * decoding them again after the other tokens have been deleted.\n         *\n         * While the spec states that PGN files should be ASCII encoded, we use\n         * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n         * for modern users\n         */\n        function toHex(s) {\n            return Array.from(s)\n                .map(function (c) {\n                /*\n                 * encodeURI doesn't transform most ASCII characters, so we handle\n                 * these ourselves\n                 */\n                return c.charCodeAt(0) < 128\n                    ? c.charCodeAt(0).toString(16)\n                    : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n            })\n                .join('');\n        }\n        function fromHex(s) {\n            return s.length == 0\n                ? ''\n                : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n        }\n        const encodeComment = function (s) {\n            s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n            return `{${toHex(s.slice(1, s.length - 1))}}`;\n        };\n        const decodeComment = function (s) {\n            if (s.startsWith('{') && s.endsWith('}')) {\n                return fromHex(s.slice(1, s.length - 1));\n            }\n        };\n        // delete header to get the moves\n        let ms = pgn\n            .replace(headerString, '')\n            .replace(\n        // encode comments so they don't get deleted below\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function (_match, bracket, semicolon) {\n            return bracket !== undefined\n                ? encodeComment(bracket)\n                : ' ' + encodeComment(`{${semicolon.slice(1)}}`);\n        })\n            .replace(new RegExp(mask(newlineChar), 'g'), ' ');\n        // delete recursive annotation variations\n        const ravRegex = /(\\([^()]+\\))+?/g;\n        while (ravRegex.test(ms)) {\n            ms = ms.replace(ravRegex, '');\n        }\n        // delete move numbers\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n        // delete ... indicating black to move\n        ms = ms.replace(/\\.\\.\\./g, '');\n        /* delete numeric annotation glyphs */\n        ms = ms.replace(/\\$\\d+/g, '');\n        // trim and get array of moves\n        let moves = ms.trim().split(new RegExp(/\\s+/));\n        // delete empty entries\n        moves = moves.filter((move) => move !== '');\n        let result = '';\n        for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n            const comment = decodeComment(moves[halfMove]);\n            if (comment !== undefined) {\n                this._comments[this.fen()] = comment;\n                continue;\n            }\n            const move = this._moveFromSan(moves[halfMove], strict);\n            // invalid move\n            if (move == null) {\n                // was the move an end of game marker\n                if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n                    result = moves[halfMove];\n                }\n                else {\n                    throw new Error(`Invalid move in PGN: ${moves[halfMove]}`);\n                }\n            }\n            else {\n                // reset the end of game marker if making a valid move\n                result = '';\n                this._makeMove(move);\n                this._incPositionCount(this.fen());\n            }\n        }\n        /*\n         * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n         * the termination marker. Only do this when headers are present, but the\n         * result tag is missing\n         */\n        if (result && Object.keys(this._header).length && !this._header['Result']) {\n            this.header('Result', result);\n        }\n    }\n    /*\n     * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} strict Use the strict SAN parser. It will throw errors\n     * on overly disambiguated moves (see below):\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */\n    _moveToSan(move, moves) {\n        let output = '';\n        if (move.flags & BITS.KSIDE_CASTLE) {\n            output = 'O-O';\n        }\n        else if (move.flags & BITS.QSIDE_CASTLE) {\n            output = 'O-O-O';\n        }\n        else {\n            if (move.piece !== PAWN) {\n                const disambiguator = getDisambiguator(move, moves);\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n                if (move.piece === PAWN) {\n                    output += algebraic(move.from)[0];\n                }\n                output += 'x';\n            }\n            output += algebraic(move.to);\n            if (move.promotion) {\n                output += '=' + move.promotion.toUpperCase();\n            }\n        }\n        this._makeMove(move);\n        if (this.isCheck()) {\n            if (this.isCheckmate()) {\n                output += '#';\n            }\n            else {\n                output += '+';\n            }\n        }\n        this._undoMove();\n        return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    _moveFromSan(move, strict = false) {\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\n        const cleanMove = strippedSan(move);\n        let pieceType = inferPieceType(cleanMove);\n        let moves = this._moves({ legal: true, piece: pieceType });\n        // strict parser\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n                return moves[i];\n            }\n        }\n        // the strict parser failed\n        if (strict) {\n            return null;\n        }\n        let piece = undefined;\n        let matches = undefined;\n        let from = undefined;\n        let to = undefined;\n        let promotion = undefined;\n        /*\n         * The default permissive (non-strict) parser allows the user to parse\n         * non-standard chess notations. This parser is only run after the strict\n         * Standard Algebraic Notation (SAN) parser has failed.\n         *\n         * When running the permissive parser, we'll run a regex to grab the piece, the\n         * to/from square, and an optional promotion piece. This regex will\n         * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n         * f7f8q, b1c3\n         *\n         * NOTE: Some positions and moves may be ambiguous when using the permissive\n         * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n         * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n         * move). In these cases, the permissive parser will default to the most\n         * basic interpretation (which is b1c3 parsing to Nc3).\n         */\n        let overlyDisambiguated = false;\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n        if (matches) {\n            piece = matches[1];\n            from = matches[2];\n            to = matches[3];\n            promotion = matches[4];\n            if (from.length == 1) {\n                overlyDisambiguated = true;\n            }\n        }\n        else {\n            /*\n             * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n             * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n             * there is one legal knight move to e7). In this case, the value of\n             * 'from' variable will be a rank or file, not a square.\n             */\n            matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n                if (from.length == 1) {\n                    overlyDisambiguated = true;\n                }\n            }\n        }\n        pieceType = inferPieceType(cleanMove);\n        moves = this._moves({\n            legal: true,\n            piece: piece ? piece : pieceType,\n        });\n        if (!to) {\n            return null;\n        }\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (!from) {\n                // if there is no from square, it could be just 'x' missing from a capture\n                if (cleanMove ===\n                    strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')) {\n                    return moves[i];\n                }\n                // hand-compare move properties with the results from our permissive regex\n            }\n            else if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                Ox88[from] == moves[i].from &&\n                Ox88[to] == moves[i].to &&\n                (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                return moves[i];\n            }\n            else if (overlyDisambiguated) {\n                /*\n                 * SPECIAL CASE: we parsed a move string that may have an unneeded\n                 * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n                 */\n                const square = algebraic(moves[i].from);\n                if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                    Ox88[to] == moves[i].to &&\n                    (from == square[0] || from == square[1]) &&\n                    (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                    return moves[i];\n                }\n            }\n        }\n        return null;\n    }\n    ascii() {\n        let s = '   +------------------------+\\n';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // display the rank\n            if (file(i) === 0) {\n                s += ' ' + '87654321'[rank(i)] + ' |';\n            }\n            if (this._board[i]) {\n                const piece = this._board[i].type;\n                const color = this._board[i].color;\n                const symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n                s += ' ' + symbol + ' ';\n            }\n            else {\n                s += ' . ';\n            }\n            if ((i + 1) & 0x88) {\n                s += '|\\n';\n                i += 8;\n            }\n        }\n        s += '   +------------------------+\\n';\n        s += '     a  b  c  d  e  f  g  h';\n        return s;\n    }\n    perft(depth) {\n        const moves = this._moves({ legal: false });\n        let nodes = 0;\n        const color = this._turn;\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(color)) {\n                if (depth - 1 > 0) {\n                    nodes += this.perft(depth - 1);\n                }\n                else {\n                    nodes++;\n                }\n            }\n            this._undoMove();\n        }\n        return nodes;\n    }\n    // pretty = external move object\n    _makePretty(uglyMove) {\n        const { color, piece, from, to, flags, captured, promotion } = uglyMove;\n        let prettyFlags = '';\n        for (const flag in BITS) {\n            if (BITS[flag] & flags) {\n                prettyFlags += FLAGS[flag];\n            }\n        }\n        const fromAlgebraic = algebraic(from);\n        const toAlgebraic = algebraic(to);\n        const move = {\n            color,\n            piece,\n            from: fromAlgebraic,\n            to: toAlgebraic,\n            san: this._moveToSan(uglyMove, this._moves({ legal: true })),\n            flags: prettyFlags,\n            lan: fromAlgebraic + toAlgebraic,\n            before: this.fen(),\n            after: '',\n        };\n        // generate the FEN for the 'after' key\n        this._makeMove(uglyMove);\n        move.after = this.fen();\n        this._undoMove();\n        if (captured) {\n            move.captured = captured;\n        }\n        if (promotion) {\n            move.promotion = promotion;\n            move.lan += promotion;\n        }\n        return move;\n    }\n    turn() {\n        return this._turn;\n    }\n    board() {\n        const output = [];\n        let row = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i] == null) {\n                row.push(null);\n            }\n            else {\n                row.push({\n                    square: algebraic(i),\n                    type: this._board[i].type,\n                    color: this._board[i].color,\n                });\n            }\n            if ((i + 1) & 0x88) {\n                output.push(row);\n                row = [];\n                i += 8;\n            }\n        }\n        return output;\n    }\n    squareColor(square) {\n        if (square in Ox88) {\n            const sq = Ox88[square];\n            return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n        }\n        return null;\n    }\n    history({ verbose = false } = {}) {\n        const reversedHistory = [];\n        const moveHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            if (verbose) {\n                moveHistory.push(this._makePretty(move));\n            }\n            else {\n                moveHistory.push(this._moveToSan(move, this._moves()));\n            }\n            this._makeMove(move);\n        }\n        return moveHistory;\n    }\n    /*\n     * Keeps track of position occurrence counts for the purpose of repetition\n     * checking. All three methods (`_inc`, `_dec`, and `_get`) trim the\n     * irrelevent information from the fen, initialising new positions, and\n     * removing old positions from the record if their counts are reduced to 0.\n     */\n    _getPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        return this._positionCount[trimmedFen] || 0;\n    }\n    _incPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        if (this._positionCount[trimmedFen] === undefined) {\n            this._positionCount[trimmedFen] = 0;\n        }\n        this._positionCount[trimmedFen] += 1;\n    }\n    _decPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        if (this._positionCount[trimmedFen] === 1) {\n            delete this._positionCount[trimmedFen];\n        }\n        else {\n            this._positionCount[trimmedFen] -= 1;\n        }\n    }\n    _pruneComments() {\n        const reversedHistory = [];\n        const currentComments = {};\n        const copyComment = (fen) => {\n            if (fen in this._comments) {\n                currentComments[fen] = this._comments[fen];\n            }\n        };\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        copyComment(this.fen());\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            this._makeMove(move);\n            copyComment(this.fen());\n        }\n        this._comments = currentComments;\n    }\n    getComment() {\n        return this._comments[this.fen()];\n    }\n    setComment(comment) {\n        this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n    }\n    deleteComment() {\n        const comment = this._comments[this.fen()];\n        delete this._comments[this.fen()];\n        return comment;\n    }\n    getComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            return { fen: fen, comment: this._comments[fen] };\n        });\n    }\n    deleteComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            const comment = this._comments[fen];\n            delete this._comments[fen];\n            return { fen: fen, comment: comment };\n        });\n    }\n    setCastlingRights(color, rights) {\n        for (const side of [KING, QUEEN]) {\n            if (rights[side] !== undefined) {\n                if (rights[side]) {\n                    this._castling[color] |= SIDES[side];\n                }\n                else {\n                    this._castling[color] &= ~SIDES[side];\n                }\n            }\n        }\n        this._updateCastlingRights();\n        const result = this.getCastlingRights(color);\n        return ((rights[KING] === undefined || rights[KING] === result[KING]) &&\n            (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN]));\n    }\n    getCastlingRights(color) {\n        return {\n            [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n            [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0,\n        };\n    }\n    moveNumber() {\n        return this._moveNumber;\n    }\n}\n//# sourceMappingURL=chess.js.map\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/chess.js/dist/esm/chess.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var chess_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chess.js */ \"./node_modules/chess.js/dist/esm/chess.js\");\n/* harmony import */ var cm_chessboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cm-chessboard */ \"./node_modules/cm-chessboard/src/Chessboard.js\");\n/* harmony import */ var cm_chessboard_src_extensions_markers_Markers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cm-chessboard/src/extensions/markers/Markers */ \"./node_modules/cm-chessboard/src/extensions/markers/Markers.js\");\n/* harmony import */ var cm_chessboard_src_extensions_promotion_dialog_PromotionDialog__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cm-chessboard/src/extensions/promotion-dialog/PromotionDialog */ \"./node_modules/cm-chessboard/src/extensions/promotion-dialog/PromotionDialog.js\");\n/* harmony import */ var cm_chessboard_src_extensions_arrows_Arrows__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cm-chessboard/src/extensions/arrows/Arrows */ \"./node_modules/cm-chessboard/src/extensions/arrows/Arrows.js\");\n/* harmony import */ var _nn_functions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./nn_functions */ \"./src/nn_functions.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst modelLoadingSpan = document.getElementById(\"modelLoading\");\r\n\r\nlet model = null\r\nmodelLoadingSpan.classList.toggle(\"hidden\", false);\r\n_nn_functions__WEBPACK_IMPORTED_MODULE_5__.loadModel(\"./../models/TORCH_100EPOCHS.onnx\").then(m => {\r\n  console.log(\"Model loaded\");\r\n  model = m;\r\n  modelLoadingSpan.classList.toggle(\"hidden\", true);\r\n});\r\n\r\nlet autoPlay = false;\r\n\r\nvar chess = new chess_js__WEBPACK_IMPORTED_MODULE_0__.Chess()\r\nconst board = new cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.Chessboard(document.getElementById(\"board\"), {\r\n  position: chess.fen(),\r\n  assetsUrl: \"./assets/\",\r\n  style: {borderType: cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.BORDER_TYPE.none, pieces: {file: \"pieces/standard.svg\"}, animationDuration: 300},\r\n  orientation: cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.COLOR.white,\r\n  extensions: [\r\n      {class: cm_chessboard_src_extensions_markers_Markers__WEBPACK_IMPORTED_MODULE_2__.Markers, props: {autoMarkers: cm_chessboard_src_extensions_markers_Markers__WEBPACK_IMPORTED_MODULE_2__.MARKER_TYPE.square}},\r\n      {class: cm_chessboard_src_extensions_promotion_dialog_PromotionDialog__WEBPACK_IMPORTED_MODULE_3__.PromotionDialog},\r\n      {class: cm_chessboard_src_extensions_arrows_Arrows__WEBPACK_IMPORTED_MODULE_4__.Arrows },\r\n  ]\r\n});\r\n\r\nconst changeOrientationButton = document.getElementById(\"flipBoardButton\");\r\nchangeOrientationButton.addEventListener(\"click\", () => {\r\n  board.setOrientation(board.getOrientation() === cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.COLOR.white ? cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.COLOR.black : cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.COLOR.white);\r\n  setTimeout(_ => {\r\n    flipTurn();\r\n  }, 300);\r\n});\r\n\r\nconst autoPlayButton = document.getElementById(\"autoPlayButton\");\r\nautoPlayButton.addEventListener(\"click\", () => {\r\n  autoPlay = !autoPlay;\r\n  flipTurn();\r\n});\r\n\r\nconst overlay = document.getElementById(\"overlay\");\r\nconst gameOverText = document.getElementById(\"gameOverText\");\r\nconst gameCodeButton = document.getElementById(\"gameCode\");\r\nconst restartButton = document.getElementById(\"restartButton\");\r\n\r\nrestartButton.addEventListener(\"click\", () => {\r\n  chess.reset();\r\n  board.setPosition(chess.fen(), true);\r\n  overlay.classList.toggle(\"hidden\", true);\r\n  flipTurn();\r\n});\r\n\r\ngameCodeButton.addEventListener(\"click\", () => {\r\n  navigator.clipboard.writeText(chess.pgn() + \" *\").then(() => {\r\n    alert(\"Game code copied to clipboard!\");\r\n  });\r\n});\r\n\r\nfunction make_move(move) {\r\n  chess.move(move);\r\n  board.setPosition(chess.fen(), true);\r\n\r\n  setTimeout(_ => {\r\n    flipTurn();\r\n  }, 100);\r\n}\r\n\r\nasync function makeEngineMove(chessboard) {\r\n  const possibleMoves = chess.moves({verbose: true});\r\n  const possibleMovesLan = possibleMoves.map((move) => move.lan);\r\n\r\n  if (possibleMoves.length > 0) {\r\n    while (model === null) {\r\n      await new Promise(resolve => setTimeout(resolve, 1000));\r\n    }\r\n\r\n    const prediction = await _nn_functions__WEBPACK_IMPORTED_MODULE_5__.predictMoves(chess, model);\r\n    const predictionPossible = prediction.filter(move => possibleMovesLan.includes(move));\r\n    if (predictionPossible.length > 0) {\r\n      make_move(predictionPossible[0]);\r\n    } else {\r\n      console.log(\"Bot can't make move so it will make a random move\");\r\n      make_move(possibleMoves[Math.floor(Math.random() * possibleMoves.length)]);\r\n    }\r\n  }\r\n}\r\n\r\nfunction flipTurn() {\r\n  // check if the game is over\r\n  if (chess.isCheckmate()) {\r\n    gameOverText.innerText = chess.turn() === board.getOrientation() ? \"You got checkmated!\" : \"You checkmated the opponent!\";\r\n    overlay.classList.toggle(\"hidden\", false);\r\n    return;\r\n  }\r\n  if (chess.isDraw()) {\r\n    chess.loadPgn(chess.pgn() + \" 1/2-1/2\");\r\n    gameOverText.innerText = \"It's a draw!\";\r\n    overlay.classList.toggle(\"hidden\", false);\r\n    return;\r\n  }\r\n\r\n  if (chess.turn() === board.getOrientation() && !autoPlay) {\r\n    board.enableMoveInput(inputHandler, board.getOrientation());\r\n  } else {\r\n    board.disableMoveInput();\r\n    makeEngineMove(board);\r\n  }\r\n}\r\n\r\nfunction inputHandler(event) {\r\n  if(event.type === cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.INPUT_EVENT_TYPE.movingOverSquare) {\r\n    return\r\n  }\r\n\r\n  if(event.type !== cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.INPUT_EVENT_TYPE.moveInputFinished) {\r\n    event.chessboard.removeLegalMovesMarkers();\r\n  }\r\n  if (event.type === cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.INPUT_EVENT_TYPE.moveInputStarted) {\r\n    const moves = chess.moves({square: event.squareFrom, verbose: true});\r\n    event.chessboard.addLegalMovesMarkers(moves);\r\n    return moves.length > 0;\r\n  }\r\n  if (event.type === cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.INPUT_EVENT_TYPE.moveInputFinished) {\r\n    if(event.legalMove) {\r\n      event.chessboard.disableMoveInput();\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (event.type === cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.INPUT_EVENT_TYPE.validateMoveInput) {\r\n    const move = {from: event.squareFrom, to: event.squareTo, promotion: event.promotion};\r\n    let result = false;\r\n\r\n    try {\r\n      result = chess.move(move);\r\n\r\n      event.chessboard.state.moveInputProcess.then(() => {\r\n        event.chessboard.setPosition(chess.fen(), true).then(() => {\r\n          flipTurn();\r\n        })\r\n      })\r\n    } catch (e) {\r\n      let possibleMoves = chess.moves({square: event.squareFrom, verbose: true});\r\n\r\n      for (const possibleMove of possibleMoves) {\r\n        if (!possibleMove.promotion || possibleMove.to !== event.squareTo) {\r\n          continue;\r\n        }\r\n\r\n        event.chessboard.showPromotionDialog(event.squareTo, cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.COLOR.white, (result) => {\r\n          if (result.type === cm_chessboard_src_extensions_promotion_dialog_PromotionDialog__WEBPACK_IMPORTED_MODULE_3__.PROMOTION_DIALOG_RESULT_TYPE.pieceSelected) {\r\n            const move = {from: event.squareFrom, to: event.squareTo, promotion: result.piece.charAt(1)};\r\n              \r\n            make_move(move);\r\n          } else {\r\n            event.chessboard.enableMoveInput(inputHandler, event.chessboard.getOrientation());\r\n            event.chessboard.setPosition(chess.fen(), true);\r\n          }\r\n        });\r\n\r\n        return true;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\nboard.enableMoveInput(inputHandler, cm_chessboard__WEBPACK_IMPORTED_MODULE_1__.COLOR.white);\r\n\n\n//# sourceURL=webpack://chess-bot-online/./src/index.js?");

/***/ }),

/***/ "./src/nn_functions.js":
/*!*****************************!*\
  !*** ./src/nn_functions.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadModel: () => (/* binding */ loadModel),\n/* harmony export */   predictMoves: () => (/* binding */ predictMoves)\n/* harmony export */ });\n/* harmony import */ var _models_heavy_move_to_int_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/heavy_move_to_int.json */ \"./models/heavy_move_to_int.json\");\n// import * as ort from 'onnxruntime-web';\r\n\r\n\r\n\r\nasync function loadModel(path) {\r\n    const session = new onnx.InferenceSession();\r\n    await session.loadModel(path);\r\n    return session;\r\n}\r\n\r\nfunction str2Pos(str) {\r\n    return [str[1] - 1, str.charCodeAt(0) - 97];\r\n}\r\n\r\nfunction board2Matrix(board, legalMoves) {\r\n    let matrix = new Array(13).fill([]).map(() =>\r\n        new Array(8).fill([]).map(() =>\r\n            new Array(8).fill(0.0)\r\n        )\r\n    );\r\n\r\n    for (const row of board) {\r\n        for (const cell of row) {\r\n            if (cell === null) {\r\n                continue;\r\n            }\r\n\r\n            const { type, color, square } = cell;\r\n            const [row, col] = str2Pos(square);\r\n            const piece_type = ['p', 'n', 'b', 'r', 'q', 'k'].indexOf(type);\r\n            const piece_color = ['w', 'b'].indexOf(color) * 6;\r\n    \r\n            matrix[piece_type + piece_color][row][col] = 1.0;    \r\n        }\r\n    }\r\n\r\n    for (const move of legalMoves) {\r\n        const { to } = move;\r\n        const [row, col] = str2Pos(to);\r\n        matrix[12][row][col] = 1.0;\r\n    }\r\n\r\n    return matrix;\r\n}\r\n\r\nlet indexes_to_move = null;\r\n\r\nfunction initializeIndexesToMove() {\r\n    indexes_to_move = {};\r\n\r\n    for (const move in _models_heavy_move_to_int_json__WEBPACK_IMPORTED_MODULE_0__) {\r\n        indexes_to_move[_models_heavy_move_to_int_json__WEBPACK_IMPORTED_MODULE_0__[move]] = move;\r\n    }\r\n}\r\n\r\nasync function predictMoves(game, model) {\r\n    const board = game.board();\r\n    const legalMoves = game.moves({ verbose: true });\r\n    const matrix = board2Matrix(board, legalMoves);\r\n    const tensor = new onnx.Tensor(matrix.flat(2), 'float32', [1, 13, 8, 8]);\r\n\r\n    // Make the prediction\r\n    const prediction = await model.run([tensor]);\r\n    \r\n    // Unpack the propabilities of the moves\r\n    const moveProps = prediction.values().next().value.data;\r\n    const movePropsD = Array.from(moveProps);\r\n    \r\n    // Apply softmax to the propabilities\r\n    const softmax = movePropsD.map((x) => Math.exp(x));\r\n    const sum = softmax.reduce((a, b) => a + b, 0);\r\n    const softmaxed = softmax.map((x) => x / sum);\r\n\r\n    if (!indexes_to_move) {\r\n        initializeIndexesToMove();\r\n    }\r\n\r\n    // Sort the indexes of the moves by the propabilities\r\n    const sortedMoves = softmaxed\r\n        .map((x, i) => [x, i])\r\n        .sort((a, b) => b[0] - a[0])\r\n        .map((x) => indexes_to_move[x[1]]);\r\n\r\n    return sortedMoves;\r\n}\r\n\n\n//# sourceURL=webpack://chess-bot-online/./src/nn_functions.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/Chessboard.js":
/*!******************************************************!*\
  !*** ./node_modules/cm-chessboard/src/Chessboard.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BORDER_TYPE: () => (/* reexport safe */ _view_ChessboardView_js__WEBPACK_IMPORTED_MODULE_4__.BORDER_TYPE),\n/* harmony export */   COLOR: () => (/* reexport safe */ _view_ChessboardView_js__WEBPACK_IMPORTED_MODULE_4__.COLOR),\n/* harmony export */   Chessboard: () => (/* binding */ Chessboard),\n/* harmony export */   FEN: () => (/* reexport safe */ _model_Position_js__WEBPACK_IMPORTED_MODULE_1__.FEN),\n/* harmony export */   INPUT_EVENT_TYPE: () => (/* reexport safe */ _view_ChessboardView_js__WEBPACK_IMPORTED_MODULE_4__.INPUT_EVENT_TYPE),\n/* harmony export */   PIECE: () => (/* binding */ PIECE),\n/* harmony export */   PIECES_FILE_TYPE: () => (/* binding */ PIECES_FILE_TYPE),\n/* harmony export */   PIECE_TYPE: () => (/* binding */ PIECE_TYPE),\n/* harmony export */   POINTER_EVENTS: () => (/* reexport safe */ _view_ChessboardView_js__WEBPACK_IMPORTED_MODULE_4__.POINTER_EVENTS)\n/* harmony export */ });\n/* harmony import */ var _model_ChessboardState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model/ChessboardState.js */ \"./node_modules/cm-chessboard/src/model/ChessboardState.js\");\n/* harmony import */ var _model_Position_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model/Position.js */ \"./node_modules/cm-chessboard/src/model/Position.js\");\n/* harmony import */ var _view_PositionAnimationsQueue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./view/PositionAnimationsQueue.js */ \"./node_modules/cm-chessboard/src/view/PositionAnimationsQueue.js\");\n/* harmony import */ var _model_Extension_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model/Extension.js */ \"./node_modules/cm-chessboard/src/model/Extension.js\");\n/* harmony import */ var _view_ChessboardView_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./view/ChessboardView.js */ \"./node_modules/cm-chessboard/src/view/ChessboardView.js\");\n/* harmony import */ var _lib_Utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/Utils.js */ \"./node_modules/cm-chessboard/src/lib/Utils.js\");\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\n\n\n\n\n\n\n\nconst PIECE = {\n    wp: \"wp\", wb: \"wb\", wn: \"wn\", wr: \"wr\", wq: \"wq\", wk: \"wk\",\n    bp: \"bp\", bb: \"bb\", bn: \"bn\", br: \"br\", bq: \"bq\", bk: \"bk\"\n}\nconst PIECE_TYPE = {\n    pawn: \"p\", knight: \"n\", bishop: \"b\", rook: \"r\", queen: \"q\", king: \"k\"\n}\nconst PIECES_FILE_TYPE = {\n    svgSprite: \"svgSprite\"\n}\n\n\n\n\n\n\nclass Chessboard {\n\n    constructor(context, props = {}) {\n        if (!context) {\n            throw new Error(\"container element is \" + context)\n        }\n        this.context = context\n        this.id = (Math.random() + 1).toString(36).substring(2, 8)\n        this.extensions = []\n        this.props = {\n            position: _model_Position_js__WEBPACK_IMPORTED_MODULE_1__.FEN.empty, // set position as fen, use FEN.start or FEN.empty as shortcuts\n            orientation: _view_ChessboardView_js__WEBPACK_IMPORTED_MODULE_4__.COLOR.white, // white on bottom\n            responsive: true, // resize the board automatically to the size of the context element\n            assetsUrl: \"./assets/\", // put all css and sprites in this folder, will be ignored for absolute urls of assets files\n            assetsCache: true, // cache the sprites, deactivate if you want to use multiple pieces sets in one page\n            style: {\n                cssClass: \"default\", // set the css theme of the board, try \"green\", \"blue\" or \"chess-club\"\n                showCoordinates: true, // show ranks and files\n                borderType: _view_ChessboardView_js__WEBPACK_IMPORTED_MODULE_4__.BORDER_TYPE.none, // \"thin\" thin border, \"frame\" wide border with coordinates in it, \"none\" no border\n                aspectRatio: 1, // height/width of the board\n                pieces: {\n                    type: PIECES_FILE_TYPE.svgSprite, // pieces are in an SVG sprite, no other type supported for now\n                    file: \"pieces/standard.svg\", // the filename of the sprite in `assets/pieces/` or an absolute url like `https://` or `/`\n                    tileSize: 40 // the tile size in the sprite\n                },\n                animationDuration: 300 // pieces animation duration in milliseconds. Disable all animations with `0`\n            },\n            extensions: [ /* {class: ExtensionClass, props: { ... }} */] // add extensions here\n        }\n        _lib_Utils_js__WEBPACK_IMPORTED_MODULE_5__.Utils.mergeObjects(this.props, props)\n        this.state = new _model_ChessboardState_js__WEBPACK_IMPORTED_MODULE_0__.ChessboardState()\n        this.view = new _view_ChessboardView_js__WEBPACK_IMPORTED_MODULE_4__.ChessboardView(this)\n        this.positionAnimationsQueue = new _view_PositionAnimationsQueue_js__WEBPACK_IMPORTED_MODULE_2__.PositionAnimationsQueue(this)\n        this.state.orientation = this.props.orientation\n        // instantiate extensions\n        for (const extensionData of this.props.extensions) {\n            this.addExtension(extensionData.class, extensionData.props)\n        }\n        this.view.redrawBoard()\n        this.state.position = new _model_Position_js__WEBPACK_IMPORTED_MODULE_1__.Position(this.props.position)\n        this.view.redrawPieces()\n        this.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_3__.EXTENSION_POINT.positionChanged)\n        this.initialized = Promise.resolve() // deprecated 2023-09-19 don't use this anymore\n    }\n\n    // API //\n\n    async setPiece(square, piece, animated = false) {\n        const positionFrom = this.state.position.clone()\n        this.state.position.setPiece(square, piece)\n        this.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_3__.EXTENSION_POINT.positionChanged)\n        return this.positionAnimationsQueue.enqueuePositionChange(positionFrom, this.state.position.clone(), animated)\n    }\n\n    async movePiece(squareFrom, squareTo, animated = false) {\n        const positionFrom = this.state.position.clone()\n        this.state.position.movePiece(squareFrom, squareTo)\n        this.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_3__.EXTENSION_POINT.positionChanged)\n        return this.positionAnimationsQueue.enqueuePositionChange(positionFrom, this.state.position.clone(), animated)\n    }\n\n    async setPosition(fen, animated = false) {\n        const positionFrom = this.state.position.clone()\n        const positionTo = new _model_Position_js__WEBPACK_IMPORTED_MODULE_1__.Position(fen)\n        if (positionFrom.getFen() !== positionTo.getFen()) {\n            this.state.position.setFen(fen)\n            this.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_3__.EXTENSION_POINT.positionChanged)\n        }\n        return this.positionAnimationsQueue.enqueuePositionChange(positionFrom, this.state.position.clone(), animated)\n    }\n\n    async setOrientation(color, animated = false) {\n        const position = this.state.position.clone()\n        if (this.boardTurning) {\n            console.warn(\"setOrientation is only once in queue allowed\")\n            return\n        }\n        this.boardTurning = true\n        return this.positionAnimationsQueue.enqueueTurnBoard(position, color, animated).then(() => {\n            this.boardTurning = false\n            this.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_3__.EXTENSION_POINT.boardChanged)\n        })\n    }\n\n    getPiece(square) {\n        return this.state.position.getPiece(square)\n    }\n\n    getPosition() {\n        return this.state.position.getFen()\n    }\n\n    getOrientation() {\n        return this.state.orientation\n    }\n\n    enableMoveInput(eventHandler, color = undefined) {\n        this.view.enableMoveInput(eventHandler, color)\n    }\n\n    disableMoveInput() {\n        this.view.disableMoveInput()\n    }\n\n    isMoveInputEnabled() {\n        return this.state.inputWhiteEnabled || this.state.inputBlackEnabled\n    }\n\n    enableSquareSelect(eventType = _view_ChessboardView_js__WEBPACK_IMPORTED_MODULE_4__.POINTER_EVENTS.pointerdown, eventHandler) {\n        if (!this.squareSelectListener) {\n            this.squareSelectListener = function (e) {\n                const square = e.target.getAttribute(\"data-square\")\n                eventHandler({\n                    eventType: e.type,\n                    event: e,\n                    chessboard: this,\n                    square: square\n                })\n            }\n        }\n        this.context.addEventListener(eventType, this.squareSelectListener)\n        this.state.squareSelectEnabled = true\n        this.view.visualizeInputState()\n    }\n\n    disableSquareSelect(eventType) {\n        this.context.removeEventListener(eventType, this.squareSelectListener)\n        this.squareSelectListener = undefined\n        this.state.squareSelectEnabled = false\n        this.view.visualizeInputState()\n    }\n\n    isSquareSelectEnabled() {\n        return this.state.squareSelectEnabled\n    }\n\n    addExtension(extensionClass, props) {\n        if (this.getExtension(extensionClass)) {\n            throw Error(\"extension \\\"\" + extensionClass.name + \"\\\" already added\")\n        }\n        this.extensions.push(new extensionClass(this, props))\n    }\n\n    getExtension(extensionClass) {\n        for (const extension of this.extensions) {\n            if (extension instanceof extensionClass) {\n                return extension\n            }\n        }\n        return null\n    }\n\n    destroy() {\n        this.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_3__.EXTENSION_POINT.destroy)\n        this.positionAnimationsQueue.destroy()\n        this.view.destroy()\n        this.view = undefined\n        this.state = undefined\n    }\n\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/Chessboard.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/extensions/arrows/Arrows.js":
/*!********************************************************************!*\
  !*** ./node_modules/cm-chessboard/src/extensions/arrows/Arrows.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ARROW_TYPE: () => (/* binding */ ARROW_TYPE),\n/* harmony export */   Arrows: () => (/* binding */ Arrows)\n/* harmony export */ });\n/* harmony import */ var _model_Extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../model/Extension.js */ \"./node_modules/cm-chessboard/src/model/Extension.js\");\n/* harmony import */ var _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/Svg.js */ \"./node_modules/cm-chessboard/src/lib/Svg.js\");\n/* harmony import */ var _lib_Utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/Utils.js */ \"./node_modules/cm-chessboard/src/lib/Utils.js\");\n/**\n * Authors and copyright: Barak Michener (@barakmich) and Stefan Haack (@shaack)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\n\n\n\n\nconst ARROW_TYPE = {\n    default: {class: \"arrow-default\", slice: \"arrowDefault\", headSize: 7},\n    danger: {class: \"arrow-danger\", slice: \"arrowDefault\", headSize: 7},\n    pointy: {class: \"arrow-pointy\", slice: \"arrowPointy\", headSize: 7},\n}\n\nclass Arrows extends _model_Extension_js__WEBPACK_IMPORTED_MODULE_0__.Extension {\n\n    /** @constructor */\n    constructor(chessboard, props = {}) {\n        super(chessboard)\n        this.registerExtensionPoint(_model_Extension_js__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_POINT.afterRedrawBoard, () => {\n            this.onRedrawBoard()\n        })\n        this.props = {\n            sprite: \"extensions/arrows/arrows.svg\"\n        }\n        Object.assign(this.props, props)\n        if (this.chessboard.props.assetsCache) {\n            this.chessboard.view.cacheSpriteToDiv(\"cm-chessboard-arrows\", this.getSpriteUrl())\n        }\n        chessboard.addArrow = this.addArrow.bind(this)\n        chessboard.getArrows = this.getArrows.bind(this)\n        chessboard.removeArrows = this.removeArrows.bind(this)\n        this.arrowGroup = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(chessboard.view.markersTopLayer, \"g\", {class: \"arrows\"})\n        this.arrows = []\n    }\n\n    onRedrawBoard() {\n        while (this.arrowGroup.firstChild) {\n            this.arrowGroup.removeChild(this.arrowGroup.firstChild)\n        }\n        this.arrows.forEach((arrow) => {\n            this.drawArrow(arrow)\n        })\n    }\n\n    drawArrow(arrow) {\n        const arrowsGroup = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(this.arrowGroup, \"g\")\n        arrowsGroup.setAttribute(\"data-arrow\", arrow.from + arrow.to)\n        arrowsGroup.setAttribute(\"class\", \"arrow \" + arrow.type.class)\n        const view = this.chessboard.view\n        const sqfrom = document.querySelectorAll('[data-square=\"' + arrow.from + '\"]')[0]\n        const sqto = document.querySelectorAll('[data-square=\"' + arrow.to + '\"]')[0]\n        const spriteUrl = this.chessboard.props.assetsCache ? \"\" : this.getSpriteUrl()\n        const defs = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(arrowsGroup, \"defs\")\n        const id = \"arrow-\" + arrow.from + arrow.to\n        const marker = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(defs, \"marker\", {\n            id: id,\n            markerWidth: arrow.type.headSize,\n            markerHeight: arrow.type.headSize,\n            //markerUnits: \"userSpaceOnUse\",\n            refX: 20,\n            refY: 20,\n            viewBox: \"0 0 40 40\",\n            orient: \"auto\",\n            class: \"arrow-head\",\n        })\n\n        const ignored = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(marker, \"use\", {\n            href: `${spriteUrl}#${arrow.type.slice}`,\n        })\n\n        const x1 = sqfrom.x.baseVal.value + (sqfrom.width.baseVal.value / 2)\n        const x2 = sqto.x.baseVal.value + (sqto.width.baseVal.value / 2)\n        const y1 = sqfrom.y.baseVal.value + (sqfrom.height.baseVal.value / 2)\n        const y2 = sqto.y.baseVal.value + (sqto.height.baseVal.value / 2)\n\n        const width = ((view.scalingX + view.scalingY) / 2) * 4\n        let lineFill = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(arrowsGroup, \"line\")\n        lineFill.setAttribute('x1', x1.toString())\n        lineFill.setAttribute('x2', x2.toString())\n        lineFill.setAttribute('y1', y1.toString())\n        lineFill.setAttribute('y2', y2.toString())\n        lineFill.setAttribute('class', 'arrow-line')\n        lineFill.setAttribute(\"marker-end\", \"url(#\" + id + \")\")\n        lineFill.setAttribute('stroke-width', width + \"px\")\n    }\n\n    addArrow(type, from, to) {\n        this.arrows.push(new Arrow(from, to, type))\n        this.chessboard.view.redrawBoard()\n    }\n\n    getArrows(type = undefined, from = undefined, to = undefined) {\n        let arrows = []\n        this.arrows.forEach((arrow) => {\n            if (arrow.matches(from, to, type)) {\n                arrows.push(arrow)\n            }\n        })\n        return arrows\n    }\n\n    removeArrows(type = undefined, from = undefined, to = undefined) {\n        this.arrows = this.arrows.filter((arrow) => !arrow.matches(from, to, type))\n        this.chessboard.view.redrawBoard()\n    }\n\n    getSpriteUrl() {\n        if(_lib_Utils_js__WEBPACK_IMPORTED_MODULE_2__.Utils.isAbsoluteUrl(this.props.sprite)) {\n            return this.props.sprite\n        } else {\n            return this.chessboard.props.assetsUrl + this.props.sprite\n        }\n    }\n}\n\nclass Arrow {\n    constructor(from, to, type) {\n        this.from = from\n        this.to = to\n        this.type = type\n    }\n\n    matches(from = undefined, to = undefined, type = undefined) {\n        if (from && from !== this.from) {\n            return false\n        }\n        if (to && to !== this.to) {\n            return false\n        }\n        return !(type && type !== this.type)\n    }\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/extensions/arrows/Arrows.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/extensions/markers/Markers.js":
/*!**********************************************************************!*\
  !*** ./node_modules/cm-chessboard/src/extensions/markers/Markers.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MARKER_TYPE: () => (/* binding */ MARKER_TYPE),\n/* harmony export */   Markers: () => (/* binding */ Markers)\n/* harmony export */ });\n/* harmony import */ var _model_Extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../model/Extension.js */ \"./node_modules/cm-chessboard/src/model/Extension.js\");\n/* harmony import */ var _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/Svg.js */ \"./node_modules/cm-chessboard/src/lib/Svg.js\");\n/* harmony import */ var _Chessboard_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Chessboard.js */ \"./node_modules/cm-chessboard/src/Chessboard.js\");\n/* harmony import */ var _lib_Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/Utils.js */ \"./node_modules/cm-chessboard/src/lib/Utils.js\");\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\n\n\n\n\nconst MARKER_TYPE = {\n    frame: {class: \"marker-frame\", slice: \"markerFrame\"},\n    framePrimary: {class: \"marker-frame-primary\", slice: \"markerFrame\"},\n    frameDanger: {class: \"marker-frame-danger\", slice: \"markerFrame\"},\n    circle: {class: \"marker-circle\", slice: \"markerCircle\"},\n    circlePrimary: {class: \"marker-circle-primary\", slice: \"markerCircle\"},\n    circleDanger: {class: \"marker-circle-danger\", slice: \"markerCircle\"},\n    square: {class: \"marker-square\", slice: \"markerSquare\"},\n    dot: {class: \"marker-dot\", slice: \"markerDot\", position: 'above'},\n    bevel: {class: \"marker-bevel\", slice: \"markerBevel\"}\n}\n\nclass Markers extends _model_Extension_js__WEBPACK_IMPORTED_MODULE_0__.Extension {\n\n    /** @constructor */\n    constructor(chessboard, props = {}) {\n        super(chessboard)\n        this.registerExtensionPoint(_model_Extension_js__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_POINT.afterRedrawBoard, () => {\n            this.onRedrawBoard()\n        })\n        this.props = {\n            autoMarkers: MARKER_TYPE.frame, // set to `null` to disable autoMarkers\n            sprite: \"extensions/markers/markers.svg\" // the sprite file of the markers\n        }\n        Object.assign(this.props, props)\n        if (chessboard.props.assetsCache) {\n            chessboard.view.cacheSpriteToDiv(\"cm-chessboard-markers\", this.getSpriteUrl())\n        }\n        chessboard.addMarker = this.addMarker.bind(this)\n        chessboard.getMarkers = this.getMarkers.bind(this)\n        chessboard.removeMarkers = this.removeMarkers.bind(this)\n        chessboard.addLegalMovesMarkers = this.addLegalMovesMarkers.bind(this)\n        chessboard.removeLegalMovesMarkers = this.removeLegalMovesMarkers.bind(this)\n        this.markerGroupDown = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(chessboard.view.markersLayer, \"g\", {class: \"markers\"})\n        this.markerGroupUp = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(chessboard.view.markersTopLayer, \"g\", {class: \"markers\"})\n        this.markers = []\n        if (this.props.autoMarkers) {\n            Object.assign(this.props.autoMarkers, this.props.autoMarkers)\n            this.registerExtensionPoint(_model_Extension_js__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_POINT.moveInput, (event) => {\n                this.drawAutoMarkers(event)\n            })\n        }\n    }\n\n    drawAutoMarkers(event) {\n        if(event.type !== _Chessboard_js__WEBPACK_IMPORTED_MODULE_2__.INPUT_EVENT_TYPE.moveInputFinished) {\n            this.removeMarkers(this.props.autoMarkers)\n        }\n        if (event.type === _Chessboard_js__WEBPACK_IMPORTED_MODULE_2__.INPUT_EVENT_TYPE.moveInputStarted &&\n            !event.moveInputCallbackResult) {\n            return\n        }\n        if (event.type === _Chessboard_js__WEBPACK_IMPORTED_MODULE_2__.INPUT_EVENT_TYPE.moveInputStarted ||\n            event.type === _Chessboard_js__WEBPACK_IMPORTED_MODULE_2__.INPUT_EVENT_TYPE.movingOverSquare) {\n            if (event.squareFrom) {\n                this.addMarker(this.props.autoMarkers, event.squareFrom)\n            }\n            if (event.squareTo) {\n                this.addMarker(this.props.autoMarkers, event.squareTo)\n            }\n        }\n    }\n\n    onRedrawBoard() {\n        while (this.markerGroupUp.firstChild) {\n            this.markerGroupUp.removeChild(this.markerGroupUp.firstChild)\n        }\n        while (this.markerGroupDown.firstChild) {\n            this.markerGroupDown.removeChild(this.markerGroupDown.firstChild)\n        }\n        this.markers.forEach((marker) => {\n                this.drawMarker(marker)\n            }\n        )\n    }\n\n    addLegalMovesMarkers(moves) {\n        for (const move of moves) {\n            if (move.promotion && move.promotion !== \"q\") {\n                continue\n            }\n            if (this.chessboard.getPiece(move.to)) {\n                this.chessboard.addMarker(MARKER_TYPE.bevel, move.to)\n            } else {\n                this.chessboard.addMarker(MARKER_TYPE.dot, move.to)\n            }\n        }\n    }\n\n    removeLegalMovesMarkers() {\n        this.chessboard.removeMarkers(MARKER_TYPE.bevel)\n        this.chessboard.removeMarkers(MARKER_TYPE.dot)\n    }\n\n    drawMarker(marker) {\n        let markerGroup\n        if (marker.type.position === 'above') {\n            markerGroup = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(this.markerGroupUp, \"g\")\n        } else {\n            markerGroup = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(this.markerGroupDown, \"g\")\n        }\n        markerGroup.setAttribute(\"data-square\", marker.square)\n        const point = this.chessboard.view.squareToPoint(marker.square)\n        const transform = (this.chessboard.view.svg.createSVGTransform())\n        transform.setTranslate(point.x, point.y)\n        markerGroup.transform.baseVal.appendItem(transform)\n        const spriteUrl = this.chessboard.props.assetsCache ? \"\" : this.getSpriteUrl()\n        const markerUse = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.addElement(markerGroup, \"use\",\n            {href: `${spriteUrl}#${marker.type.slice}`, class: \"marker \" + marker.type.class})\n        const transformScale = (this.chessboard.view.svg.createSVGTransform())\n        transformScale.setScale(this.chessboard.view.scalingX, this.chessboard.view.scalingY)\n        markerUse.transform.baseVal.appendItem(transformScale)\n        return markerGroup\n    }\n\n    addMarker(type, square) {\n        if (typeof type === \"string\" || typeof square === \"object\") { // todo remove 2022-12-01\n            console.error(\"changed the signature of `addMarker` to `(type, square)` with v5.1.x\")\n            return\n        }\n        this.markers.push(new Marker(square, type))\n        this.onRedrawBoard()\n    }\n\n    getMarkers(type = undefined, square = undefined) {\n        if (typeof type === \"string\" || typeof square === \"object\") { // todo remove 2022-12-01\n            console.error(\"changed the signature of `getMarkers` to `(type, square)` with v5.1.x\")\n            return\n        }\n        let markersFound = []\n        this.markers.forEach((marker) => {\n            if (marker.matches(square, type)) {\n                markersFound.push(marker)\n            }\n        })\n        return markersFound\n    }\n\n    removeMarkers(type = undefined, square = undefined) {\n        if (typeof type === \"string\" || typeof square === \"object\") { // todo remove 2022-12-01\n            console.error(\"changed the signature of `removeMarkers` to `(type, square)` with v5.1.x\")\n            return\n        }\n        this.markers = this.markers.filter((marker) => !marker.matches(square, type))\n        this.onRedrawBoard()\n    }\n\n    getSpriteUrl() {\n        if(_lib_Utils_js__WEBPACK_IMPORTED_MODULE_3__.Utils.isAbsoluteUrl(this.props.sprite)) {\n            return this.props.sprite\n        } else {\n            return this.chessboard.props.assetsUrl + this.props.sprite\n        }\n    }\n}\n\nclass Marker {\n    constructor(square, type) {\n        this.square = square\n        this.type = type\n    }\n\n    matches(square = undefined, type = undefined) {\n        if (!type && !square) {\n            return true\n        } else if (!type) {\n            if (square === this.square) {\n                return true\n            }\n        } else if (!square) {\n            if (this.type === type) {\n                return true\n            }\n        } else if (this.type === type && square === this.square) {\n            return true\n        }\n        return false\n    }\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/extensions/markers/Markers.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/extensions/promotion-dialog/PromotionDialog.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/cm-chessboard/src/extensions/promotion-dialog/PromotionDialog.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PROMOTION_DIALOG_RESULT_TYPE: () => (/* binding */ PROMOTION_DIALOG_RESULT_TYPE),\n/* harmony export */   PromotionDialog: () => (/* binding */ PromotionDialog)\n/* harmony export */ });\n/* harmony import */ var _model_Extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../model/Extension.js */ \"./node_modules/cm-chessboard/src/model/Extension.js\");\n/* harmony import */ var _Chessboard_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Chessboard.js */ \"./node_modules/cm-chessboard/src/Chessboard.js\");\n/* harmony import */ var _lib_Svg_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/Svg.js */ \"./node_modules/cm-chessboard/src/lib/Svg.js\");\n/* harmony import */ var _lib_Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/Utils.js */ \"./node_modules/cm-chessboard/src/lib/Utils.js\");\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\n\n\n\n\nconst DISPLAY_STATE = {\n    hidden: \"hidden\",\n    displayRequested: \"displayRequested\",\n    shown: \"shown\"\n}\n\nconst PROMOTION_DIALOG_RESULT_TYPE = {\n    pieceSelected: \"pieceSelected\",\n    canceled: \"canceled\"\n}\n\nclass PromotionDialog extends _model_Extension_js__WEBPACK_IMPORTED_MODULE_0__.Extension {\n\n    /** @constructor */\n    constructor(chessboard) {\n        super(chessboard)\n        this.registerExtensionPoint(_model_Extension_js__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_POINT.afterRedrawBoard, this.extensionPointRedrawBoard.bind(this))\n        chessboard.showPromotionDialog = this.showPromotionDialog.bind(this)\n        chessboard.isPromotionDialogShown = this.isPromotionDialogShown.bind(this)\n        this.promotionDialogGroup = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_2__.Svg.addElement(chessboard.view.interactiveTopLayer, \"g\", {class: \"promotion-dialog-group\"})\n        this.state = {\n            displayState: DISPLAY_STATE.hidden,\n            callback: null,\n            dialogParams: {\n                square: null,\n                color: null\n            }\n        }\n    }\n\n    // public (chessboard.showPromotionDialog)\n    showPromotionDialog(square, color, callback) {\n        this.state.dialogParams.square = square\n        this.state.dialogParams.color = color\n        this.state.callback = callback\n        this.setDisplayState(DISPLAY_STATE.displayRequested)\n        setTimeout(() => {\n                this.chessboard.view.positionsAnimationTask.then(() => {\n                    this.setDisplayState(DISPLAY_STATE.shown)\n                })\n            }\n        )\n    }\n\n    // public (chessboard.isPromotionDialogShown)\n    isPromotionDialogShown() {\n        return this.state.displayState === DISPLAY_STATE.shown ||\n            this.state.displayState === DISPLAY_STATE.displayRequested\n    }\n\n    // private\n    extensionPointRedrawBoard() {\n        this.redrawDialog()\n    }\n\n    drawPieceButton(piece, point) {\n        const squareWidth = this.chessboard.view.squareWidth\n        const squareHeight = this.chessboard.view.squareHeight\n        _lib_Svg_js__WEBPACK_IMPORTED_MODULE_2__.Svg.addElement(this.promotionDialogGroup,\n            \"rect\", {\n                x: point.x, y: point.y, width: squareWidth, height: squareHeight,\n                class: \"promotion-dialog-button\",\n                \"data-piece\": piece\n            })\n        this.chessboard.view.drawPiece(this.promotionDialogGroup, piece, point)\n    }\n\n    redrawDialog() {\n        while (this.promotionDialogGroup.firstChild) {\n            this.promotionDialogGroup.removeChild(this.promotionDialogGroup.firstChild)\n        }\n        if (this.state.displayState === DISPLAY_STATE.shown) {\n            const squareWidth = this.chessboard.view.squareWidth\n            const squareHeight = this.chessboard.view.squareHeight\n            const squareCenterPoint = this.chessboard.view.squareToPoint(this.state.dialogParams.square)\n            squareCenterPoint.x = squareCenterPoint.x + squareWidth / 2\n            squareCenterPoint.y = squareCenterPoint.y + squareHeight / 2\n            let turned = false\n            const rank = parseInt(this.state.dialogParams.square.charAt(1), 10)\n            if (this.chessboard.getOrientation() === _Chessboard_js__WEBPACK_IMPORTED_MODULE_1__.COLOR.white && rank < 5 ||\n                this.chessboard.getOrientation() === _Chessboard_js__WEBPACK_IMPORTED_MODULE_1__.COLOR.black && rank >= 5) {\n                turned = true\n            }\n            const offsetY = turned ? -4 * squareHeight : 0\n            const offsetX = squareCenterPoint.x + squareWidth > this.chessboard.view.width ? -squareWidth : 0\n            _lib_Svg_js__WEBPACK_IMPORTED_MODULE_2__.Svg.addElement(this.promotionDialogGroup,\n                \"rect\", {\n                    x: squareCenterPoint.x + offsetX,\n                    y: squareCenterPoint.y + offsetY,\n                    width: squareWidth,\n                    height: squareHeight * 4,\n                    class: \"promotion-dialog\"\n                })\n            const dialogParams = this.state.dialogParams\n            if (turned) {\n                this.drawPieceButton(_Chessboard_js__WEBPACK_IMPORTED_MODULE_1__.PIECE[dialogParams.color + \"q\"], {\n                    x: squareCenterPoint.x + offsetX,\n                    y: squareCenterPoint.y - squareHeight\n                })\n                this.drawPieceButton(_Chessboard_js__WEBPACK_IMPORTED_MODULE_1__.PIECE[dialogParams.color + \"r\"], {\n                    x: squareCenterPoint.x + offsetX,\n                    y: squareCenterPoint.y - squareHeight * 2\n                })\n                this.drawPieceButton(_Chessboard_js__WEBPACK_IMPORTED_MODULE_1__.PIECE[dialogParams.color + \"b\"], {\n                    x: squareCenterPoint.x + offsetX,\n                    y: squareCenterPoint.y - squareHeight * 3\n                })\n                this.drawPieceButton(_Chessboard_js__WEBPACK_IMPORTED_MODULE_1__.PIECE[dialogParams.color + \"n\"], {\n                    x: squareCenterPoint.x + offsetX,\n                    y: squareCenterPoint.y - squareHeight * 4\n                })\n            } else {\n                this.drawPieceButton(_Chessboard_js__WEBPACK_IMPORTED_MODULE_1__.PIECE[dialogParams.color + \"q\"], {\n                    x: squareCenterPoint.x + offsetX,\n                    y: squareCenterPoint.y\n                })\n                this.drawPieceButton(_Chessboard_js__WEBPACK_IMPORTED_MODULE_1__.PIECE[dialogParams.color + \"r\"], {\n                    x: squareCenterPoint.x + offsetX,\n                    y: squareCenterPoint.y + squareHeight\n                })\n                this.drawPieceButton(_Chessboard_js__WEBPACK_IMPORTED_MODULE_1__.PIECE[dialogParams.color + \"b\"], {\n                    x: squareCenterPoint.x + offsetX,\n                    y: squareCenterPoint.y + squareHeight * 2\n                })\n                this.drawPieceButton(_Chessboard_js__WEBPACK_IMPORTED_MODULE_1__.PIECE[dialogParams.color + \"n\"], {\n                    x: squareCenterPoint.x + offsetX,\n                    y: squareCenterPoint.y + squareHeight * 3\n                })\n            }\n        }\n    }\n\n    promotionDialogOnClickPiece(event) {\n        if (event.button !== 2) {\n            if (event.target.dataset.piece) {\n                if(this.state.callback) {\n                    this.state.callback({\n                        type: PROMOTION_DIALOG_RESULT_TYPE.pieceSelected,\n                        square: this.state.dialogParams.square,\n                        piece: event.target.dataset.piece\n                    })\n                }\n                this.setDisplayState(DISPLAY_STATE.hidden)\n            } else {\n                this.promotionDialogOnCancel(event)\n            }\n        }\n    }\n\n    promotionDialogOnCancel(event) {\n        if (this.state.displayState === DISPLAY_STATE.shown) {\n            event.preventDefault()\n            this.setDisplayState(DISPLAY_STATE.hidden)\n            if(this.state.callback) {\n                this.state.callback({type: PROMOTION_DIALOG_RESULT_TYPE.canceled})\n            }\n        }\n    }\n\n    contextMenu(event) {\n        event.preventDefault()\n        this.setDisplayState(DISPLAY_STATE.hidden)\n        if(this.state.callback) {\n            this.state.callback({type: PROMOTION_DIALOG_RESULT_TYPE.canceled})\n        }\n    }\n\n    setDisplayState(displayState) {\n        this.state.displayState = displayState\n        if (displayState === DISPLAY_STATE.shown) {\n            this.clickDelegate = _lib_Utils_js__WEBPACK_IMPORTED_MODULE_3__.Utils.delegate(this.chessboard.view.svg,\n                \"pointerdown\",\n                \"*\",\n                this.promotionDialogOnClickPiece.bind(this))\n            this.contextMenuListener = this.contextMenu.bind(this)\n            this.chessboard.view.svg.addEventListener(\"contextmenu\", this.contextMenuListener)\n        } else if (displayState === DISPLAY_STATE.hidden) {\n            this.clickDelegate.remove()\n            this.chessboard.view.svg.removeEventListener(\"contextmenu\", this.contextMenuListener)\n        }\n        this.redrawDialog()\n    }\n\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/extensions/promotion-dialog/PromotionDialog.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/lib/Svg.js":
/*!***************************************************!*\
  !*** ./node_modules/cm-chessboard/src/lib/Svg.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Svg: () => (/* binding */ Svg)\n/* harmony export */ });\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\"\n\nclass Svg {\n\n    /**\n     * create the Svg in the HTML DOM\n     * @param containerElement\n     * @returns {Element}\n     */\n    static createSvg(containerElement = undefined) {\n        let svg = document.createElementNS(SVG_NAMESPACE, \"svg\")\n        if (containerElement) {\n            svg.setAttribute(\"width\", \"100%\")\n            svg.setAttribute(\"height\", \"100%\")\n            containerElement.appendChild(svg)\n        }\n        return svg\n    }\n\n    /**\n     * Add an Element to an SVG DOM\n     * @param parent\n     * @param name\n     * @param attributes\n     * @returns {Element}\n     */\n    static addElement(parent, name, attributes = {}) {\n        let element = document.createElementNS(SVG_NAMESPACE, name)\n        if (name === \"use\") {\n            attributes[\"xlink:href\"] = attributes[\"href\"] // fix for safari\n        }\n        for (let attribute in attributes) {\n            if (attributes.hasOwnProperty(attribute)) {\n                if (attribute.indexOf(\":\") !== -1) {\n                    const value = attribute.split(\":\")\n                    element.setAttributeNS(\"http://www.w3.org/1999/\" + value[0], value[1], attributes[attribute])\n                } else {\n                    element.setAttribute(attribute, attributes[attribute])\n                }\n            }\n        }\n        parent.appendChild(element)\n        return element\n    }\n\n    /**\n     * Remove an element from an SVG DOM\n     * @param element\n     */\n    static removeElement(element) {\n        if(!element) {\n            console.warn(\"removeElement, element is\", element)\n            return\n        }\n        if (element.parentNode) {\n            element.parentNode.removeChild(element)\n        } else {\n            console.warn(element, \"without parentNode\")\n        }\n    }\n\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/lib/Svg.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/lib/Utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/cm-chessboard/src/lib/Utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Utils: () => (/* binding */ Utils)\n/* harmony export */ });\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\nclass Utils {\n\n    static delegate(element, eventName, selector, handler) {\n        const eventListener = function (event) {\n            let target = event.target\n            while (target && target !== this) {\n                if (target.matches(selector)) {\n                    handler.call(target, event)\n                }\n                target = target.parentNode\n            }\n        }\n        element.addEventListener(eventName, eventListener)\n        return {\n            remove: function () {\n                element.removeEventListener(eventName, eventListener)\n            }\n        }\n    }\n\n    static mergeObjects(target, source) {\n        const isObject = (obj) => obj && typeof obj === 'object'\n        if (!isObject(target) || !isObject(source)) {\n            return source\n        }\n        for (const key of Object.keys(source)) {\n            if (source[key] instanceof Object) {\n                Object.assign(source[key], Utils.mergeObjects(target[key], source[key]))\n            }\n        }\n        Object.assign(target || {}, source)\n        return target\n    }\n\n    static createDomElement(html) {\n        const template = document.createElement('template')\n        template.innerHTML = html.trim()\n        return template.content.firstChild\n    }\n\n    static createTask() {\n        let resolve, reject\n        const promise = new Promise(function (_resolve, _reject) {\n            resolve = _resolve\n            reject = _reject\n        })\n        promise.resolve = resolve\n        promise.reject = reject\n        return promise\n    }\n\n    static isAbsoluteUrl(url) {\n        return url.indexOf(\"://\") !== -1 || url.startsWith(\"/\")\n    }\n\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/lib/Utils.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/model/ChessboardState.js":
/*!*****************************************************************!*\
  !*** ./node_modules/cm-chessboard/src/model/ChessboardState.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChessboardState: () => (/* binding */ ChessboardState)\n/* harmony export */ });\n/* harmony import */ var _Position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Position.js */ \"./node_modules/cm-chessboard/src/model/Position.js\");\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\n\nclass ChessboardState {\n\n    constructor() {\n        this.position = new _Position_js__WEBPACK_IMPORTED_MODULE_0__.Position()\n        this.orientation = undefined\n        this.inputWhiteEnabled = false\n        this.inputBlackEnabled = false\n        this.squareSelectEnabled = false\n        this.moveInputCallback = null\n        this.extensionPoints = {}\n        this.moveInputProcess = Promise.resolve()\n    }\n\n    inputEnabled() {\n        return this.inputWhiteEnabled || this.inputBlackEnabled\n    }\n\n    invokeExtensionPoints(name, data = {}) {\n        const extensionPoints = this.extensionPoints[name]\n        const dataCloned = Object.assign({}, data)\n        dataCloned.extensionPoint = name\n        let returnValue = true\n        if (extensionPoints) {\n            for (const extensionPoint of extensionPoints) {\n                if(extensionPoint(dataCloned) === false) {\n                    returnValue = false\n                }\n            }\n        }\n        return returnValue\n    }\n\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/model/ChessboardState.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/model/Extension.js":
/*!***********************************************************!*\
  !*** ./node_modules/cm-chessboard/src/model/Extension.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXTENSION_POINT: () => (/* binding */ EXTENSION_POINT),\n/* harmony export */   Extension: () => (/* binding */ Extension)\n/* harmony export */ });\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\nconst EXTENSION_POINT = {\n    positionChanged: \"positionChanged\", // the positions of the pieces was changed\n    boardChanged: \"boardChanged\", // the board (orientation) was changed\n    moveInputToggled: \"moveInputToggled\", // move input was enabled or disabled\n    moveInput: \"moveInput\", // move started, moving over a square, validating or canceled\n    beforeRedrawBoard: \"beforeRedrawBoard\", // called before redrawing the board\n    afterRedrawBoard: \"afterRedrawBoard\", // called after redrawing the board\n    redrawBoard: \"redrawBoard\", // called after redrawing the board, DEPRECATED, use afterRedrawBoard 2023-09-18\n    animation: \"animation\", // called on animation start, end, and on every animation frame\n    destroy: \"destroy\" // called, before the board is destroyed\n}\n\nclass Extension {\n\n    constructor(chessboard) {\n        this.chessboard = chessboard\n    }\n\n    registerExtensionPoint(name, callback) {\n        if(name === EXTENSION_POINT.redrawBoard) { // deprecated 2023-09-18\n            console.warn(\"EXTENSION_POINT.redrawBoard is deprecated, use EXTENSION_POINT.afterRedrawBoard\")\n            name = EXTENSION_POINT.afterRedrawBoard\n        }\n        if (!this.chessboard.state.extensionPoints[name]) {\n            this.chessboard.state.extensionPoints[name] = []\n        }\n        this.chessboard.state.extensionPoints[name].push(callback)\n    }\n\n    /** @deprecated 2023-05-18 */\n    registerMethod(name, callback) {\n        console.warn(\"registerMethod is deprecated, just add methods directly to the chessboard instance\")\n        if (!this.chessboard[name]) {\n            this.chessboard[name] = (...args) => {\n                return callback.apply(this, args)\n            }\n        } else {\n            log.error(\"method\", name, \"already exists\")\n        }\n    }\n\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/model/Extension.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/model/Position.js":
/*!**********************************************************!*\
  !*** ./node_modules/cm-chessboard/src/model/Position.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FEN: () => (/* binding */ FEN),\n/* harmony export */   Position: () => (/* binding */ Position)\n/* harmony export */ });\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\nconst FEN = {\n    start: \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\",\n    empty: \"8/8/8/8/8/8/8/8\"\n}\n\nclass Position {\n\n    constructor(fen = FEN.empty) {\n        this.squares = new Array(64).fill(null)\n        this.setFen(fen)\n    }\n\n    setFen(fen = FEN.empty) {\n        const parts = fen.replace(/^\\s*/, \"\").replace(/\\s*$/, \"\").split(/\\/|\\s/)\n        for (let part = 0; part < 8; part++) {\n            const row = parts[7 - part].replace(/\\d/g, (str) => {\n                const numSpaces = parseInt(str)\n                let ret = ''\n                for (let i = 0; i < numSpaces; i++) {\n                    ret += '-'\n                }\n                return ret\n            })\n            for (let c = 0; c < 8; c++) {\n                const char = row.substring(c, c + 1)\n                let piece = null\n                if (char !== '-') {\n                    if (char.toUpperCase() === char) {\n                        piece = `w${char.toLowerCase()}`\n                    } else {\n                        piece = `b${char}`\n                    }\n                }\n                this.squares[part * 8 + c] = piece\n            }\n        }\n    }\n\n    getFen() {\n        let parts = new Array(8).fill(\"\")\n        for (let part = 0; part < 8; part++) {\n            let spaceCounter = 0\n            for (let i = 0; i < 8; i++) {\n                const piece = this.squares[part * 8 + i]\n                if (!piece) {\n                    spaceCounter++\n                } else {\n                    if (spaceCounter > 0) {\n                        parts[7 - part] += spaceCounter\n                        spaceCounter = 0\n                    }\n                    const color = piece.substring(0, 1)\n                    const name = piece.substring(1, 2)\n                    if (color === \"w\") {\n                        parts[7 - part] += name.toUpperCase()\n                    } else {\n                        parts[7 - part] += name\n                    }\n                }\n            }\n            if (spaceCounter > 0) {\n                parts[7 - part] += spaceCounter\n                spaceCounter = 0\n            }\n        }\n        return parts.join(\"/\")\n    }\n\n    getPieces(pieceColor = undefined, pieceType = undefined, sortBy = ['k', 'q', 'r', 'b', 'n', 'p']) {\n        const pieces = []\n        const sort = (a, b) => {\n            return sortBy.indexOf(a.name) - sortBy.indexOf(b.name)\n        }\n        for (let i = 0; i < 64; i++) {\n            const piece = this.squares[i]\n            if (piece) {\n                const type = piece.charAt(1)\n                const color = piece.charAt(0)\n                const square = Position.indexToSquare(i)\n                if(pieceType && pieceType !== type || pieceColor && pieceColor !== color) {\n                    continue\n                }\n                pieces.push({\n                    name: type, // deprecated, use type\n                    type: type,\n                    color: color,\n                    position: square, // deprecated, use square\n                    square: square\n                })\n            }\n        }\n        if (sortBy) {\n            pieces.sort(sort)\n        }\n        return pieces\n    }\n\n    movePiece(squareFrom, squareTo) {\n        if (!this.squares[Position.squareToIndex(squareFrom)]) {\n            console.warn(\"no piece on\", squareFrom)\n            return\n        }\n        this.squares[Position.squareToIndex(squareTo)] = this.squares[Position.squareToIndex(squareFrom)]\n        this.squares[Position.squareToIndex(squareFrom)] = null\n    }\n\n    setPiece(square, piece) {\n        this.squares[Position.squareToIndex(square)] = piece\n    }\n\n    getPiece(square) {\n        return this.squares[Position.squareToIndex(square)]\n    }\n\n    static squareToIndex(square) {\n        const coordinates = Position.squareToCoordinates(square)\n        return coordinates[0] + coordinates[1] * 8\n    }\n\n    static indexToSquare(index) {\n        return this.coordinatesToSquare([Math.floor(index % 8), index / 8])\n    }\n\n    static squareToCoordinates(square) {\n        const file = square.charCodeAt(0) - 97\n        const rank = square.charCodeAt(1) - 49\n        return [file, rank]\n    }\n\n    static coordinatesToSquare(coordinates) {\n        const file = String.fromCharCode(coordinates[0] + 97)\n        const rank = String.fromCharCode(coordinates[1] + 49)\n        return file + rank\n    }\n\n    toString() {\n        return this.getFen()\n    }\n\n    clone() {\n        const cloned = new Position()\n        cloned.squares = this.squares.slice(0)\n        return cloned\n    }\n\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/model/Position.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/view/ChessboardView.js":
/*!***************************************************************!*\
  !*** ./node_modules/cm-chessboard/src/view/ChessboardView.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BORDER_TYPE: () => (/* binding */ BORDER_TYPE),\n/* harmony export */   COLOR: () => (/* binding */ COLOR),\n/* harmony export */   ChessboardView: () => (/* binding */ ChessboardView),\n/* harmony export */   INPUT_EVENT_TYPE: () => (/* binding */ INPUT_EVENT_TYPE),\n/* harmony export */   POINTER_EVENTS: () => (/* binding */ POINTER_EVENTS)\n/* harmony export */ });\n/* harmony import */ var _VisualMoveInput_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VisualMoveInput.js */ \"./node_modules/cm-chessboard/src/view/VisualMoveInput.js\");\n/* harmony import */ var _model_Position_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/Position.js */ \"./node_modules/cm-chessboard/src/model/Position.js\");\n/* harmony import */ var _model_Extension_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/Extension.js */ \"./node_modules/cm-chessboard/src/model/Extension.js\");\n/* harmony import */ var _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/Svg.js */ \"./node_modules/cm-chessboard/src/lib/Svg.js\");\n/* harmony import */ var _lib_Utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/Utils.js */ \"./node_modules/cm-chessboard/src/lib/Utils.js\");\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\n\n\n\n\n\n\nconst COLOR = {\n    white: \"w\",\n    black: \"b\"\n}\nconst INPUT_EVENT_TYPE = {\n    moveInputStarted: \"moveInputStarted\",\n    movingOverSquare: \"movingOverSquare\", // while dragging or hover after click\n    validateMoveInput: \"validateMoveInput\",\n    moveInputCanceled: \"moveInputCanceled\",\n    moveInputFinished: \"moveInputFinished\"\n}\nconst POINTER_EVENTS = {\n    pointercancel: \"pointercancel\",\n    pointerdown: \"pointerdown\",\n    pointerenter: \"pointerenter\",\n    pointerleave: \"pointerleave\",\n    pointermove: \"pointermove\",\n    pointerout: \"pointerout\",\n    pointerover: \"pointerover\",\n    pointerup: \"pointerup\"\n}\nconst BORDER_TYPE = {\n    none: \"none\", // no border\n    thin: \"thin\", // thin border\n    frame: \"frame\" // wide border with coordinates in it\n}\n\nclass ChessboardView {\n    constructor(chessboard) {\n        this.chessboard = chessboard\n        this.visualMoveInput = new _VisualMoveInput_js__WEBPACK_IMPORTED_MODULE_0__.VisualMoveInput(this)\n        if (chessboard.props.assetsCache) {\n            this.cacheSpriteToDiv(\"cm-chessboard-sprite\", this.getSpriteUrl())\n        }\n        this.container = document.createElement(\"div\")\n        this.chessboard.context.appendChild(this.container)\n        if (chessboard.props.responsive) {\n            if (typeof ResizeObserver !== \"undefined\") {\n                this.resizeObserver = new ResizeObserver(() => {\n                    setTimeout(() => { // prevents \"ResizeObserver loop completed with undelivered notifications.\"\n                        this.handleResize()\n                    })\n                })\n                this.resizeObserver.observe(this.chessboard.context)\n            } else {\n                this.resizeListener = this.handleResize.bind(this)\n                window.addEventListener(\"resize\", this.resizeListener)\n            }\n        }\n        this.positionsAnimationTask = Promise.resolve()\n        this.pointerDownListener = this.pointerDownHandler.bind(this)\n        this.container.addEventListener(\"mousedown\", this.pointerDownListener)\n        this.container.addEventListener(\"touchstart\", this.pointerDownListener, {passive: false})\n        this.createSvgAndGroups()\n        this.handleResize()\n    }\n\n    pointerDownHandler(e) {\n        this.visualMoveInput.onPointerDown(e)\n    }\n\n    destroy() {\n        this.visualMoveInput.destroy()\n        if (this.resizeObserver) {\n            this.resizeObserver.unobserve(this.chessboard.context)\n        }\n        if (this.resizeListener) {\n            window.removeEventListener(\"resize\", this.resizeListener)\n        }\n        this.chessboard.context.removeEventListener(\"mousedown\", this.pointerDownListener)\n        this.chessboard.context.removeEventListener(\"touchstart\", this.pointerDownListener)\n        _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.removeElement(this.svg)\n        this.container.remove()\n    }\n\n    // Sprite //\n\n    cacheSpriteToDiv(wrapperId, url) {\n        if (!document.getElementById(wrapperId)) {\n            const wrapper = document.createElement(\"div\")\n            wrapper.style.transform = \"scale(0)\"\n            wrapper.style.position = \"absolute\"\n            wrapper.setAttribute(\"aria-hidden\", \"true\")\n            wrapper.id = wrapperId\n            document.body.appendChild(wrapper)\n            const xhr = new XMLHttpRequest()\n            xhr.open(\"GET\", url, true)\n            xhr.onload = function () {\n                wrapper.insertAdjacentHTML('afterbegin', xhr.response)\n            }\n            xhr.send()\n        }\n    }\n\n    createSvgAndGroups() {\n        this.svg = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.createSvg(this.container)\n        // let description = document.createElement(\"description\")\n        // description.innerText = \"Chessboard\"\n        // description.id = \"svg-description\"\n        // this.svg.appendChild(description)\n        let cssClass = this.chessboard.props.style.cssClass ? this.chessboard.props.style.cssClass : \"default\"\n        this.svg.setAttribute(\"class\", \"cm-chessboard border-type-\" + this.chessboard.props.style.borderType + \" \" + cssClass)\n        // this.svg.setAttribute(\"aria-describedby\", \"svg-description\")\n        this.svg.setAttribute(\"role\", \"img\")\n        this.updateMetrics()\n        this.boardGroup = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.svg, \"g\", {class: \"board\"})\n        this.coordinatesGroup = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.svg, \"g\", {class: \"coordinates\", \"aria-hidden\": \"true\"})\n        this.markersLayer = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.svg, \"g\", {class: \"markers-layer\"})\n        this.piecesLayer = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.svg, \"g\", {class: \"pieces-layer\"})\n        this.piecesGroup = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.piecesLayer, \"g\", {class: \"pieces\"})\n        this.markersTopLayer = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.svg, \"g\", {class: \"markers-top-layer\"})\n        this.interactiveTopLayer = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.svg, \"g\", {class: \"interactive-top-layer\"})\n    }\n\n    updateMetrics() {\n        const piecesTileSize = this.chessboard.props.style.pieces.tileSize\n        this.width = this.container.clientWidth\n        this.height = this.container.clientWidth * (this.chessboard.props.style.aspectRatio || 1)\n        if (this.chessboard.props.style.borderType === BORDER_TYPE.frame) {\n            this.borderSize = this.width / 25\n        } else if (this.chessboard.props.style.borderType === BORDER_TYPE.thin) {\n            this.borderSize = this.width / 320\n        } else {\n            this.borderSize = 0\n        }\n        this.innerWidth = this.width - 2 * this.borderSize\n        this.innerHeight = this.height - 2 * this.borderSize\n        this.squareWidth = this.innerWidth / 8\n        this.squareHeight = this.innerHeight / 8\n        this.scalingX = this.squareWidth / piecesTileSize\n        this.scalingY = this.squareHeight / piecesTileSize\n        this.pieceXTranslate = (this.squareWidth / 2 - piecesTileSize * this.scalingY / 2)\n    }\n\n    handleResize() {\n        this.container.style.width = (this.chessboard.context.clientWidth) + \"px\"\n        this.container.style.height = (this.chessboard.context.clientWidth * this.chessboard.props.style.aspectRatio) + \"px\"\n        if (this.container.clientWidth !== this.width || this.container.clientHeight !== this.height) {\n            this.updateMetrics()\n            this.redrawBoard()\n            this.redrawPieces()\n        }\n        this.svg.setAttribute(\"width\", \"100%\")\n        this.svg.setAttribute(\"height\", \"100%\")\n    }\n\n    redrawBoard() {\n        this.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.beforeRedrawBoard)\n        this.redrawSquares()\n        this.drawCoordinates()\n        this.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.afterRedrawBoard)\n        this.visualizeInputState()\n    }\n\n    // Board //\n\n    redrawSquares() {\n        while (this.boardGroup.firstChild) {\n            this.boardGroup.removeChild(this.boardGroup.lastChild)\n        }\n\n        let boardBorder = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.boardGroup, \"rect\", {width: this.width, height: this.height})\n        boardBorder.setAttribute(\"class\", \"border\")\n        if (this.chessboard.props.style.borderType === BORDER_TYPE.frame) {\n            const innerPos = this.borderSize\n            let borderInner = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.boardGroup, \"rect\", {\n                x: innerPos, y: innerPos, width: this.width - innerPos * 2, height: this.height - innerPos * 2\n            })\n            borderInner.setAttribute(\"class\", \"border-inner\")\n        }\n\n        for (let i = 0; i < 64; i++) {\n            const index = this.chessboard.state.orientation === COLOR.white ? i : 63 - i\n            const squareColor = ((9 * index) & 8) === 0 ? 'black' : 'white'\n            const fieldClass = `square ${squareColor}`\n            const point = this.squareToPoint(_model_Position_js__WEBPACK_IMPORTED_MODULE_1__.Position.indexToSquare(index))\n            const squareRect = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.boardGroup, \"rect\", {\n                x: point.x, y: point.y, width: this.squareWidth, height: this.squareHeight\n            })\n            squareRect.setAttribute(\"class\", fieldClass)\n            squareRect.setAttribute(\"data-square\", _model_Position_js__WEBPACK_IMPORTED_MODULE_1__.Position.indexToSquare(index))\n        }\n    }\n\n    drawCoordinates() {\n        if (!this.chessboard.props.style.showCoordinates) {\n            return\n        }\n        while (this.coordinatesGroup.firstChild) {\n            this.coordinatesGroup.removeChild(this.coordinatesGroup.lastChild)\n        }\n        const inline = this.chessboard.props.style.borderType !== BORDER_TYPE.frame\n        for (let file = 0; file < 8; file++) {\n            let x = this.borderSize + (17 + this.chessboard.props.style.pieces.tileSize * file) * this.scalingX\n            let y = this.height - this.scalingY * 3.5\n            let cssClass = \"coordinate file\"\n            if (inline) {\n                x = x + this.scalingX * 15.5\n                cssClass += file % 2 ? \" white\" : \" black\"\n            }\n            const textElement = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.coordinatesGroup, \"text\", {\n                class: cssClass, x: x, y: y, style: `font-size: ${this.scalingY * 10}px`\n            })\n            if (this.chessboard.state.orientation === COLOR.white) {\n                textElement.textContent = String.fromCharCode(97 + file)\n            } else {\n                textElement.textContent = String.fromCharCode(104 - file)\n            }\n        }\n        for (let rank = 0; rank < 8; rank++) {\n            let x = (this.borderSize / 3.7)\n            let y = this.borderSize + 25 * this.scalingY + rank * this.squareHeight\n            let cssClass = \"coordinate rank\"\n            if (inline) {\n                cssClass += rank % 2 ? \" black\" : \" white\"\n                if (this.chessboard.props.style.borderType === BORDER_TYPE.frame) {\n                    x = x + this.scalingX * 10\n                    y = y - this.scalingY * 15\n                } else {\n                    x = x + this.scalingX * 2\n                    y = y - this.scalingY * 15\n                }\n            }\n            const textElement = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.coordinatesGroup, \"text\", {\n                class: cssClass, x: x, y: y, style: `font-size: ${this.scalingY * 10}px`\n            })\n            if (this.chessboard.state.orientation === COLOR.white) {\n                textElement.textContent = \"\" + (8 - rank)\n            } else {\n                textElement.textContent = \"\" + (1 + rank)\n            }\n        }\n    }\n\n    // Pieces //\n\n    redrawPieces(squares = this.chessboard.state.position.squares) {\n        const childNodes = Array.from(this.piecesGroup.childNodes)\n        const isDragging = this.visualMoveInput.isDragging()\n        for (let i = 0; i < 64; i++) {\n            const pieceName = squares[i]\n            if (pieceName) {\n                const square = _model_Position_js__WEBPACK_IMPORTED_MODULE_1__.Position.indexToSquare(i)\n                this.drawPieceOnSquare(square, pieceName, isDragging && square === this.visualMoveInput.fromSquare)\n            }\n        }\n        for (const childNode of childNodes) {\n            this.piecesGroup.removeChild(childNode)\n        }\n    }\n\n    drawPiece(parentGroup, pieceName, point) {\n        const pieceGroup = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(parentGroup, \"g\", {})\n        pieceGroup.setAttribute(\"data-piece\", pieceName)\n        const transform = (this.svg.createSVGTransform())\n        transform.setTranslate(point.x, point.y)\n        pieceGroup.transform.baseVal.appendItem(transform)\n        const spriteUrl = this.chessboard.props.assetsCache ? \"\" : this.getSpriteUrl()\n        const pieceUse = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(pieceGroup, \"use\", {\n            href: `${spriteUrl}#${pieceName}`, class: \"piece\"\n        })\n        const transformScale = (this.svg.createSVGTransform())\n        transformScale.setScale(this.scalingY, this.scalingY)\n        pieceUse.transform.baseVal.appendItem(transformScale)\n        return pieceGroup\n    }\n\n    drawPieceOnSquare(square, pieceName, hidden = false) {\n        const pieceGroup = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(this.piecesGroup, \"g\", {})\n        pieceGroup.setAttribute(\"data-piece\", pieceName)\n        pieceGroup.setAttribute(\"data-square\", square)\n        if (hidden) {\n            pieceGroup.setAttribute(\"visibility\", \"hidden\")\n        }\n        const point = this.squareToPoint(square)\n        const transform = (this.svg.createSVGTransform())\n        transform.setTranslate(point.x, point.y)\n        pieceGroup.transform.baseVal.appendItem(transform)\n        const spriteUrl = this.chessboard.props.assetsCache ? \"\" : this.getSpriteUrl()\n        const pieceUse = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_3__.Svg.addElement(pieceGroup, \"use\", {\n            href: `${spriteUrl}#${pieceName}`, class: \"piece\"\n        })\n        // center on square\n        const transformTranslate = (this.svg.createSVGTransform())\n        transformTranslate.setTranslate(this.pieceXTranslate, 0)\n        pieceUse.transform.baseVal.appendItem(transformTranslate)\n        // scale\n        const transformScale = (this.svg.createSVGTransform())\n        transformScale.setScale(this.scalingY, this.scalingY)\n        pieceUse.transform.baseVal.appendItem(transformScale)\n        return pieceGroup\n    }\n\n    setPieceVisibility(square, visible = true) {\n        const piece = this.getPieceElement(square)\n        if (piece) {\n            if (visible) {\n                piece.setAttribute(\"visibility\", \"visible\")\n            } else {\n                piece.setAttribute(\"visibility\", \"hidden\")\n            }\n        } else {\n            console.warn(\"no piece on\", square)\n        }\n    }\n\n    getPieceElement(square) {\n        if (!square || square.length < 2) {\n            console.warn(\"invalid square\", square)\n            return null\n        }\n        const piece = this.piecesGroup.querySelector(`g[data-square='${square}']`)\n        if (!piece) {\n            console.warn(\"no piece on\", square)\n            return null\n        }\n        return piece\n    }\n\n    // enable and disable move input //\n\n    enableMoveInput(eventHandler, color = null) {\n        if (this.chessboard.state.moveInputCallback) {\n            throw Error(\"moveInput already enabled\")\n        }\n        if (color === COLOR.white) {\n            this.chessboard.state.inputWhiteEnabled = true\n        } else if (color === COLOR.black) {\n            this.chessboard.state.inputBlackEnabled = true\n        } else {\n            this.chessboard.state.inputWhiteEnabled = true\n            this.chessboard.state.inputBlackEnabled = true\n        }\n        this.chessboard.state.moveInputCallback = eventHandler\n        this.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.moveInputToggled, {enabled: true, color: color})\n        this.visualizeInputState()\n    }\n\n    disableMoveInput() {\n        this.chessboard.state.inputWhiteEnabled = false\n        this.chessboard.state.inputBlackEnabled = false\n        this.chessboard.state.moveInputCallback = null\n        this.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.moveInputToggled, {enabled: false})\n        this.visualizeInputState()\n    }\n\n    // callbacks //\n\n    moveInputStartedCallback(square) {\n        const data = {\n            chessboard: this.chessboard,\n            type: INPUT_EVENT_TYPE.moveInputStarted,\n            square: square, /** square is deprecated, use squareFrom (2023-05-22) */\n            squareFrom: square,\n            piece: this.chessboard.getPiece(square)\n        }\n        if (this.chessboard.state.moveInputCallback) {\n            data.moveInputCallbackResult = this.chessboard.state.moveInputCallback(data)\n        }\n        this.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.moveInput, data)\n        return data.moveInputCallbackResult\n    }\n\n    movingOverSquareCallback(squareFrom, squareTo) {\n        const data = {\n            chessboard: this.chessboard,\n            type: INPUT_EVENT_TYPE.movingOverSquare,\n            squareFrom: squareFrom,\n            squareTo: squareTo,\n            piece: this.chessboard.getPiece(squareFrom)\n        }\n        if (this.chessboard.state.moveInputCallback) {\n            data.moveInputCallbackResult = this.chessboard.state.moveInputCallback(data)\n        }\n        this.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.moveInput, data)\n    }\n\n    validateMoveInputCallback(squareFrom, squareTo) {\n        const data = {\n            chessboard: this.chessboard,\n            type: INPUT_EVENT_TYPE.validateMoveInput,\n            squareFrom: squareFrom,\n            squareTo: squareTo,\n            piece: this.chessboard.getPiece(squareFrom)\n        }\n        if (this.chessboard.state.moveInputCallback) {\n            data.moveInputCallbackResult = this.chessboard.state.moveInputCallback(data)\n        }\n        this.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.moveInput, data)\n        return data.moveInputCallbackResult\n    }\n\n    moveInputCanceledCallback(squareFrom, squareTo, reason) {\n        const data = {\n            chessboard: this.chessboard,\n            type: INPUT_EVENT_TYPE.moveInputCanceled,\n            reason: reason,\n            squareFrom: squareFrom,\n            squareTo: squareTo\n        }\n        if (this.chessboard.state.moveInputCallback) {\n            this.chessboard.state.moveInputCallback(data)\n        }\n        this.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.moveInput, data)\n    }\n\n    moveInputFinishedCallback(squareFrom, squareTo, legalMove) {\n        const data = {\n            chessboard: this.chessboard,\n            type: INPUT_EVENT_TYPE.moveInputFinished,\n            squareFrom: squareFrom,\n            squareTo: squareTo,\n            legalMove: legalMove\n        }\n        if (this.chessboard.state.moveInputCallback) {\n            this.chessboard.state.moveInputCallback(data)\n        }\n        this.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.moveInput, data)\n    }\n\n    // Helpers //\n\n    visualizeInputState() {\n        if (this.chessboard.state) { // fix https://github.com/shaack/cm-chessboard/issues/47\n            if (this.chessboard.state.inputWhiteEnabled || this.chessboard.state.inputBlackEnabled) {\n                this.boardGroup.setAttribute(\"class\", \"board input-enabled\")\n            } else {\n                this.boardGroup.setAttribute(\"class\", \"board\")\n            }\n        }\n    }\n\n    indexToPoint(index) {\n        let x, y\n        if (this.chessboard.state.orientation === COLOR.white) {\n            x = this.borderSize + (index % 8) * this.squareWidth\n            y = this.borderSize + (7 - Math.floor(index / 8)) * this.squareHeight\n        } else {\n            x = this.borderSize + (7 - index % 8) * this.squareWidth\n            y = this.borderSize + (Math.floor(index / 8)) * this.squareHeight\n        }\n        return {x: x, y: y}\n    }\n\n    squareToPoint(square) {\n        const index = _model_Position_js__WEBPACK_IMPORTED_MODULE_1__.Position.squareToIndex(square)\n        return this.indexToPoint(index)\n    }\n\n    getSpriteUrl() {\n        if (_lib_Utils_js__WEBPACK_IMPORTED_MODULE_4__.Utils.isAbsoluteUrl(this.chessboard.props.style.pieces.file)) {\n            return this.chessboard.props.style.pieces.file\n        } else {\n            return this.chessboard.props.assetsUrl + this.chessboard.props.style.pieces.file\n        }\n    }\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/view/ChessboardView.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/view/PositionAnimationsQueue.js":
/*!************************************************************************!*\
  !*** ./node_modules/cm-chessboard/src/view/PositionAnimationsQueue.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ANIMATION_EVENT_TYPE: () => (/* binding */ ANIMATION_EVENT_TYPE),\n/* harmony export */   PositionAnimationsQueue: () => (/* binding */ PositionAnimationsQueue),\n/* harmony export */   PositionsAnimation: () => (/* binding */ PositionsAnimation),\n/* harmony export */   PromiseQueue: () => (/* binding */ PromiseQueue)\n/* harmony export */ });\n/* harmony import */ var _model_Position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/Position.js */ \"./node_modules/cm-chessboard/src/model/Position.js\");\n/* harmony import */ var _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/Svg.js */ \"./node_modules/cm-chessboard/src/lib/Svg.js\");\n/* harmony import */ var _model_Extension_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/Extension.js */ \"./node_modules/cm-chessboard/src/model/Extension.js\");\n/* harmony import */ var _lib_Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/Utils.js */ \"./node_modules/cm-chessboard/src/lib/Utils.js\");\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\n\n\n\n\n/*\n* Thanks to markosyan for the idea of the PromiseQueue\n* https://medium.com/@karenmarkosyan/how-to-manage-promises-into-dynamic-queue-with-vanilla-javascript-9d0d1f8d4df5\n*/\n\nconst ANIMATION_EVENT_TYPE = {\n    start: \"start\",\n    frame: \"frame\",\n    end: \"end\"\n}\n\nclass PromiseQueue {\n\n    constructor() {\n        this.queue = []\n        this.workingOnPromise = false\n        this.stop = false\n    }\n\n    async enqueue(promise) {\n        return new Promise((resolve, reject) => {\n            this.queue.push({\n                promise, resolve, reject,\n            })\n            this.dequeue()\n        })\n    }\n\n    dequeue() {\n        if (this.workingOnPromise) {\n            return\n        }\n        if (this.stop) {\n            this.queue = []\n            this.stop = false\n            return\n        }\n        const entry = this.queue.shift()\n        if (!entry) {\n            return\n        }\n        try {\n            this.workingOnPromise = true\n            entry.promise().then((value) => {\n                this.workingOnPromise = false\n                entry.resolve(value)\n                this.dequeue()\n            }).catch(err => {\n                this.workingOnPromise = false\n                entry.reject(err)\n                this.dequeue()\n            })\n        } catch (err) {\n            this.workingOnPromise = false\n            entry.reject(err)\n            this.dequeue()\n        }\n        return true\n    }\n\n    destroy() {\n        this.stop = true\n    }\n\n}\n\n\nconst CHANGE_TYPE = {\n    move: 0,\n    appear: 1,\n    disappear: 2\n}\n\nclass PositionsAnimation {\n\n    constructor(view, fromPosition, toPosition, duration, callback) {\n        this.view = view\n        if (fromPosition && toPosition) {\n            this.animatedElements = this.createAnimation(fromPosition.squares, toPosition.squares)\n            this.duration = duration\n            this.callback = callback\n            this.frameHandle = requestAnimationFrame(this.animationStep.bind(this))\n        } else {\n            console.error(\"fromPosition\", fromPosition, \"toPosition\", toPosition)\n        }\n        this.view.positionsAnimationTask = _lib_Utils_js__WEBPACK_IMPORTED_MODULE_3__.Utils.createTask()\n        this.view.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.animation, {\n            type: ANIMATION_EVENT_TYPE.start\n        })\n    }\n\n    static seekChanges(fromSquares, toSquares) {\n        const appearedList = [], disappearedList = [], changes = []\n        for (let i = 0; i < 64; i++) {\n            const previousSquare = fromSquares[i]\n            const newSquare = toSquares[i]\n            if (newSquare !== previousSquare) {\n                if (newSquare) {\n                    appearedList.push({piece: newSquare, index: i})\n                }\n                if (previousSquare) {\n                    disappearedList.push({piece: previousSquare, index: i})\n                }\n            }\n        }\n        appearedList.forEach((appeared) => {\n            let shortestDistance = 8\n            let foundMoved = null\n            disappearedList.forEach((disappeared) => {\n                if (appeared.piece === disappeared.piece) {\n                    const moveDistance = PositionsAnimation.squareDistance(appeared.index, disappeared.index)\n                    if (moveDistance < shortestDistance) {\n                        foundMoved = disappeared\n                        shortestDistance = moveDistance\n                    }\n                }\n            })\n            if (foundMoved) {\n                disappearedList.splice(disappearedList.indexOf(foundMoved), 1) // remove from disappearedList, because it is moved now\n                changes.push({\n                    type: CHANGE_TYPE.move,\n                    piece: appeared.piece,\n                    atIndex: foundMoved.index,\n                    toIndex: appeared.index\n                })\n            } else {\n                changes.push({type: CHANGE_TYPE.appear, piece: appeared.piece, atIndex: appeared.index})\n            }\n        })\n        disappearedList.forEach((disappeared) => {\n            changes.push({type: CHANGE_TYPE.disappear, piece: disappeared.piece, atIndex: disappeared.index})\n        })\n        return changes\n    }\n\n    createAnimation(fromSquares, toSquares) {\n        const changes = PositionsAnimation.seekChanges(fromSquares, toSquares)\n        const animatedElements = []\n        changes.forEach((change) => {\n            const animatedItem = {\n                type: change.type\n            }\n            switch (change.type) {\n                case CHANGE_TYPE.move:\n                    animatedItem.element = this.view.getPieceElement(_model_Position_js__WEBPACK_IMPORTED_MODULE_0__.Position.indexToSquare(change.atIndex))\n                    animatedItem.element.parentNode.appendChild(animatedItem.element) // move element to top layer\n                    animatedItem.atPoint = this.view.indexToPoint(change.atIndex)\n                    animatedItem.toPoint = this.view.indexToPoint(change.toIndex)\n                    break\n                case CHANGE_TYPE.appear:\n                    animatedItem.element = this.view.drawPieceOnSquare(_model_Position_js__WEBPACK_IMPORTED_MODULE_0__.Position.indexToSquare(change.atIndex), change.piece)\n                    animatedItem.element.style.opacity = 0\n                    break\n                case CHANGE_TYPE.disappear:\n                    animatedItem.element = this.view.getPieceElement(_model_Position_js__WEBPACK_IMPORTED_MODULE_0__.Position.indexToSquare(change.atIndex))\n                    break\n            }\n            animatedElements.push(animatedItem)\n        })\n        return animatedElements\n    }\n\n    animationStep(time) {\n        if(!this.view || !this.view.chessboard.state) { // board was destroyed\n            return\n        }\n        if (!this.startTime) {\n            this.startTime = time\n        }\n        const timeDiff = time - this.startTime\n        if (timeDiff <= this.duration) {\n            this.frameHandle = requestAnimationFrame(this.animationStep.bind(this))\n        } else {\n            cancelAnimationFrame(this.frameHandle)\n            this.animatedElements.forEach((animatedItem) => {\n                if (animatedItem.type === CHANGE_TYPE.disappear) {\n                    _lib_Svg_js__WEBPACK_IMPORTED_MODULE_1__.Svg.removeElement(animatedItem.element)\n                }\n            })\n            this.view.positionsAnimationTask.resolve()\n            this.view.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.animation, {\n                type: ANIMATION_EVENT_TYPE.end\n            })\n            this.callback()\n            return\n        }\n        const t = Math.min(1, timeDiff / this.duration)\n        let progress = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t // easeInOut\n        if (isNaN(progress) || progress > 0.99) {\n            progress = 1\n        }\n        this.animatedElements.forEach((animatedItem) => {\n            if (animatedItem.element) {\n                switch (animatedItem.type) {\n                    case CHANGE_TYPE.move:\n                        animatedItem.element.transform.baseVal.removeItem(0)\n                        const transform = (this.view.svg.createSVGTransform())\n                        transform.setTranslate(\n                            animatedItem.atPoint.x + (animatedItem.toPoint.x - animatedItem.atPoint.x) * progress,\n                            animatedItem.atPoint.y + (animatedItem.toPoint.y - animatedItem.atPoint.y) * progress)\n                        animatedItem.element.transform.baseVal.appendItem(transform)\n                        break\n                    case CHANGE_TYPE.appear:\n                        animatedItem.element.style.opacity = Math.round(progress * 100) / 100\n                        break\n                    case CHANGE_TYPE.disappear:\n                        animatedItem.element.style.opacity = Math.round((1 - progress) * 100) / 100\n                        break\n                }\n            } else {\n                console.warn(\"animatedItem has no element\", animatedItem)\n            }\n        })\n        this.view.chessboard.state.invokeExtensionPoints(_model_Extension_js__WEBPACK_IMPORTED_MODULE_2__.EXTENSION_POINT.animation, {\n            type: ANIMATION_EVENT_TYPE.frame,\n            progress: progress\n        })\n    }\n\n    static squareDistance(index1, index2) {\n        const file1 = index1 % 8\n        const rank1 = Math.floor(index1 / 8)\n        const file2 = index2 % 8\n        const rank2 = Math.floor(index2 / 8)\n        return Math.max(Math.abs(rank2 - rank1), Math.abs(file2 - file1))\n    }\n\n}\n\nclass PositionAnimationsQueue extends PromiseQueue {\n\n    constructor(chessboard) {\n        super()\n        this.chessboard = chessboard\n    }\n\n    async enqueuePositionChange(positionFrom, positionTo, animated) {\n        if(positionFrom.getFen() === positionTo.getFen()) {\n            return Promise.resolve()\n        } else {\n            return super.enqueue(() => new Promise((resolve) => {\n                let duration = animated ? this.chessboard.props.style.animationDuration : 0\n                if (this.queue.length > 0) {\n                    duration = duration / (1 + Math.pow(this.queue.length / 5, 2))\n                }\n                new PositionsAnimation(this.chessboard.view,\n                    positionFrom, positionTo, animated ? duration : 0,\n                    () => {\n                        if (this.chessboard.view) { // if destroyed, no view anymore\n                            this.chessboard.view.redrawPieces(positionTo.squares)\n                        }\n                        resolve()\n                    }\n                )\n            }))\n        }\n    }\n\n    async enqueueTurnBoard(position, color, animated) {\n        return super.enqueue(() => new Promise((resolve) => {\n            const emptyPosition = new _model_Position_js__WEBPACK_IMPORTED_MODULE_0__.Position(_model_Position_js__WEBPACK_IMPORTED_MODULE_0__.FEN.empty)\n            let duration = animated ? this.chessboard.props.style.animationDuration : 0\n            if(this.queue.length > 0) {\n                duration = duration / (1 + Math.pow(this.queue.length / 5, 2))\n            }\n            new PositionsAnimation(this.chessboard.view,\n                position, emptyPosition, animated ? duration : 0,\n                () => {\n                    this.chessboard.state.orientation = color\n                    this.chessboard.view.redrawBoard()\n                    this.chessboard.view.redrawPieces(emptyPosition.squares)\n                    new PositionsAnimation(this.chessboard.view,\n                        emptyPosition, position, animated ? duration : 0,\n                        () => {\n                            this.chessboard.view.redrawPieces(position.squares)\n                            resolve()\n                        }\n                    )\n                }\n            )\n        }))\n    }\n\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/view/PositionAnimationsQueue.js?");

/***/ }),

/***/ "./node_modules/cm-chessboard/src/view/VisualMoveInput.js":
/*!****************************************************************!*\
  !*** ./node_modules/cm-chessboard/src/view/VisualMoveInput.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MOVE_CANCELED_REASON: () => (/* binding */ MOVE_CANCELED_REASON),\n/* harmony export */   VisualMoveInput: () => (/* binding */ VisualMoveInput)\n/* harmony export */ });\n/* harmony import */ var _lib_Svg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/Svg.js */ \"./node_modules/cm-chessboard/src/lib/Svg.js\");\n/* harmony import */ var _lib_Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/Utils.js */ \"./node_modules/cm-chessboard/src/lib/Utils.js\");\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\n\n\n\nconst MOVE_INPUT_STATE = {\n    waitForInputStart: \"waitForInputStart\",\n    pieceClickedThreshold: \"pieceClickedThreshold\",\n    clickTo: \"clickTo\",\n    secondClickThreshold: \"secondClickThreshold\",\n    dragTo: \"dragTo\",\n    clickDragTo: \"clickDragTo\",\n    moveDone: \"moveDone\",\n    reset: \"reset\"\n}\n\nconst MOVE_CANCELED_REASON = {\n    secondClick: \"secondClick\", // clicked the same piece\n    secondaryClick: \"secondaryClick\", // right click while moving\n    movedOutOfBoard: \"movedOutOfBoard\",\n    draggedBack: \"draggedBack\", // dragged to the start square\n    clickedAnotherPiece: \"clickedAnotherPiece\" // of the same color\n}\n\nconst DRAG_THRESHOLD = 4\n\nclass VisualMoveInput {\n\n    constructor(view) {\n        this.view = view\n        this.chessboard = view.chessboard\n        this.moveInputState = null\n        this.fromSquare = null\n        this.toSquare = null\n\n        this.setMoveInputState(MOVE_INPUT_STATE.waitForInputStart)\n    }\n\n    moveInputStartedCallback(square) {\n        const result = this.view.moveInputStartedCallback(square)\n        if (result) {\n            this.chessboard.state.moveInputProcess = _lib_Utils_js__WEBPACK_IMPORTED_MODULE_1__.Utils.createTask()\n            this.chessboard.state.moveInputProcess.then((result) => {\n                if (this.moveInputState === MOVE_INPUT_STATE.waitForInputStart ||\n                    this.moveInputState === MOVE_INPUT_STATE.moveDone) {\n                    this.view.moveInputFinishedCallback(this.fromSquare, this.toSquare, result)\n                }\n            })\n        }\n        return result\n    }\n\n    movingOverSquareCallback(fromSquare, toSquare) {\n        this.view.movingOverSquareCallback(fromSquare, toSquare)\n    }\n\n    validateMoveInputCallback(fromSquare, toSquare) {\n        const result = this.view.validateMoveInputCallback(fromSquare, toSquare)\n        this.chessboard.state.moveInputProcess.resolve(result)\n        return result\n    }\n\n    moveInputCanceledCallback(fromSquare, toSquare, reason) {\n        this.view.moveInputCanceledCallback(fromSquare, toSquare, reason)\n        this.chessboard.state.moveInputProcess.resolve()\n    }\n\n    setMoveInputState(newState, params = undefined) {\n        const prevState = this.moveInputState\n        this.moveInputState = newState\n\n        switch (newState) {\n\n            case MOVE_INPUT_STATE.waitForInputStart:\n                break\n\n            case MOVE_INPUT_STATE.pieceClickedThreshold:\n                if (MOVE_INPUT_STATE.waitForInputStart !== prevState && MOVE_INPUT_STATE.clickTo !== prevState) {\n                    throw new Error(\"moveInputState\")\n                }\n                if (this.pointerMoveListener) {\n                    removeEventListener(this.pointerMoveListener.type, this.pointerMoveListener)\n                    this.pointerMoveListener = null\n                }\n                if (this.pointerUpListener) {\n                    removeEventListener(this.pointerUpListener.type, this.pointerUpListener)\n                    this.pointerUpListener = null\n                }\n                this.fromSquare = params.square\n                this.toSquare = null\n                this.movedPiece = params.piece\n                this.startPoint = params.point\n                if (!this.pointerMoveListener && !this.pointerUpListener) {\n                    if (params.type === \"mousedown\") {\n                        this.pointerMoveListener = this.onPointerMove.bind(this)\n                        this.pointerMoveListener.type = \"mousemove\"\n                        addEventListener(\"mousemove\", this.pointerMoveListener)\n                        this.pointerUpListener = this.onPointerUp.bind(this)\n                        this.pointerUpListener.type = \"mouseup\"\n                        addEventListener(\"mouseup\", this.pointerUpListener)\n                    } else if (params.type === \"touchstart\") {\n                        this.pointerMoveListener = this.onPointerMove.bind(this)\n                        this.pointerMoveListener.type = \"touchmove\"\n                        addEventListener(\"touchmove\", this.pointerMoveListener)\n                        this.pointerUpListener = this.onPointerUp.bind(this)\n                        this.pointerUpListener.type = \"touchend\"\n                        addEventListener(\"touchend\", this.pointerUpListener)\n                    } else {\n                        throw Error(\"4b74af\")\n                    }\n                    if (!this.contextMenuListener) {\n                        this.contextMenuListener = this.onContextMenu.bind(this)\n                        this.chessboard.view.svg.addEventListener(\"contextmenu\", this.contextMenuListener)\n                    }\n                } else {\n                    throw Error(\"94ad0c\")\n                }\n                break\n\n            case MOVE_INPUT_STATE.clickTo:\n                if (this.draggablePiece) {\n                    _lib_Svg_js__WEBPACK_IMPORTED_MODULE_0__.Svg.removeElement(this.draggablePiece)\n                    this.draggablePiece = null\n                }\n                if (prevState === MOVE_INPUT_STATE.dragTo) {\n                    this.view.setPieceVisibility(params.square, true)\n                }\n                break\n\n            case MOVE_INPUT_STATE.secondClickThreshold:\n                if (MOVE_INPUT_STATE.clickTo !== prevState) {\n                    throw new Error(\"moveInputState\")\n                }\n                this.startPoint = params.point\n                break\n\n            case MOVE_INPUT_STATE.dragTo:\n                if (MOVE_INPUT_STATE.pieceClickedThreshold !== prevState) {\n                    throw new Error(\"moveInputState\")\n                }\n                if (this.view.chessboard.state.inputEnabled()) {\n                    this.view.setPieceVisibility(params.square, false)\n                    this.createDraggablePiece(params.piece)\n                }\n                break\n\n            case MOVE_INPUT_STATE.clickDragTo:\n                if (MOVE_INPUT_STATE.secondClickThreshold !== prevState) {\n                    throw new Error(\"moveInputState\")\n                }\n                if (this.view.chessboard.state.inputEnabled()) {\n                    this.view.setPieceVisibility(params.square, false)\n                    this.createDraggablePiece(params.piece)\n                }\n                break\n\n            case MOVE_INPUT_STATE.moveDone:\n                if ([MOVE_INPUT_STATE.dragTo, MOVE_INPUT_STATE.clickTo, MOVE_INPUT_STATE.clickDragTo].indexOf(prevState) === -1) {\n                    throw new Error(\"moveInputState\")\n                }\n                this.toSquare = params.square\n                if (this.toSquare && this.validateMoveInputCallback(this.fromSquare, this.toSquare)) {\n                    this.chessboard.movePiece(this.fromSquare, this.toSquare, prevState === MOVE_INPUT_STATE.clickTo).then(() => {\n                        if (prevState === MOVE_INPUT_STATE.clickTo) {\n                            this.view.setPieceVisibility(this.toSquare, true)\n                        }\n                        this.setMoveInputState(MOVE_INPUT_STATE.reset)\n                    })\n                } else {\n                    this.view.setPieceVisibility(this.fromSquare, true)\n                    this.setMoveInputState(MOVE_INPUT_STATE.reset)\n                }\n                break\n\n            case MOVE_INPUT_STATE.reset:\n                if (this.fromSquare && !this.toSquare && this.movedPiece) {\n                    this.chessboard.state.position.setPiece(this.fromSquare, this.movedPiece)\n                }\n                this.fromSquare = null\n                this.toSquare = null\n                this.movedPiece = null\n                if (this.draggablePiece) {\n                    _lib_Svg_js__WEBPACK_IMPORTED_MODULE_0__.Svg.removeElement(this.draggablePiece)\n                    this.draggablePiece = null\n                }\n                if (this.pointerMoveListener) {\n                    removeEventListener(this.pointerMoveListener.type, this.pointerMoveListener)\n                    this.pointerMoveListener = null\n                }\n                if (this.pointerUpListener) {\n                    removeEventListener(this.pointerUpListener.type, this.pointerUpListener)\n                    this.pointerUpListener = null\n                }\n                if (this.contextMenuListener) {\n                    removeEventListener(\"contextmenu\", this.contextMenuListener)\n                    this.contextMenuListener = null\n                }\n                this.setMoveInputState(MOVE_INPUT_STATE.waitForInputStart)\n                // set temporarily hidden pieces visible again\n                const hiddenPieces = this.view.piecesGroup.querySelectorAll(\"[visibility=hidden]\")\n                for (let i = 0; i < hiddenPieces.length; i++) {\n                    hiddenPieces[i].removeAttribute(\"visibility\")\n                }\n                break\n\n            default:\n                throw Error(`260b09: moveInputState ${newState}`)\n        }\n    }\n\n    createDraggablePiece(pieceName) {\n        // maybe I should use the existing piece from the board and don't create a new one\n        if (this.draggablePiece) {\n            throw Error(\"draggablePiece already exists\")\n        }\n        this.draggablePiece = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_0__.Svg.createSvg(document.body)\n        this.draggablePiece.classList.add(\"cm-chessboard-draggable-piece\")\n        this.draggablePiece.setAttribute(\"width\", this.view.squareWidth)\n        this.draggablePiece.setAttribute(\"height\", this.view.squareHeight)\n        this.draggablePiece.setAttribute(\"style\", \"pointer-events: none\")\n        this.draggablePiece.name = pieceName\n        const spriteUrl = this.chessboard.props.assetsCache ? \"\" : this.view.getSpriteUrl()\n        const piece = _lib_Svg_js__WEBPACK_IMPORTED_MODULE_0__.Svg.addElement(this.draggablePiece, \"use\", {\n            href: `${spriteUrl}#${pieceName}`\n        })\n        const scaling = this.view.squareHeight / this.chessboard.props.style.pieces.tileSize\n        const transformScale = (this.draggablePiece.createSVGTransform())\n        transformScale.setScale(scaling, scaling)\n        piece.transform.baseVal.appendItem(transformScale)\n    }\n\n    moveDraggablePiece(x, y) {\n        this.draggablePiece.setAttribute(\"style\",\n            `pointer-events: none; position: absolute; left: ${x - (this.view.squareHeight / 2)}px; top: ${y - (this.view.squareHeight / 2)}px`)\n    }\n\n    onPointerDown(e) {\n        if (!(e.type === \"mousedown\" && e.button === 0 || e.type === \"touchstart\")) {\n            return\n        }\n        const square = e.target.getAttribute(\"data-square\")\n        if (!square) { // pointer on square\n            return\n        }\n        const pieceName = this.chessboard.getPiece(square)\n        let color\n        if (pieceName) {\n            color = pieceName ? pieceName.substring(0, 1) : null\n            // allow scrolling, if not pointed on draggable piece\n            if (color === \"w\" && this.chessboard.state.inputWhiteEnabled ||\n                color === \"b\" && this.chessboard.state.inputBlackEnabled) {\n                e.preventDefault()\n            }\n        }\n        if (this.moveInputState !== MOVE_INPUT_STATE.waitForInputStart ||\n            this.chessboard.state.inputWhiteEnabled && color === \"w\" ||\n            this.chessboard.state.inputBlackEnabled && color === \"b\") {\n            let point\n            if (e.type === \"mousedown\") {\n                point = {x: e.clientX, y: e.clientY}\n            } else if (e.type === \"touchstart\") {\n                point = {x: e.touches[0].clientX, y: e.touches[0].clientY}\n            }\n            if (this.moveInputState === MOVE_INPUT_STATE.waitForInputStart && pieceName && this.moveInputStartedCallback(square)) {\n                this.setMoveInputState(MOVE_INPUT_STATE.pieceClickedThreshold, {\n                    square: square,\n                    piece: pieceName,\n                    point: point,\n                    type: e.type\n                })\n            } else if (this.moveInputState === MOVE_INPUT_STATE.clickTo) {\n                if (square === this.fromSquare) {\n                    this.setMoveInputState(MOVE_INPUT_STATE.secondClickThreshold, {\n                        square: square,\n                        piece: pieceName,\n                        point: point,\n                        type: e.type\n                    })\n                } else {\n                    const pieceName = this.chessboard.getPiece(square)\n                    const pieceColor = pieceName ? pieceName.substring(0, 1) : null\n                    const startPieceName = this.chessboard.getPiece(this.fromSquare)\n                    const startPieceColor = startPieceName ? startPieceName.substring(0, 1) : null\n                    if (color && startPieceColor === pieceColor) {\n                        this.moveInputCanceledCallback(this.fromSquare, square, MOVE_CANCELED_REASON.clickedAnotherPiece)\n                        if (this.moveInputStartedCallback(square)) {\n                            this.setMoveInputState(MOVE_INPUT_STATE.pieceClickedThreshold, {\n                                square: square,\n                                piece: pieceName,\n                                point: point,\n                                type: e.type\n                            })\n                        } else {\n                            this.setMoveInputState(MOVE_INPUT_STATE.reset)\n                        }\n                    } else {\n                        this.setMoveInputState(MOVE_INPUT_STATE.moveDone, {square: square})\n                    }\n                }\n            }\n        }\n    }\n\n    onPointerMove(e) {\n        let pageX, pageY, clientX, clientY, target\n        if (e.type === \"mousemove\") {\n            clientX = e.clientX\n            clientY = e.clientY\n            pageX = e.pageX\n            pageY = e.pageY\n            target = e.target\n        } else if (e.type === \"touchmove\") {\n            clientX = e.touches[0].clientX\n            clientY = e.touches[0].clientY\n            pageX = e.touches[0].pageX\n            pageY = e.touches[0].pageY\n            target = document.elementFromPoint(clientX, clientY)\n        }\n        if (this.moveInputState === MOVE_INPUT_STATE.pieceClickedThreshold || this.moveInputState === MOVE_INPUT_STATE.secondClickThreshold) {\n            if (Math.abs(this.startPoint.x - clientX) > DRAG_THRESHOLD || Math.abs(this.startPoint.y - clientY) > DRAG_THRESHOLD) {\n                if (this.moveInputState === MOVE_INPUT_STATE.secondClickThreshold) {\n                    this.setMoveInputState(MOVE_INPUT_STATE.clickDragTo, {\n                        square: this.fromSquare,\n                        piece: this.movedPiece\n                    })\n                } else {\n                    this.setMoveInputState(MOVE_INPUT_STATE.dragTo, {square: this.fromSquare, piece: this.movedPiece})\n                }\n                if (this.view.chessboard.state.inputEnabled()) {\n                    this.moveDraggablePiece(pageX, pageY)\n                }\n            }\n        } else if (this.moveInputState === MOVE_INPUT_STATE.dragTo || this.moveInputState === MOVE_INPUT_STATE.clickDragTo || this.moveInputState === MOVE_INPUT_STATE.clickTo) {\n            if (target && target.getAttribute && target.parentElement === this.view.boardGroup) {\n                const square = target.getAttribute(\"data-square\")\n                if (square !== this.fromSquare && square !== this.toSquare) {\n                    this.toSquare = square\n                    this.movingOverSquareCallback(this.fromSquare, this.toSquare)\n                } else if (square === this.fromSquare && this.toSquare !== null) {\n                    this.toSquare = null\n                    this.movingOverSquareCallback(this.fromSquare, null)\n                }\n            } else if (this.toSquare !== null) {\n                this.toSquare = null\n                this.movingOverSquareCallback(this.fromSquare, null)\n            }\n\n            if (this.view.chessboard.state.inputEnabled() && (this.moveInputState === MOVE_INPUT_STATE.dragTo || this.moveInputState === MOVE_INPUT_STATE.clickDragTo)) {\n                this.moveDraggablePiece(pageX, pageY)\n            }\n        }\n    }\n\n    onPointerUp(e) {\n        let target\n        if (e.type === \"mouseup\") {\n            target = e.target\n        } else if (e.type === \"touchend\") {\n            target = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY)\n        }\n        if (target && target.getAttribute) {\n            const square = target.getAttribute(\"data-square\")\n\n            if (square) {\n                if (this.moveInputState === MOVE_INPUT_STATE.dragTo || this.moveInputState === MOVE_INPUT_STATE.clickDragTo) {\n                    if (this.fromSquare === square) {\n                        if (this.moveInputState === MOVE_INPUT_STATE.clickDragTo) {\n                            this.chessboard.state.position.setPiece(this.fromSquare, this.movedPiece)\n                            this.view.setPieceVisibility(this.fromSquare)\n                            this.moveInputCanceledCallback(square, null, MOVE_CANCELED_REASON.draggedBack)\n                            this.setMoveInputState(MOVE_INPUT_STATE.reset)\n                        } else {\n                            this.setMoveInputState(MOVE_INPUT_STATE.clickTo, {square: square})\n                        }\n                    } else {\n                        this.setMoveInputState(MOVE_INPUT_STATE.moveDone, {square: square})\n                    }\n                } else if (this.moveInputState === MOVE_INPUT_STATE.pieceClickedThreshold) {\n                    this.setMoveInputState(MOVE_INPUT_STATE.clickTo, {square: square})\n                } else if (this.moveInputState === MOVE_INPUT_STATE.secondClickThreshold) {\n                    this.setMoveInputState(MOVE_INPUT_STATE.reset)\n                    this.moveInputCanceledCallback(square, null, MOVE_CANCELED_REASON.secondClick)\n                }\n            } else {\n                this.view.redrawPieces()\n                const moveStartSquare = this.fromSquare\n                this.setMoveInputState(MOVE_INPUT_STATE.reset)\n                this.moveInputCanceledCallback(moveStartSquare, null, MOVE_CANCELED_REASON.movedOutOfBoard)\n            }\n        } else {\n            this.view.redrawPieces()\n            this.setMoveInputState(MOVE_INPUT_STATE.reset)\n        }\n    }\n\n    onContextMenu(e) { // while moving\n        e.preventDefault()\n        this.view.redrawPieces()\n        this.setMoveInputState(MOVE_INPUT_STATE.reset)\n        this.moveInputCanceledCallback(this.fromSquare, null, MOVE_CANCELED_REASON.secondaryClick)\n    }\n\n    isDragging() {\n        return this.moveInputState === MOVE_INPUT_STATE.dragTo || this.moveInputState === MOVE_INPUT_STATE.clickDragTo\n    }\n\n    destroy() {\n        this.setMoveInputState(MOVE_INPUT_STATE.reset)\n    }\n\n}\n\n\n//# sourceURL=webpack://chess-bot-online/./node_modules/cm-chessboard/src/view/VisualMoveInput.js?");

/***/ }),

/***/ "./models/heavy_move_to_int.json":
/*!***************************************!*\
  !*** ./models/heavy_move_to_int.json ***!
  \***************************************/
/***/ ((module) => {

eval("module.exports = /*#__PURE__*/JSON.parse('{\"e8a4\":0,\"a1a8\":1,\"e7h4\":2,\"c6g2\":3,\"b6b5\":4,\"f1f2\":5,\"d1f2\":6,\"e4e3\":7,\"b2b7\":8,\"a2e6\":9,\"d7c5\":10,\"g4e2\":11,\"g6e4\":12,\"d3f3\":13,\"b4a5\":14,\"f6f8\":15,\"f6b2\":16,\"g1e2\":17,\"h5h6\":18,\"f6g6\":19,\"h7g8\":20,\"f6c3\":21,\"b5d7\":22,\"a8d5\":23,\"b8f4\":24,\"a4c5\":25,\"f3h2\":26,\"h5f6\":27,\"h3g3\":28,\"e1a1\":29,\"g4h5\":30,\"c4c6\":31,\"d8d2\":32,\"b1b8\":33,\"f3a3\":34,\"h5e5\":35,\"a1a3\":36,\"e8f6\":37,\"h6b6\":38,\"d2d1q\":39,\"b2g7\":40,\"h4h7\":41,\"b1g1\":42,\"g5c5\":43,\"b4c3\":44,\"f7c7\":45,\"h2c2\":46,\"h1c1\":47,\"g4c8\":48,\"h5f5\":49,\"d3b5\":50,\"g5e6\":51,\"c7e8\":52,\"a1c2\":53,\"g4d7\":54,\"f2f5\":55,\"g2f4\":56,\"b5a4\":57,\"e6c4\":58,\"b5b8\":59,\"d4h8\":60,\"c3h8\":61,\"b8b7\":62,\"c6b5\":63,\"g5f6\":64,\"b6d5\":65,\"f1b1\":66,\"e5g4\":67,\"a2b1\":68,\"b6e3\":69,\"h3g4\":70,\"f6f2\":71,\"h6h5\":72,\"c7d7\":73,\"e8e6\":74,\"d4h4\":75,\"f4d3\":76,\"c7c8q\":77,\"g6h7\":78,\"a5h5\":79,\"c7a6\":80,\"e1e6\":81,\"e7e3\":82,\"c8d8\":83,\"a1c3\":84,\"h3f4\":85,\"h7e4\":86,\"d3b1\":87,\"f5d4\":88,\"g3h3\":89,\"c7g7\":90,\"b3b8\":91,\"h6g4\":92,\"h5g5\":93,\"d8g5\":94,\"f2e1q\":95,\"f8d8\":96,\"a3c4\":97,\"b7b8q\":98,\"b2c3\":99,\"g5f7\":100,\"a7a8r\":101,\"b5a6\":102,\"c5a4\":103,\"g4b4\":104,\"h7h3\":105,\"f1f3\":106,\"e7e8n\":107,\"g5g3\":108,\"b3h3\":109,\"d4b5\":110,\"h6e3\":111,\"c4c3\":112,\"f2a2\":113,\"b1b7\":114,\"b2c4\":115,\"g4g6\":116,\"c6e4\":117,\"a2a1n\":118,\"d8d6\":119,\"c3b5\":120,\"b8a8\":121,\"c3a3\":122,\"e3e5\":123,\"f1a1\":124,\"e7a7\":125,\"g8h6\":126,\"g6g5\":127,\"a3c2\":128,\"a6d3\":129,\"h6e6\":130,\"a5a2\":131,\"e2f3\":132,\"g7b7\":133,\"h1a1\":134,\"g8e6\":135,\"c7g3\":136,\"b6a6\":137,\"e5b2\":138,\"b3d5\":139,\"d3g6\":140,\"h7g5\":141,\"a7g1\":142,\"h8d4\":143,\"e4d5\":144,\"d6f5\":145,\"a8a6\":146,\"b2h8\":147,\"h6h2\":148,\"b7a6\":149,\"h1f2\":150,\"g3a3\":151,\"c8e8\":152,\"f1g2\":153,\"d8d4\":154,\"e2d1\":155,\"h8a8\":156,\"e1a5\":157,\"e5f3\":158,\"g5h6\":159,\"f4d6\":160,\"b7d5\":161,\"g6g1\":162,\"g7g8r\":163,\"a4d4\":164,\"e3e4\":165,\"f3h1\":166,\"d3d6\":167,\"g3g2\":168,\"h7h1\":169,\"f2h2\":170,\"d5c5\":171,\"d6b7\":172,\"e8b8\":173,\"h7c2\":174,\"a6b5\":175,\"c7c8n\":176,\"c5d3\":177,\"f2g4\":178,\"d8c6\":179,\"e6c7\":180,\"f5c8\":181,\"c3c5\":182,\"e8e1\":183,\"h4f2\":184,\"h7f5\":185,\"c7b5\":186,\"h6f5\":187,\"d7e8q\":188,\"f7g7\":189,\"e2a2\":190,\"c3h3\":191,\"g5g8\":192,\"f3h3\":193,\"a8h1\":194,\"b4d2\":195,\"b5a5\":196,\"f5f2\":197,\"d1d3\":198,\"e3d3\":199,\"c4e4\":200,\"a6b7\":201,\"b6a7\":202,\"c1h1\":203,\"c5e5\":204,\"c8b8\":205,\"f3e1\":206,\"a6a1\":207,\"a3c5\":208,\"a6a4\":209,\"d4e5\":210,\"f6a6\":211,\"a6c6\":212,\"d4d5\":213,\"b2d1\":214,\"d7b6\":215,\"a6c4\":216,\"f6g4\":217,\"c2c1q\":218,\"f6h8\":219,\"d7b8\":220,\"d5b5\":221,\"d7f7\":222,\"c6a4\":223,\"a1e5\":224,\"f8e6\":225,\"g8h7\":226,\"c7f7\":227,\"f3g3\":228,\"e4f4\":229,\"d1a4\":230,\"f4h4\":231,\"h3d3\":232,\"c5e4\":233,\"b4e7\":234,\"e3e2\":235,\"h7g8r\":236,\"c7b8\":237,\"a3b2\":238,\"c1g5\":239,\"f1d3\":240,\"h7b7\":241,\"g8f6\":242,\"d6e7\":243,\"f4f8\":244,\"d5d2\":245,\"b7a8n\":246,\"e1f1\":247,\"e1e7\":248,\"h8f6\":249,\"h1a8\":250,\"a1f6\":251,\"f5d5\":252,\"h8e8\":253,\"c2e1\":254,\"g2e4\":255,\"c5d7\":256,\"c4a6\":257,\"f1c4\":258,\"e7e2\":259,\"d6b5\":260,\"d6h6\":261,\"e7b7\":262,\"b6c8\":263,\"c2c6\":264,\"b7c5\":265,\"e4g4\":266,\"g2f1\":267,\"e2g2\":268,\"a7a5\":269,\"c6b4\":270,\"g4g5\":271,\"f8g8\":272,\"h8d8\":273,\"e2e5\":274,\"c5c3\":275,\"b1a2\":276,\"g8d8\":277,\"d7d8r\":278,\"c6e5\":279,\"f2f6\":280,\"g3f2\":281,\"g7g6\":282,\"b7b5\":283,\"b7b6\":284,\"g4a4\":285,\"g3g6\":286,\"d4e4\":287,\"e5c7\":288,\"a7a8\":289,\"h4b4\":290,\"b7c8q\":291,\"h6h3\":292,\"d1c2\":293,\"d8h8\":294,\"e3a3\":295,\"g1d1\":296,\"e7h7\":297,\"d2d1b\":298,\"b3a1\":299,\"f7g6\":300,\"c8g4\":301,\"d3f5\":302,\"d5c4\":303,\"h6g7\":304,\"g5e5\":305,\"f7f4\":306,\"f5f7\":307,\"c3e5\":308,\"e2g1\":309,\"f1f4\":310,\"b7d7\":311,\"c8b6\":312,\"f1a6\":313,\"g7g1\":314,\"b7a5\":315,\"e3d4\":316,\"c7c2\":317,\"e5e2\":318,\"g7a1\":319,\"a2a4\":320,\"e2h5\":321,\"c4c5\":322,\"e4e7\":323,\"c5c2\":324,\"c7h7\":325,\"b5a3\":326,\"b4e4\":327,\"d4a7\":328,\"e7f7\":329,\"d5a8\":330,\"c8c2\":331,\"f7f2\":332,\"a7d7\":333,\"h7h8q\":334,\"g4g8\":335,\"f2d2\":336,\"h5e8\":337,\"g4g3\":338,\"a1d1\":339,\"d4e2\":340,\"d4f2\":341,\"h5h8\":342,\"c2b1q\":343,\"a6g6\":344,\"g1g7\":345,\"d7d4\":346,\"d1h5\":347,\"b2c2\":348,\"e5g3\":349,\"f7g5\":350,\"b7b2\":351,\"c2a2\":352,\"c6f6\":353,\"e6f7\":354,\"e5e7\":355,\"g3b8\":356,\"f5b5\":357,\"e2g4\":358,\"b5d4\":359,\"h3c8\":360,\"c6d6\":361,\"a7a8q\":362,\"a1b2\":363,\"g2g1n\":364,\"b4c5\":365,\"c2c1\":366,\"c2a4\":367,\"e7d5\":368,\"b7a8q\":369,\"d4c5\":370,\"h7d7\":371,\"e2e8\":372,\"c7b7\":373,\"d2d1n\":374,\"b5e8\":375,\"a6a8\":376,\"f4b4\":377,\"e5a1\":378,\"b6b4\":379,\"h2h4\":380,\"g6f8\":381,\"a4a5\":382,\"a4e8\":383,\"e5g5\":384,\"h5f3\":385,\"f6h4\":386,\"d1g1\":387,\"a1a7\":388,\"b6f2\":389,\"c4h4\":390,\"d7f6\":391,\"a8e8\":392,\"f3h4\":393,\"h4g3\":394,\"e1b1\":395,\"f6h5\":396,\"d6b4\":397,\"h6f8\":398,\"e6b6\":399,\"e1c3\":400,\"d5d3\":401,\"g3h2\":402,\"g4h4\":403,\"a4d1\":404,\"b7b1\":405,\"f4f3\":406,\"c5d4\":407,\"c5b7\":408,\"a4a6\":409,\"h3f3\":410,\"c3e1\":411,\"c2e2\":412,\"f7e8\":413,\"d5a2\":414,\"c7d8q\":415,\"b2a1r\":416,\"d7e5\":417,\"e7f8r\":418,\"c7a8\":419,\"f6e7\":420,\"c3a2\":421,\"d4f5\":422,\"a7c7\":423,\"b1d1\":424,\"d1c1\":425,\"b2b8\":426,\"d4e6\":427,\"g8a2\":428,\"e5e3\":429,\"c5c4\":430,\"e7d7\":431,\"h8f8\":432,\"f8f1\":433,\"d1e1\":434,\"d7d8\":435,\"a6b6\":436,\"a3d6\":437,\"g5f4\":438,\"g3d3\":439,\"b6f6\":440,\"f7e8q\":441,\"h2h3\":442,\"d5b4\":443,\"c6c1\":444,\"f1d2\":445,\"b2d2\":446,\"h5d5\":447,\"e2a6\":448,\"e6e7\":449,\"b8b2\":450,\"g2d5\":451,\"f5h3\":452,\"b7d6\":453,\"c4e2\":454,\"e7c8\":455,\"e6e3\":456,\"f4a4\":457,\"g3h4\":458,\"b1f5\":459,\"e6g7\":460,\"f7e5\":461,\"e4c6\":462,\"h7d3\":463,\"g4d4\":464,\"f6e4\":465,\"d4d6\":466,\"d5e5\":467,\"a6f6\":468,\"b5c7\":469,\"g7e8\":470,\"d2d5\":471,\"f3e3\":472,\"d8e8\":473,\"f3d3\":474,\"c2a3\":475,\"b4c2\":476,\"g2h4\":477,\"a2c2\":478,\"h7h8r\":479,\"d4d8\":480,\"g2c6\":481,\"d5b7\":482,\"a4c2\":483,\"c7a7\":484,\"g1g5\":485,\"f8g6\":486,\"e5d4\":487,\"g5c1\":488,\"f3f4\":489,\"b4a2\":490,\"b3c1\":491,\"d3b2\":492,\"b5f5\":493,\"g5g7\":494,\"c5b3\":495,\"d8f8\":496,\"b5h5\":497,\"d2e4\":498,\"d6e6\":499,\"d6g3\":500,\"a8h8\":501,\"d3c2\":502,\"c4d2\":503,\"a1b3\":504,\"d2g2\":505,\"a4b4\":506,\"b2b3\":507,\"e6e4\":508,\"f5e3\":509,\"g6e8\":510,\"d1c3\":511,\"h1h6\":512,\"e6d4\":513,\"d8a8\":514,\"a6b4\":515,\"c6e6\":516,\"f3g1\":517,\"h6g8\":518,\"a1f1\":519,\"g6a6\":520,\"d1g4\":521,\"b7c8\":522,\"f8f4\":523,\"b2e2\":524,\"a6c7\":525,\"d6c8\":526,\"c4g8\":527,\"f5e5\":528,\"d2a2\":529,\"d7g4\":530,\"e2d4\":531,\"b4b6\":532,\"e6d5\":533,\"g2a8\":534,\"c1d2\":535,\"b2f6\":536,\"g5f3\":537,\"d7f5\":538,\"c3c7\":539,\"d3a3\":540,\"c3e2\":541,\"d3d5\":542,\"f4f6\":543,\"b5c4\":544,\"g8c4\":545,\"f8e8\":546,\"g2g7\":547,\"e3g2\":548,\"c3g7\":549,\"d5a5\":550,\"d2f2\":551,\"e7e5\":552,\"a4c4\":553,\"f5c5\":554,\"d7d1\":555,\"g8g4\":556,\"a8b8\":557,\"h8h7\":558,\"e1g3\":559,\"a4a7\":560,\"g8g7\":561,\"c4c2\":562,\"e6e2\":563,\"g8g3\":564,\"f8b8\":565,\"c7h2\":566,\"g2e1\":567,\"b3c5\":568,\"e5e1\":569,\"c3c6\":570,\"c3a1\":571,\"f7f6\":572,\"h8h1\":573,\"d3c3\":574,\"f6g7\":575,\"c8f8\":576,\"g6b6\":577,\"d5d1\":578,\"b2f2\":579,\"b2a1q\":580,\"c1c6\":581,\"h6g6\":582,\"b6c4\":583,\"g2h3\":584,\"d3h7\":585,\"d2d3\":586,\"c2h7\":587,\"d2e3\":588,\"a7f2\":589,\"h3h2\":590,\"c6c4\":591,\"g8g5\":592,\"h4e7\":593,\"e4g2\":594,\"b3b6\":595,\"c2e3\":596,\"b3a4\":597,\"f2e2\":598,\"h4f6\":599,\"f1g1\":600,\"b3a2\":601,\"e8c8\":602,\"e4b4\":603,\"c8h8\":604,\"h1h3\":605,\"h2f2\":606,\"f4g4\":607,\"a7b8q\":608,\"f8c8\":609,\"e4d4\":610,\"e5b8\":611,\"d5e6\":612,\"h5d1\":613,\"f8f3\":614,\"c6b7\":615,\"c5c6\":616,\"f6a1\":617,\"b1c3\":618,\"c2d2\":619,\"e8e5\":620,\"d2f4\":621,\"d4b4\":622,\"d4g7\":623,\"d8g8\":624,\"c1b2\":625,\"b4g4\":626,\"a3h3\":627,\"g3e2\":628,\"d2f3\":629,\"b7f7\":630,\"c6c3\":631,\"g3f3\":632,\"a3e3\":633,\"d8d7\":634,\"h4h6\":635,\"f7h6\":636,\"d4f4\":637,\"b3f3\":638,\"b5b7\":639,\"a8a5\":640,\"a5f5\":641,\"e3h3\":642,\"g2f1q\":643,\"g6d6\":644,\"e8c6\":645,\"b1b2\":646,\"h8h2\":647,\"b8b1\":648,\"g5g4\":649,\"d2d4\":650,\"h7a7\":651,\"b4f8\":652,\"e2d1n\":653,\"e8f7\":654,\"h5h7\":655,\"b2c1r\":656,\"g2b7\":657,\"a8g2\":658,\"d6f7\":659,\"f5g7\":660,\"c7c8r\":661,\"b3g8\":662,\"h1d1\":663,\"b6c6\":664,\"e6g6\":665,\"h5g6\":666,\"f6b6\":667,\"b4a6\":668,\"c6f3\":669,\"f5f8\":670,\"d3e5\":671,\"c7c3\":672,\"a8f3\":673,\"f8b4\":674,\"e5f6\":675,\"d8f7\":676,\"c6a8\":677,\"g7g5\":678,\"d2h6\":679,\"c3c1\":680,\"f3h5\":681,\"a5a7\":682,\"d4c4\":683,\"d1d8\":684,\"c5g5\":685,\"g1h1\":686,\"c3f3\":687,\"f7f8q\":688,\"f4d2\":689,\"d6b8\":690,\"b4e1\":691,\"c2c5\":692,\"f2d1\":693,\"a7a4\":694,\"b4d6\":695,\"b7a7\":696,\"g7h8q\":697,\"b6c7\":698,\"d3d4\":699,\"f1h1\":700,\"d1d5\":701,\"d5c6\":702,\"f4e2\":703,\"f6h6\":704,\"g8h8\":705,\"d2b4\":706,\"a7a6\":707,\"a5a4\":708,\"g1f1\":709,\"f2f4\":710,\"e3h6\":711,\"f6e5\":712,\"d2e2\":713,\"h8h3\":714,\"c3f6\":715,\"e4c5\":716,\"d3d7\":717,\"e4h7\":718,\"a8c8\":719,\"d3a6\":720,\"g3g8\":721,\"g7d4\":722,\"b2a4\":723,\"f2g1n\":724,\"a2b1q\":725,\"e5c3\":726,\"c1c5\":727,\"c5e6\":728,\"h6f7\":729,\"b3b2\":730,\"a5a8\":731,\"b2a1\":732,\"e7d8r\":733,\"b8b4\":734,\"d3e3\":735,\"g3g4\":736,\"f5f1\":737,\"f3a8\":738,\"f3f6\":739,\"b3d4\":740,\"f2h3\":741,\"a6a3\":742,\"d8e6\":743,\"c2b4\":744,\"a6e6\":745,\"g7g8\":746,\"g2b2\":747,\"f4g5\":748,\"f4h5\":749,\"f1f5\":750,\"d4g4\":751,\"c7c6\":752,\"b8b6\":753,\"e2g3\":754,\"a2f2\":755,\"e4e6\":756,\"e6g5\":757,\"h6h8\":758,\"f7b7\":759,\"g7e6\":760,\"h2h1\":761,\"c6d7\":762,\"c6c5\":763,\"a4b3\":764,\"b8c7\":765,\"e7a3\":766,\"b7b8r\":767,\"f6h7\":768,\"f6d4\":769,\"a2g8\":770,\"a2a3\":771,\"g6d3\":772,\"c1f4\":773,\"a8a2\":774,\"g1c5\":775,\"c2d4\":776,\"c4b2\":777,\"d1b1\":778,\"c2b1\":779,\"b5b6\":780,\"e6e5\":781,\"e4b1\":782,\"c3d4\":783,\"g1c1\":784,\"f2d3\":785,\"f7d7\":786,\"h7h5\":787,\"b3b5\":788,\"g1f2\":789,\"c4g4\":790,\"a2a8\":791,\"g6f4\":792,\"f8f5\":793,\"e7d6\":794,\"g3h5\":795,\"e8e7\":796,\"c7c5\":797,\"d4c3\":798,\"f4e5\":799,\"f7h5\":800,\"b6e6\":801,\"c1e3\":802,\"f7g8\":803,\"g8d5\":804,\"d6c4\":805,\"e2d2\":806,\"a5d2\":807,\"c4a2\":808,\"b5a7\":809,\"g5d5\":810,\"a5a1\":811,\"h6d2\":812,\"f2e1\":813,\"a4e4\":814,\"b6b7\":815,\"e1c1\":816,\"c6b6\":817,\"c4d3\":818,\"a3b4\":819,\"a8a4\":820,\"b5g5\":821,\"g7a7\":822,\"a1h1\":823,\"e3g3\":824,\"c3e3\":825,\"b3d1\":826,\"g4h3\":827,\"a7h7\":828,\"b3e3\":829,\"e3g1\":830,\"h3f5\":831,\"b5b3\":832,\"e8g8\":833,\"f1e1\":834,\"a8d8\":835,\"f6e6\":836,\"g2f2\":837,\"d7b5\":838,\"a3c3\":839,\"a7a1\":840,\"h2h1n\":841,\"a2a1b\":842,\"e2f1\":843,\"g3f4\":844,\"c5f5\":845,\"d7c7\":846,\"c7e6\":847,\"e7e1\":848,\"d5f3\":849,\"c6a6\":850,\"b8e5\":851,\"f4g3\":852,\"f6f5\":853,\"c4c8\":854,\"a2c3\":855,\"c6c8\":856,\"e2e7\":857,\"a5e5\":858,\"a1a5\":859,\"d4g1\":860,\"e7c5\":861,\"a2d5\":862,\"a5c5\":863,\"d5d7\":864,\"e2d3\":865,\"b8g3\":866,\"a2h2\":867,\"h7g6\":868,\"e3f2\":869,\"d7a4\":870,\"f5g3\":871,\"c2c1n\":872,\"a4a3\":873,\"g2h1\":874,\"c3a5\":875,\"b6d8\":876,\"f2g1\":877,\"h7f6\":878,\"e1f3\":879,\"b4a4\":880,\"f5g4\":881,\"a8g8\":882,\"b8b3\":883,\"c5c7\":884,\"e3a7\":885,\"e2c2\":886,\"g6f6\":887,\"f3e4\":888,\"e8f8\":889,\"d5f4\":890,\"h1f3\":891,\"b8a7\":892,\"b2g2\":893,\"g7h6\":894,\"d6e8\":895,\"a1a4\":896,\"a4a1\":897,\"b4b5\":898,\"d4c6\":899,\"e2b2\":900,\"a3a4\":901,\"a3a6\":902,\"g1b6\":903,\"b2b6\":904,\"f3b3\":905,\"e2e1q\":906,\"h7h8b\":907,\"d2a5\":908,\"c6c7\":909,\"e1d2\":910,\"b3e6\":911,\"c6h6\":912,\"f2h1\":913,\"f2e3\":914,\"g5g1\":915,\"e1d3\":916,\"d6d8\":917,\"g8g2\":918,\"a8b6\":919,\"h8g8\":920,\"e2f1q\":921,\"a8f8\":922,\"e5h5\":923,\"c8e7\":924,\"e8a8\":925,\"d6e4\":926,\"b5f1\":927,\"b6h6\":928,\"b8c8\":929,\"e4e5\":930,\"e5b5\":931,\"f5e7\":932,\"e4d3\":933,\"e5c4\":934,\"h3h6\":935,\"d1a1\":936,\"e2c4\":937,\"g7e5\":938,\"g6g4\":939,\"c3b3\":940,\"h2g1\":941,\"a8a1\":942,\"d3e1\":943,\"c5d6\":944,\"g4d1\":945,\"a6b8\":946,\"a5d8\":947,\"h3g5\":948,\"f3e5\":949,\"f5d6\":950,\"g1e3\":951,\"f1f8\":952,\"e1h4\":953,\"d4b2\":954,\"d5e3\":955,\"e3f1\":956,\"h8c8\":957,\"e3b3\":958,\"b6a5\":959,\"h5h2\":960,\"h4g6\":961,\"e2e1\":962,\"e4f5\":963,\"c1e1\":964,\"a2a1r\":965,\"e3e1\":966,\"a6a2\":967,\"e4a8\":968,\"d8c7\":969,\"c4b6\":970,\"e2c3\":971,\"b6d4\":972,\"d7d3\":973,\"b2b1\":974,\"c4d6\":975,\"a7a8n\":976,\"b3a3\":977,\"c7c4\":978,\"b7h1\":979,\"h5g4\":980,\"a3a8\":981,\"f5h7\":982,\"c7e5\":983,\"h7e7\":984,\"d1d7\":985,\"f3c6\":986,\"g6e5\":987,\"g6f5\":988,\"a4b6\":989,\"e2f2\":990,\"d3b3\":991,\"d5c7\":992,\"f2d4\":993,\"f2f8\":994,\"e5d3\":995,\"d6d7\":996,\"a7e7\":997,\"f3f1\":998,\"h2g1q\":999,\"h7h2\":1000,\"e7e4\":1001,\"a5g5\":1002,\"c7c1\":1003,\"f2f1\":1004,\"a7a2\":1005,\"f5h6\":1006,\"d3d1\":1007,\"b8h8\":1008,\"b3a5\":1009,\"a5c6\":1010,\"c2g2\":1011,\"a2a1\":1012,\"a8a7\":1013,\"f2f3\":1014,\"g8c8\":1015,\"h3g1\":1016,\"g3c3\":1017,\"g2c2\":1018,\"c8c5\":1019,\"d1e2\":1020,\"a2a7\":1021,\"b8a6\":1022,\"a6e2\":1023,\"e3e8\":1024,\"a4b2\":1025,\"h6a6\":1026,\"h7h4\":1027,\"h8e5\":1028,\"f7f8n\":1029,\"b8e8\":1030,\"e7e8q\":1031,\"e7e8r\":1032,\"g4e4\":1033,\"a1a6\":1034,\"g4h2\":1035,\"e5e4\":1036,\"h6f6\":1037,\"b8f8\":1038,\"h5c5\":1039,\"c2c4\":1040,\"f8h8\":1041,\"b2h2\":1042,\"e4f6\":1043,\"h2g2\":1044,\"h4f4\":1045,\"h8h6\":1046,\"f7a2\":1047,\"c7d6\":1048,\"d7d8q\":1049,\"f7c4\":1050,\"e5h8\":1051,\"g4f6\":1052,\"g6h8\":1053,\"c6d4\":1054,\"f1e2\":1055,\"b2b1r\":1056,\"f3f2\":1057,\"c8c3\":1058,\"d7d2\":1059,\"h2h7\":1060,\"e6c6\":1061,\"d7c8q\":1062,\"c3a4\":1063,\"f5c2\":1064,\"a5d5\":1065,\"c5a5\":1066,\"f5e4\":1067,\"d5g8\":1068,\"e1h1\":1069,\"a5b3\":1070,\"d3d2\":1071,\"g5h5\":1072,\"g2a2\":1073,\"g5a5\":1074,\"e4c2\":1075,\"e6h6\":1076,\"h6d6\":1077,\"c4b5\":1078,\"d6f4\":1079,\"d3d8\":1080,\"d3c4\":1081,\"g1h3\":1082,\"h4d8\":1083,\"g7b2\":1084,\"g1a7\":1085,\"c7e7\":1086,\"e4f3\":1087,\"b4b2\":1088,\"g5e7\":1089,\"e5e6\":1090,\"c5b4\":1091,\"h5g3\":1092,\"a2c1\":1093,\"e5f5\":1094,\"a8e4\":1095,\"g1b1\":1096,\"f7f8\":1097,\"d6a3\":1098,\"c7c8\":1099,\"a6a5\":1100,\"c3c8\":1101,\"h4g4\":1102,\"b4b3\":1103,\"g8f8\":1104,\"a5e1\":1105,\"d8c8\":1106,\"g8e7\":1107,\"f8f6\":1108,\"c5a7\":1109,\"c7a5\":1110,\"h1g1\":1111,\"b1b4\":1112,\"f3f5\":1113,\"b2c1q\":1114,\"b6b3\":1115,\"g3e5\":1116,\"h4e1\":1117,\"b3c2\":1118,\"e4g5\":1119,\"c7b6\":1120,\"g2h2\":1121,\"b1e1\":1122,\"b7a8\":1123,\"b4d5\":1124,\"f5f4\":1125,\"h4h2\":1126,\"d2h2\":1127,\"g4g1\":1128,\"e4c4\":1129,\"a7e3\":1130,\"d5e4\":1131,\"h2c7\":1132,\"b5d6\":1133,\"c4e6\":1134,\"c6e7\":1135,\"h6h4\":1136,\"f7f8b\":1137,\"c1c8\":1138,\"b7e4\":1139,\"e6b3\":1140,\"h5b5\":1141,\"g4e5\":1142,\"g2f3\":1143,\"h3h4\":1144,\"g3e1\":1145,\"h6f4\":1146,\"d4a4\":1147,\"h8g7\":1148,\"h3f1\":1149,\"b6g1\":1150,\"a5b4\":1151,\"f4h3\":1152,\"c4b4\":1153,\"e3c2\":1154,\"d7b7\":1155,\"e8b5\":1156,\"f3d4\":1157,\"c3d1\":1158,\"f2b2\":1159,\"g5g6\":1160,\"b6b1\":1161,\"c2g6\":1162,\"h2f3\":1163,\"a4b5\":1164,\"c5b5\":1165,\"g2g1q\":1166,\"b2a3\":1167,\"d3h3\":1168,\"c8e6\":1169,\"c1c7\":1170,\"h7h8n\":1171,\"c8c7\":1172,\"h7g8q\":1173,\"c8f5\":1174,\"e6f6\":1175,\"d2b1\":1176,\"b8h2\":1177,\"h4h3\":1178,\"a2a6\":1179,\"h8g6\":1180,\"e4c3\":1181,\"b5d5\":1182,\"c4c1\":1183,\"c6g6\":1184,\"h8f7\":1185,\"d1d4\":1186,\"c1c3\":1187,\"g6h5\":1188,\"a3b1\":1189,\"b5e5\":1190,\"b6b2\":1191,\"b8d8\":1192,\"d6d2\":1193,\"g6c2\":1194,\"d7h3\":1195,\"b2c1\":1196,\"c6a7\":1197,\"b8c6\":1198,\"f5h5\":1199,\"c2f2\":1200,\"e1d1\":1201,\"d6c7\":1202,\"f8a3\":1203,\"f6f4\":1204,\"h8h4\":1205,\"e4d2\":1206,\"e7g5\":1207,\"h1g2\":1208,\"h1h8\":1209,\"a1g7\":1210,\"e7e8\":1211,\"c5f8\":1212,\"a7c6\":1213,\"e8h5\":1214,\"g2g5\":1215,\"e1g2\":1216,\"d1f1\":1217,\"a2g2\":1218,\"e6e1\":1219,\"f6g5\":1220,\"g4g7\":1221,\"d6f8\":1222,\"h5h4\":1223,\"d5d8\":1224,\"g4f2\":1225,\"e5f7\":1226,\"e1e5\":1227,\"f4f5\":1228,\"e5a5\":1229,\"g2g4\":1230,\"g1d4\":1231,\"b4b8\":1232,\"g3e3\":1233,\"e3f3\":1234,\"g6c6\":1235,\"g3e4\":1236,\"e4h1\":1237,\"d2g5\":1238,\"h2h1r\":1239,\"b5d3\":1240,\"e2f4\":1241,\"c2d1q\":1242,\"e1e4\":1243,\"a1e1\":1244,\"h6g5\":1245,\"a8b7\":1246,\"d3f4\":1247,\"c4d5\":1248,\"b3g3\":1249,\"e4a4\":1250,\"g2e2\":1251,\"f4d5\":1252,\"d1e3\":1253,\"e5f4\":1254,\"e6f4\":1255,\"e8d6\":1256,\"g7g3\":1257,\"c1b3\":1258,\"b4d4\":1259,\"c2h2\":1260,\"d8b8\":1261,\"b2d3\":1262,\"h2h8\":1263,\"a2b3\":1264,\"a7b6\":1265,\"c5b6\":1266,\"e3d1\":1267,\"e6e8\":1268,\"e3f5\":1269,\"h4h5\":1270,\"c1c2\":1271,\"g6g7\":1272,\"d5h5\":1273,\"d7c6\":1274,\"g5d8\":1275,\"e8h8\":1276,\"f6f7\":1277,\"b6g6\":1278,\"c3g3\":1279,\"d3g3\":1280,\"a2b2\":1281,\"c2e4\":1282,\"f7e7\":1283,\"h5h1\":1284,\"f8h7\":1285,\"h7h8\":1286,\"h6h1\":1287,\"f2a7\":1288,\"h4g5\":1289,\"h1h2\":1290,\"d8d3\":1291,\"d5f5\":1292,\"f2f1b\":1293,\"b6a4\":1294,\"c3d5\":1295,\"f1f6\":1296,\"a4a2\":1297,\"e8c7\":1298,\"e4e2\":1299,\"d4b3\":1300,\"h3e3\":1301,\"c4f7\":1302,\"a1c1\":1303,\"c3b1\":1304,\"c7d8\":1305,\"a2d2\":1306,\"c1e2\":1307,\"g6e7\":1308,\"d7e8\":1309,\"e6f8\":1310,\"a3f8\":1311,\"f4e3\":1312,\"f7e6\":1313,\"h4f5\":1314,\"c5e7\":1315,\"e1c2\":1316,\"d2c2\":1317,\"c5a6\":1318,\"f7h7\":1319,\"e2e4\":1320,\"a3a1\":1321,\"e3c4\":1322,\"g5e4\":1323,\"d1f3\":1324,\"d7f8\":1325,\"h2h6\":1326,\"f6f1\":1327,\"e3e6\":1328,\"c1f1\":1329,\"h1b1\":1330,\"f3f7\":1331,\"e4h4\":1332,\"a5a6\":1333,\"c6h1\":1334,\"b7g2\":1335,\"f5f3\":1336,\"d8d1\":1337,\"b1e4\":1338,\"d2e1r\":1339,\"c4b3\":1340,\"a3g3\":1341,\"h1h5\":1342,\"c6d5\":1343,\"f7f3\":1344,\"f4c4\":1345,\"b7c6\":1346,\"d2d7\":1347,\"e3f4\":1348,\"d4a1\":1349,\"c6b8\":1350,\"f5d7\":1351,\"a6a7\":1352,\"h4h8\":1353,\"a6c5\":1354,\"h4f3\":1355,\"f8f7\":1356,\"g8a8\":1357,\"f8g7\":1358,\"e5g7\":1359,\"g7f8q\":1360,\"f1b5\":1361,\"a7a3\":1362,\"c6d8\":1363,\"e6d8\":1364,\"d5b3\":1365,\"c3e4\":1366,\"b8b5\":1367,\"g5h3\":1368,\"a4f4\":1369,\"b6d7\":1370,\"f3c3\":1371,\"e5d5\":1372,\"f1d1\":1373,\"d6a6\":1374,\"e7e6\":1375,\"a7g7\":1376,\"e4d6\":1377,\"g6g3\":1378,\"f5e6\":1379,\"h4e4\":1380,\"f6d6\":1381,\"c4c7\":1382,\"b3b4\":1383,\"d8h4\":1384,\"a8c7\":1385,\"f2g2\":1386,\"f5h4\":1387,\"d8f6\":1388,\"f3b7\":1389,\"a6c8\":1390,\"b8d6\":1391,\"a5b5\":1392,\"e2h2\":1393,\"b3d3\":1394,\"g7h8\":1395,\"b4a3\":1396,\"b1b6\":1397,\"g4f5\":1398,\"e8d8\":1399,\"b4b1\":1400,\"d4c2\":1401,\"a7b7\":1402,\"d1b2\":1403,\"f4f1\":1404,\"c4d4\":1405,\"f4e6\":1406,\"c4a5\":1407,\"c8a7\":1408,\"g5d2\":1409,\"g2g6\":1410,\"e2b5\":1411,\"h3h7\":1412,\"b1a3\":1413,\"e5d6\":1414,\"c2f5\":1415,\"f7f5\":1416,\"c2a1\":1417,\"c2b2\":1418,\"g5h7\":1419,\"h4g2\":1420,\"d6c6\":1421,\"b4h4\":1422,\"a5c3\":1423,\"d5e7\":1424,\"g7f6\":1425,\"a2e2\":1426,\"c3b2\":1427,\"a4h4\":1428,\"a7b8\":1429,\"b4c4\":1430,\"c1h6\":1431,\"e2e3\":1432,\"h1d5\":1433,\"g1f3\":1434,\"g3c7\":1435,\"d8d5\":1436,\"g3g5\":1437,\"b6a8\":1438,\"h2b2\":1439,\"b4f4\":1440,\"f5d3\":1441,\"h5e2\":1442,\"d3f2\":1443,\"a5b6\":1444,\"e6g4\":1445,\"d8b6\":1446,\"g4h6\":1447,\"c6c2\":1448,\"b2b1q\":1449,\"b4d3\":1450,\"e2e6\":1451,\"b7b8n\":1452,\"d6e5\":1453,\"h1f1\":1454,\"e1b4\":1455,\"e1e3\":1456,\"c4a3\":1457,\"f8h6\":1458,\"f2f1q\":1459,\"h2a2\":1460,\"g7f7\":1461,\"g3b3\":1462,\"h1g3\":1463,\"f4b8\":1464,\"a2f7\":1465,\"d2c1\":1466,\"d7d6\":1467,\"c4a4\":1468,\"c1d3\":1469,\"a3c1\":1470,\"e1f2\":1471,\"d4d1\":1472,\"h5h3\":1473,\"c3c4\":1474,\"h7c7\":1475,\"h1h4\":1476,\"g7c3\":1477,\"h7f7\":1478,\"h3h8\":1479,\"c8c4\":1480,\"c4f1\":1481,\"g1h2\":1482,\"d2e1q\":1483,\"d3c1\":1484,\"g4e6\":1485,\"e8e4\":1486,\"e5d7\":1487,\"b1h7\":1488,\"d5g2\":1489,\"e7f8\":1490,\"e6c8\":1491,\"d2d1\":1492,\"f1h2\":1493,\"c8d7\":1494,\"g5g2\":1495,\"h1c6\":1496,\"h3g2\":1497,\"g8f7\":1498,\"f7h8\":1499,\"d4b6\":1500,\"e4e1\":1501,\"f3d1\":1502,\"c5e3\":1503,\"g6h6\":1504,\"f4d4\":1505,\"a3f3\":1506,\"h7g7\":1507,\"c8b7\":1508,\"g1g2\":1509,\"f6g8\":1510,\"a5b7\":1511,\"c6e8\":1512,\"b5b2\":1513,\"a7b5\":1514,\"a3d3\":1515,\"g3f1\":1516,\"a3a7\":1517,\"d1d6\":1518,\"a4a8\":1519,\"c2c3\":1520,\"e4g6\":1521,\"a6h6\":1522,\"e8g7\":1523,\"g1g6\":1524,\"f5g5\":1525,\"f1c1\":1526,\"b5e2\":1527,\"h2h1q\":1528,\"c7d5\":1529,\"h2g3\":1530,\"c5h5\":1531,\"b5c6\":1532,\"f5g6\":1533,\"e3c3\":1534,\"b5c5\":1535,\"g2g1\":1536,\"d6g6\":1537,\"f5a5\":1538,\"f8d7\":1539,\"c1g1\":1540,\"h2f4\":1541,\"g7f5\":1542,\"g7g8q\":1543,\"c5c1\":1544,\"h2d2\":1545,\"a3e7\":1546,\"d4d2\":1547,\"e8g6\":1548,\"g6h4\":1549,\"e2f1n\":1550,\"e5h2\":1551,\"e8e2\":1552,\"d1b3\":1553,\"d6d5\":1554,\"e2d1q\":1555,\"f2h4\":1556,\"f6e8\":1557,\"b2b5\":1558,\"h4a4\":1559,\"d2c4\":1560,\"f7d8\":1561,\"d1d2\":1562,\"d6b6\":1563,\"f5f6\":1564,\"h3d7\":1565,\"f3g5\":1566,\"f1h3\":1567,\"d3e4\":1568,\"a6f1\":1569,\"g3g7\":1570,\"d2b2\":1571,\"f7b3\":1572,\"h7f8\":1573,\"d2b3\":1574,\"c4f4\":1575,\"c6a5\":1576,\"h7b1\":1577,\"f5b1\":1578,\"e6c5\":1579,\"e6a6\":1580,\"g1g4\":1581,\"b6c5\":1582,\"f1g3\":1583,\"b8d7\":1584,\"a8a3\":1585,\"e5g6\":1586,\"b2a2\":1587,\"d4f3\":1588,\"f8d6\":1589,\"c5d5\":1590,\"g8g1\":1591,\"b7b4\":1592,\"g5h4\":1593,\"c1c4\":1594,\"h2h5\":1595,\"f6c6\":1596,\"g7h5\":1597,\"d2c3\":1598,\"e6f5\":1599,\"d7a7\":1600,\"b5b1\":1601,\"e6d7\":1602,\"d6d3\":1603,\"f4f7\":1604,\"b1b5\":1605,\"b2b4\":1606,\"e7c6\":1607,\"a4d7\":1608,\"f4g6\":1609,\"c4e5\":1610,\"d5h1\":1611,\"e1g1\":1612,\"d6h2\":1613,\"b3d2\":1614,\"c3d3\":1615,\"g1g8\":1616,\"g2g8\":1617,\"c3c2\":1618,\"f2c5\":1619,\"a2c4\":1620,\"g1e1\":1621,\"c5a3\":1622,\"d7d5\":1623,\"h3a3\":1624,\"d8a5\":1625,\"f1e3\":1626,\"e7g6\":1627,\"b3b1\":1628,\"c8h3\":1629,\"c3d2\":1630,\"e6d6\":1631,\"g4f3\":1632,\"a7f7\":1633,\"h1e4\":1634,\"f4h6\":1635,\"h5f4\":1636,\"b7e7\":1637,\"c2d1\":1638,\"e8e3\":1639,\"f7f1\":1640,\"f6f3\":1641,\"d8b7\":1642,\"f3g2\":1643,\"f2c2\":1644,\"d4f6\":1645,\"e3e7\":1646,\"g3d6\":1647,\"d7h7\":1648,\"a5c7\":1649,\"c5c8\":1650,\"c4e3\":1651,\"b1b3\":1652,\"b7f3\":1653,\"e2e1b\":1654,\"d6f6\":1655,\"d5b6\":1656,\"e8d7\":1657,\"b1d2\":1658,\"f6d7\":1659,\"e3g5\":1660,\"b1d3\":1661,\"f4g2\":1662,\"h8a1\":1663,\"d2d1r\":1664,\"e4b7\":1665,\"h7h6\":1666,\"g7f8r\":1667,\"e7g7\":1668,\"e3b6\":1669,\"b6b8\":1670,\"e5c6\":1671,\"b3c4\":1672,\"d5g5\":1673,\"g7d7\":1674,\"d4e3\":1675,\"h8b8\":1676,\"b4c6\":1677,\"e7f5\":1678,\"f2f1n\":1679,\"a1a2\":1680,\"g8b8\":1681,\"f2b6\":1682,\"a5a3\":1683,\"g4e3\":1684,\"b1g6\":1685,\"d7e7\":1686,\"g1g3\":1687,\"b1c1\":1688,\"h5f7\":1689,\"g3g1\":1690,\"b5b4\":1691,\"h4d4\":1692,\"g7h7\":1693,\"h6c6\":1694,\"a3a2\":1695,\"g4c4\":1696,\"g3f5\":1697,\"b4b7\":1698,\"c2c7\":1699,\"h2g4\":1700,\"d5c3\":1701,\"d7e8r\":1702,\"b2d4\":1703,\"a2b4\":1704,\"a3b3\":1705,\"g6g8\":1706,\"b7d8\":1707,\"f8a8\":1708,\"b1a1\":1709,\"b3f7\":1710,\"d1h1\":1711,\"c3b4\":1712,\"a3a5\":1713,\"c1a3\":1714,\"a4c6\":1715,\"a3b5\":1716,\"e1e2\":1717,\"g7c7\":1718,\"h5g7\":1719,\"f2f7\":1720,\"a7c5\":1721,\"a5c4\":1722,\"a8c6\":1723,\"g8b3\":1724,\"c5g1\":1725,\"c1a1\":1726,\"g7g2\":1727,\"f4e4\":1728,\"b2b1b\":1729,\"c8g8\":1730,\"a7d4\":1731,\"e7g8\":1732,\"d2d8\":1733,\"f4f2\":1734,\"g2d2\":1735,\"b6d6\":1736,\"c1d1\":1737,\"c8a6\":1738,\"a4c3\":1739,\"h2e2\":1740,\"b8g8\":1741,\"c2b3\":1742,\"d2c1q\":1743,\"g7f8\":1744,\"a6d6\":1745,\"e3c1\":1746,\"c7f4\":1747,\"f7d5\":1748,\"g2h1q\":1749,\"d6c5\":1750,\"h6h7\":1751,\"e4f2\":1752,\"h1e1\":1753,\"a7c8\":1754,\"c8a8\":1755,\"a1d4\":1756,\"f4h2\":1757,\"b2e5\":1758,\"h5a5\":1759,\"f4c1\":1760,\"d7g7\":1761,\"b7h7\":1762,\"h1h7\":1763,\"f7d6\":1764,\"d7e6\":1765,\"h3h1\":1766,\"f2g1q\":1767,\"h3b3\":1768,\"d3b4\":1769,\"g6e6\":1770,\"f8f2\":1771,\"g2g3\":1772,\"h6c1\":1773,\"c2c1r\":1774,\"d2d6\":1775,\"h2f1\":1776,\"h8h5\":1777,\"f3f8\":1778,\"e1e8\":1779,\"c8d6\":1780,\"d8e7\":1781,\"d3e2\":1782,\"d6d4\":1783,\"a1h8\":1784,\"e7d8q\":1785,\"f7f8r\":1786,\"g6f7\":1787,\"g2e3\":1788,\"b5c3\":1789,\"h3h5\":1790,\"e4g3\":1791,\"b7b3\":1792,\"f1f7\":1793,\"c8c1\":1794,\"h1b7\":1795,\"g7e7\":1796,\"d4d7\":1797,\"g5f5\":1798,\"c1a2\":1799,\"b1c2\":1800,\"d2f1\":1801,\"g5b5\":1802,\"f7a7\":1803,\"d5d4\":1804,\"b1h1\":1805,\"e3c5\":1806,\"c8c6\":1807,\"g1a1\":1808,\"d2e1\":1809,\"e6g8\":1810,\"f6d8\":1811,\"e5e8\":1812,\"d3f1\":1813,\"b1f1\":1814,\"g5e3\":1815,\"f2e4\":1816,\"e4e8\":1817,\"h8c3\":1818,\"g4f4\":1819,\"g7g4\":1820,\"h2b8\":1821,\"e2c1\":1822,\"h2d6\":1823,\"f8e7\":1824,\"c1b1\":1825,\"e7f8q\":1826,\"b7g7\":1827,\"f4c7\":1828,\"d5f7\":1829,\"d3c5\":1830,\"a1g1\":1831,\"b2b1n\":1832,\"e7f6\":1833,\"h3f2\":1834,\"e3d2\":1835,\"e6a2\":1836,\"f2g3\":1837,\"e3g4\":1838,\"f6d5\":1839,\"e7b4\":1840,\"e6h3\":1841,\"f3d5\":1842,\"e7c7\":1843,\"h4c4\":1844,\"a4g4\":1845,\"b7c7\":1846,\"g6b1\":1847,\"g7g8n\":1848,\"f3d2\":1849,\"h3c3\":1850,\"d4d3\":1851,\"f3e2\":1852,\"e5c5\":1853,\"c5f2\":1854,\"a1b1\":1855,\"e2e1r\":1856,\"e7d8\":1857,\"f8c5\":1858,\"d5f6\":1859,\"g8g6\":1860,\"h3e6\":1861,\"b3b7\":1862,\"d7c8\":1863,\"h4h1\":1864,\"d5d6\":1865,\"h2e5\":1866,\"g6g2\":1867,\"g3h1\":1868,\"g4g2\":1869,\"f7g8q\":1870,\"c2c8\":1871,\"g8e8\":1872,\"c7d8r\":1873,\"b7b8\":1874,\"a2a1q\":1875,\"c2d3\":1876,\"e3d5\":1877,\"h8b2\":1878,\"d6d1\":1879,\"c7b8q\":1880,\"a2a5\":1881,\"b3c3\":1882,\"f3g4\":1883}');\n\n//# sourceURL=webpack://chess-bot-online/./models/heavy_move_to_int.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;